# =============================================================================
# Soak Test / Long-Running Test Workflow Template
# =============================================================================
# A template for running extended duration tests (12-72+ hours) with periodic
# health checks and notifications on a remote production server via Tailscale/SSH.
#
# ‚ö†Ô∏è IMPORTANT: GitHub-hosted runners have a 6-hour job timeout limit.
# This template is designed for SELF-HOSTED RUNNERS with no timeout limits.
# See the "Runner Requirements" section below for alternatives.
#
# Features:
# - Manual trigger with configurable duration and options
# - Paper trading / simulation mode support
# - Connects to production server via Tailscale VPN
# - Runs tests remotely via SSH
# - Periodic health checks at configurable intervals
# - Discord notifications for status updates
# - Automatic log collection
# - Clean shutdown and final reporting
#
# Runner Requirements:
# --------------------
# Option 1: Self-hosted runner (RECOMMENDED for soak tests)
#   - No timeout limits
#   - Change `runs-on: ubuntu-latest` to `runs-on: self-hosted`
#   - Ensure runner has Docker, SSH client installed
#
# Option 2: Use scheduled workflows (for GitHub-hosted runners)
#   - Split into separate workflows triggered by cron
#   - Store test state externally (e.g., in a file on the server)
#   - Not covered by this template
#
# Usage:
# ------
# 1. Copy this file to your repo's .github/workflows/ directory
# 2. Update the CUSTOMIZATION SECTION below
# 3. Add required secrets to your repository
# 4. Trigger manually from GitHub Actions UI
#
# Required Secrets:
# -----------------
# - PROD_SSH_KEY: SSH private key for deployment
# - PROD_SSH_USER: SSH username (or set default in env)
# - PROD_SSH_PORT: SSH port (default: 22)
# - PROD_TAILSCALE_IP: Target server's Tailscale IP (100.x.x.x)
# - TAILSCALE_OAUTH_CLIENT_ID: Tailscale OAuth client ID
# - TAILSCALE_OAUTH_SECRET: Tailscale OAuth secret
# - DISCORD_WEBHOOK_ACTIONS: Discord webhook URL (optional)
# - DOCKER_USERNAME: Docker Hub username (if rebuilding images)
# - DOCKER_TOKEN: Docker Hub token (if rebuilding images)
# =============================================================================

name: üß™ Soak Test

on:
    workflow_dispatch:
        inputs:
            duration_hours:
                description: "Test duration in hours"
                required: false
                type: choice
                options:
                    - "1"
                    - "6"
                    - "12"
                    - "24"
                    - "48"
                    - "72"
                default: "48"
            # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            # CUSTOMIZE: Add your test-specific inputs below
            # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            test_targets:
                description: "Test targets (comma-separated)"
                required: false
                type: string
                default: "target1,target2,target3"
            health_check_interval:
                description: "Health check interval"
                required: false
                type: choice
                options:
                    - "15m"
                    - "30m"
                    - "1h"
                    - "2h"
                    - "4h"
                default: "1h"
            rebuild_images:
                description: "Force rebuild Docker images"
                required: false
                type: boolean
                default: false
            clean_state:
                description: "Clean state before starting (fresh DB/volumes)"
                required: false
                type: boolean
                default: false
            notify_on_health_checks:
                description: "Send Discord notifications for each health check"
                required: false
                type: boolean
                default: false

permissions:
    contents: read
    actions: write

# =============================================================================
# CUSTOMIZATION SECTION - Update these for your project
# =============================================================================
env:
    # Project settings
    PROJECT_NAME: my-project
    PROJECT_PATH: ~/my-project
    COMPOSE_FILE: docker-compose.yml

    # Docker settings (leave empty to skip Docker builds)
    REGISTRY: docker.io
    IMAGE_NAME: myuser/my-project

    # Container names to monitor (space-separated)
    MONITORED_CONTAINERS: "my-project_app my-project_worker my-project_db"

    # Test identification
    TEST_ID: "soak-${{ github.run_number }}-${{ github.run_attempt }}"

# =============================================================================
# END CUSTOMIZATION SECTION
# =============================================================================

concurrency:
    group: soak-test-${{ github.repository }}
    cancel-in-progress: false # Don't cancel running soak tests

jobs:
    # =========================================================================
    # STAGE 1: SETUP AND VALIDATION
    # =========================================================================
    setup:
        name: üìã Setup Test
        runs-on: ubuntu-latest
        timeout-minutes: 10
        outputs:
            test_id: ${{ steps.config.outputs.test_id }}
            start_time: ${{ steps.config.outputs.start_time }}
            end_time: ${{ steps.config.outputs.end_time }}
            duration_seconds: ${{ steps.config.outputs.duration_seconds }}
            health_interval_seconds: ${{ steps.config.outputs.health_interval_seconds }}
            health_check_count: ${{ steps.config.outputs.health_check_count }}
            target_host: ${{ steps.target.outputs.host }}
        steps:
            - name: üéØ Configure test parameters
              id: config
              run: |
                  START_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
                  DURATION_HOURS=${{ inputs.duration_hours }}
                  DURATION_SECONDS=$((DURATION_HOURS * 3600))
                  END_TIME=$(date -u -d "+${DURATION_HOURS} hours" +"%Y-%m-%dT%H:%M:%SZ")

                  # Calculate health check interval in seconds
                  INTERVAL="${{ inputs.health_check_interval }}"
                  case "$INTERVAL" in
                    "15m") INTERVAL_SECONDS=900 ;;
                    "30m") INTERVAL_SECONDS=1800 ;;
                    "1h")  INTERVAL_SECONDS=3600 ;;
                    "2h")  INTERVAL_SECONDS=7200 ;;
                    "4h")  INTERVAL_SECONDS=14400 ;;
                    *)     INTERVAL_SECONDS=3600 ;;
                  esac

                  # Calculate number of health checks
                  HEALTH_CHECK_COUNT=$((DURATION_SECONDS / INTERVAL_SECONDS))

                  # Output values
                  echo "test_id=${{ env.TEST_ID }}" >> $GITHUB_OUTPUT
                  echo "start_time=$START_TIME" >> $GITHUB_OUTPUT
                  echo "end_time=$END_TIME" >> $GITHUB_OUTPUT
                  echo "duration_seconds=$DURATION_SECONDS" >> $GITHUB_OUTPUT
                  echo "health_interval_seconds=$INTERVAL_SECONDS" >> $GITHUB_OUTPUT
                  echo "health_check_count=$HEALTH_CHECK_COUNT" >> $GITHUB_OUTPUT

                  # Display configuration
                  echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
                  echo "‚ïë               SOAK TEST CONFIGURATION                        ‚ïë"
                  echo "‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£"
                  echo "‚ïë  Test ID:           ${{ env.TEST_ID }}"
                  echo "‚ïë  Duration:          ${DURATION_HOURS} hours"
                  echo "‚ïë  Health Interval:   ${{ inputs.health_check_interval }}"
                  echo "‚ïë  Health Checks:     ~${HEALTH_CHECK_COUNT} checks planned"
                  echo "‚ïë  Test Targets:      ${{ inputs.test_targets }}"
                  echo "‚ïë  Start:             $START_TIME"
                  echo "‚ïë  Expected End:      $END_TIME"
                  echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"

            - name: ‚öôÔ∏è Configure target host
              id: target
              run: |
                  # Use Tailscale IP from secrets
                  TARGET_HOST="${{ secrets.PROD_TAILSCALE_IP }}"

                  if [ -z "$TARGET_HOST" ]; then
                    echo "‚ùå ERROR: PROD_TAILSCALE_IP secret is not configured!"
                    echo "## ‚ùå Missing: PROD_TAILSCALE_IP" >> $GITHUB_STEP_SUMMARY
                    exit 1
                  fi

                  echo "host=$TARGET_HOST" >> $GITHUB_OUTPUT
                  echo "‚úÖ Target host configured: $TARGET_HOST"

            - name: üîç Validate configuration
              env:
                  HAS_SSH_KEY: ${{ secrets.PROD_SSH_KEY != '' }}
                  HAS_TAILSCALE_IP: ${{ secrets.PROD_TAILSCALE_IP != '' }}
                  HAS_TAILSCALE_ID: ${{ secrets.TAILSCALE_OAUTH_CLIENT_ID != '' }}
                  HAS_TAILSCALE_SECRET: ${{ secrets.TAILSCALE_OAUTH_SECRET != '' }}
              run: |
                  ERRORS=""

                  if [ "$HAS_SSH_KEY" != "true" ]; then
                    ERRORS="${ERRORS}\n  - PROD_SSH_KEY"
                  fi
                  if [ "$HAS_TAILSCALE_IP" != "true" ]; then
                    ERRORS="${ERRORS}\n  - PROD_TAILSCALE_IP"
                  fi
                  if [ "$HAS_TAILSCALE_ID" != "true" ]; then
                    ERRORS="${ERRORS}\n  - TAILSCALE_OAUTH_CLIENT_ID"
                  fi
                  if [ "$HAS_TAILSCALE_SECRET" != "true" ]; then
                    ERRORS="${ERRORS}\n  - TAILSCALE_OAUTH_SECRET"
                  fi

                  if [ -n "$ERRORS" ]; then
                    echo -e "‚ùå Missing required secrets:$ERRORS"
                    exit 1
                  fi

                  echo "‚úÖ All required secrets present"

            - name: ‚ö†Ô∏è Verify runner capability
              run: |
                  DURATION_HOURS=${{ inputs.duration_hours }}

                  if [ "$DURATION_HOURS" -gt 5 ]; then
                    echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
                    echo "‚ïë  ‚ö†Ô∏è  WARNING: Long-duration test selected                    ‚ïë"
                    echo "‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£"
                    echo "‚ïë  Duration: ${DURATION_HOURS} hours                                          "
                    echo "‚ïë                                                              ‚ïë"
                    echo "‚ïë  GitHub-hosted runners have a 6-hour job timeout.            ‚ïë"
                    echo "‚ïë  For tests longer than ~5 hours, ensure you're using a       ‚ïë"
                    echo "‚ïë  self-hosted runner with no timeout limits.                  ‚ïë"
                    echo "‚ïë                                                              ‚ïë"
                    echo "‚ïë  To use self-hosted runner, change 'runs-on' in the          ‚ïë"
                    echo "‚ïë  'run-test' job from 'ubuntu-latest' to 'self-hosted'.       ‚ïë"
                    echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
                  fi

    # =========================================================================
    # STAGE 2: BUILD IMAGES (Optional)
    # =========================================================================
    build:
        name: üê≥ Build Images
        runs-on: ubuntu-latest
        timeout-minutes: 30
        needs: setup
        if: ${{ inputs.rebuild_images }}
        steps:
            - name: üì• Checkout code
              uses: actions/checkout@v4

            # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            # CUSTOMIZE: Update this section for your Docker build process
            # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            - name: üê≥ Build and Push
              uses: nuniesmith/actions/.github/actions/docker-build-push@main
              with:
                  image-name: ${{ env.IMAGE_NAME }}
                  username: ${{ secrets.DOCKER_USERNAME }}
                  password: ${{ secrets.DOCKER_TOKEN }}
                  dockerfile: Dockerfile
                  context: .
                  platforms: linux/amd64
                  push: true
                  tags: |
                      ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
                      ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}

    # =========================================================================
    # STAGE 3: DEPLOY TEST ENVIRONMENT VIA TAILSCALE/SSH
    # =========================================================================
    deploy:
        name: üöÄ Deploy Test Environment
        runs-on: ubuntu-latest
        timeout-minutes: 20
        needs: [setup, build]
        if: always() && needs.setup.result == 'success' && (needs.build.result == 'success' || needs.build.result == 'skipped')
        outputs:
            deployed: ${{ steps.deploy.outputs.deployed }}
        steps:
            - name: üì• Checkout code
              uses: actions/checkout@v4

            - name: üîå Connect to Tailscale
              uses: nuniesmith/actions/.github/actions/tailscale-connect@main
              with:
                  oauth-client-id: ${{ secrets.TAILSCALE_OAUTH_CLIENT_ID }}
                  oauth-secret: ${{ secrets.TAILSCALE_OAUTH_SECRET }}
                  target-ip: ${{ needs.setup.outputs.target_host }}
                  target-ssh-port: ${{ secrets.PROD_SSH_PORT || '22' }}

            - name: üöÄ Deploy Test Environment
              id: deploy
              uses: nuniesmith/actions/.github/actions/ssh-deploy@main
              with:
                  host: ${{ needs.setup.outputs.target_host }}
                  port: ${{ secrets.PROD_SSH_PORT || '22' }}
                  username: ${{ secrets.PROD_SSH_USER || 'actions' }}
                  ssh-key: ${{ secrets.PROD_SSH_KEY }}
                  project-path: ${{ env.PROJECT_PATH }}
                  git-pull: "true"
                  git-branch: ${{ github.ref_name }}
                  docker-pull: "true"
                  # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                  # CUSTOMIZE: Update deployment commands for your project
                  # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                  pre-deploy-command: |
                      echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
                      echo "üß™ PREPARING SOAK TEST ENVIRONMENT"
                      echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"

                      # System info
                      echo "üñ•Ô∏è  Host: $(hostname) | $(date)"
                      echo "üíæ Disk: $(df -h / | tail -1 | awk '{print $4}') free | Memory: $(free -h | grep Mem | awk '{print $7}') available"

                      # Create test configuration
                      TEST_ENV_FILE=".env.soak-test"
                      cat > "$TEST_ENV_FILE" << 'ENVEOF'
                      # Soak Test Configuration
                      # Test ID: ${{ needs.setup.outputs.test_id }}
                      # Generated: ${{ needs.setup.outputs.start_time }}

                      # Test Mode Settings
                      TEST_MODE=true
                      SIMULATION_MODE=true

                      # Test Parameters
                      TEST_ID=${{ needs.setup.outputs.test_id }}
                      TEST_START_TIME=${{ needs.setup.outputs.start_time }}
                      TEST_DURATION_HOURS=${{ inputs.duration_hours }}
                      TEST_TARGETS=${{ inputs.test_targets }}
                      ENVEOF

                      # Merge with existing .env if present (keep passwords, etc.)
                      if [ -f .env ]; then
                        grep -E "^[A-Z_]+=" .env | grep -v "^TEST_" >> "$TEST_ENV_FILE" 2>/dev/null || true
                      fi

                      # Create log directory
                      TEST_LOG_DIR="logs/soak-test-$(date +%Y%m%d-%H%M%S)"
                      mkdir -p "$TEST_LOG_DIR"
                      echo "TEST_LOG_DIR=$TEST_LOG_DIR" >> "$TEST_ENV_FILE"

                      echo "‚úÖ Test configuration created: $TEST_ENV_FILE"

                  deploy-command: |
                      echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
                      echo "üöÄ STARTING SOAK TEST"
                      echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"

                      # Docker login (if credentials available)
                      if [ -n "${{ secrets.DOCKER_TOKEN }}" ]; then
                        echo "${{ secrets.DOCKER_TOKEN }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin docker.io || true
                      fi

                      # Source test environment
                      set -a && source .env.soak-test && set +a

                      # Clean state if requested
                      if [ "${{ inputs.clean_state }}" = "true" ]; then
                        echo "üßπ Cleaning existing state..."
                        docker compose -f ${{ env.COMPOSE_FILE }} down -v --remove-orphans 2>/dev/null || true
                      else
                        echo "üõë Stopping existing containers..."
                        docker compose -f ${{ env.COMPOSE_FILE }} down --remove-orphans 2>/dev/null || true
                      fi

                      # Pull latest images
                      echo "üì• Pulling images..."
                      docker compose -f ${{ env.COMPOSE_FILE }} pull --ignore-pull-failures 2>&1 || true

                      # Start services
                      echo "üèóÔ∏è Starting services..."
                      docker compose -f ${{ env.COMPOSE_FILE }} up -d

                      echo "‚è≥ Waiting for services to initialize..."
                      sleep 30

                      # Start log collection
                      TEST_LOG_DIR=$(grep TEST_LOG_DIR .env.soak-test | cut -d= -f2)
                      nohup docker compose -f ${{ env.COMPOSE_FILE }} logs -f --timestamps > "$TEST_LOG_DIR/all-services.log" 2>&1 &
                      echo $! > "$TEST_LOG_DIR/log-collector.pid"

                      # Save test metadata
                      cat > "$TEST_LOG_DIR/test-info.json" << EOF
                      {
                        "test_id": "${{ needs.setup.outputs.test_id }}",
                        "test_type": "soak_test",
                        "start_time": "${{ needs.setup.outputs.start_time }}",
                        "expected_end_time": "${{ needs.setup.outputs.end_time }}",
                        "duration_hours": ${{ inputs.duration_hours }},
                        "test_targets": "${{ inputs.test_targets }}",
                        "github_run_id": "${{ github.run_id }}",
                        "github_sha": "${{ github.sha }}",
                        "triggered_by": "${{ github.actor }}"
                      }
                      EOF

                      # Display status
                      echo ""
                      echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
                      echo "‚ïë              SOAK TEST DEPLOYED SUCCESSFULLY                 ‚ïë"
                      echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
                      echo ""
                      echo "üìä Container Status:"
                      docker ps --format "table {{.Names}}\t{{.Status}}" | head -15
                      echo ""
                      echo "üìÅ Logs: $TEST_LOG_DIR"

                      # Verify deployment
                      RUNNING=$(docker ps --format '{{.Names}}' | wc -l)
                      if [ "$RUNNING" -ge 1 ]; then
                        echo "deployed=true" >> $GITHUB_OUTPUT
                      else
                        echo "deployed=false" >> $GITHUB_OUTPUT
                      fi

                  post-deploy-command: |
                      echo ""
                      echo "üîç Initial health check..."
                      docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
                      echo ""
                      echo "‚úÖ Deployment complete! Test is running on remote server."

            - name: üì£ Notify test started
              if: steps.deploy.outputs.deployed == 'true'
              uses: nuniesmith/actions/.github/actions/discord-notify@main
              continue-on-error: true
              with:
                  webhook-url: ${{ secrets.DISCORD_WEBHOOK_ACTIONS }}
                  title: "üß™ Soak Test Started"
                  description: "Soak test has been deployed and started on production server."
                  status: success
                  include-repo-info: true
                  fields: |
                      Test ID|${{ needs.setup.outputs.test_id }}|true
                      Duration|${{ inputs.duration_hours }} hours|true
                      Targets|${{ inputs.test_targets }}|true
                      Health Interval|${{ inputs.health_check_interval }}|true
                      Start Time|${{ needs.setup.outputs.start_time }}|false
                      Expected End|${{ needs.setup.outputs.end_time }}|false

    # =========================================================================
    # STAGE 4: RUN TEST WITH HEALTH CHECKS VIA SSH
    # =========================================================================
    # ‚ö†Ô∏è This job runs for the full duration of the test.
    # For GitHub-hosted runners, max is ~6 hours.
    # For longer tests, use a self-hosted runner.
    # =========================================================================
    run-test:
        name: üèÉ Run Soak Test
        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        # IMPORTANT: For tests > 5 hours, change to: runs-on: self-hosted
        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        runs-on: ubuntu-latest
        timeout-minutes: 21600 # 15 days max (self-hosted), GitHub-hosted will use 6h limit
        needs: [setup, deploy]
        if: needs.deploy.outputs.deployed == 'true'
        steps:
            - name: üîå Connect to Tailscale
              uses: nuniesmith/actions/.github/actions/tailscale-connect@main
              with:
                  oauth-client-id: ${{ secrets.TAILSCALE_OAUTH_CLIENT_ID }}
                  oauth-secret: ${{ secrets.TAILSCALE_OAUTH_SECRET }}
                  target-ip: ${{ needs.setup.outputs.target_host }}
                  target-ssh-port: ${{ secrets.PROD_SSH_PORT || '22' }}

            - name: üèÉ Run test with periodic health checks via SSH
              env:
                  DURATION_SECONDS: ${{ needs.setup.outputs.duration_seconds }}
                  HEALTH_INTERVAL: ${{ needs.setup.outputs.health_interval_seconds }}
                  TEST_ID: ${{ needs.setup.outputs.test_id }}
                  SSH_HOST: ${{ needs.setup.outputs.target_host }}
                  SSH_PORT: ${{ secrets.PROD_SSH_PORT || '22' }}
                  SSH_USER: ${{ secrets.PROD_SSH_USER || 'actions' }}
                  SSH_KEY: ${{ secrets.PROD_SSH_KEY }}
                  NOTIFY_HEALTH_CHECKS: ${{ inputs.notify_on_health_checks }}
                  DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK_ACTIONS }}
                  PROJECT_PATH: ${{ env.PROJECT_PATH }}
                  COMPOSE_FILE: ${{ env.COMPOSE_FILE }}
                  MONITORED_CONTAINERS: ${{ env.MONITORED_CONTAINERS }}
              run: |
                  # Setup SSH key
                  mkdir -p ~/.ssh
                  chmod 700 ~/.ssh
                  echo "$SSH_KEY" > ~/.ssh/soak_test_key
                  chmod 600 ~/.ssh/soak_test_key

                  # SSH config for stable long-running connections
                  cat >> ~/.ssh/config << EOF
                  Host soak-test-target
                      HostName $SSH_HOST
                      Port $SSH_PORT
                      User $SSH_USER
                      IdentityFile ~/.ssh/soak_test_key
                      StrictHostKeyChecking no
                      UserKnownHostsFile /dev/null
                      ConnectTimeout 30
                      ServerAliveInterval 60
                      ServerAliveCountMax 10
                  EOF

                  ssh_cmd() {
                    ssh soak-test-target "$1"
                  }

                  send_discord() {
                    if [ -n "$DISCORD_WEBHOOK" ] && [ "$NOTIFY_HEALTH_CHECKS" = "true" ]; then
                      local title="$1"
                      local desc="$2"
                      local color="$3"
                      curl -s -H "Content-Type: application/json" \
                        -d "{\"embeds\":[{\"title\":\"$title\",\"description\":\"$desc\",\"color\":$color}]}" \
                        "$DISCORD_WEBHOOK" > /dev/null 2>&1 || true
                    fi
                  }

                  echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
                  echo "‚ïë              SOAK TEST MONITORING STARTED                    ‚ïë"
                  echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
                  echo ""
                  echo "Test ID: $TEST_ID"
                  echo "Target Host: $SSH_HOST"
                  echo "Duration: $((DURATION_SECONDS / 3600)) hours"
                  echo "Health check interval: $((HEALTH_INTERVAL / 60)) minutes"
                  echo ""

                  START_TIME=$(date +%s)
                  END_TIME=$((START_TIME + DURATION_SECONDS))
                  CHECK_NUMBER=0
                  FAILURES=0

                  while [ $(date +%s) -lt $END_TIME ]; do
                    CHECK_NUMBER=$((CHECK_NUMBER + 1))
                    ELAPSED=$(($(date +%s) - START_TIME))
                    ELAPSED_HOURS=$((ELAPSED / 3600))
                    ELAPSED_MINS=$(((ELAPSED % 3600) / 60))
                    REMAINING=$((END_TIME - $(date +%s)))
                    REMAINING_HOURS=$((REMAINING / 3600))

                    echo ""
                    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
                    echo "üè• HEALTH CHECK #$CHECK_NUMBER (via SSH to $SSH_HOST)"
                    echo "   Elapsed: ${ELAPSED_HOURS}h ${ELAPSED_MINS}m | Remaining: ~${REMAINING_HOURS}h"
                    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"

                    # Run health check via SSH to remote server
                    HEALTH_OUTPUT=$(ssh_cmd "cd $PROJECT_PATH && \
                      echo 'üìä Container Status:' && \
                      docker ps --format 'table {{.Names}}\t{{.Status}}\t{{.RunningFor}}' && \
                      echo '' && \
                      echo 'üíæ Resource Usage:' && \
                      docker stats --no-stream --format 'table {{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}' | head -10 && \
                      echo '' && \
                      echo 'üìù Recent Logs (last 5 lines per container):' && \
                      for c in $MONITORED_CONTAINERS; do \
                        echo \"--- \$c ---\" && \
                        docker logs --tail 5 \"\$c\" 2>&1 || echo 'Container not found'; \
                      done" 2>&1) || HEALTH_OUTPUT="‚ùå SSH connection failed"

                    echo "$HEALTH_OUTPUT"

                    # Check for failures
                    if echo "$HEALTH_OUTPUT" | grep -qi "error\|fail\|unhealthy\|exited"; then
                      FAILURES=$((FAILURES + 1))
                      echo ""
                      echo "‚ö†Ô∏è Potential issue detected (failure count: $FAILURES)"
                      send_discord "‚ö†Ô∏è Soak Test Health Warning" "Check #$CHECK_NUMBER found potential issues. Test ID: $TEST_ID" "16776960"
                    else
                      echo ""
                      echo "‚úÖ Health check passed"
                    fi

                    # Milestone notifications (25%, 50%, 75%)
                    PROGRESS=$((ELAPSED * 100 / DURATION_SECONDS))
                    if [ "$PROGRESS" -ge 25 ] && [ "$PROGRESS" -lt 30 ] && [ "$CHECK_NUMBER" -gt 1 ]; then
                      send_discord "üè• Soak Test: 25% Complete" "Test ID: $TEST_ID - Running for ${ELAPSED_HOURS}h" "3447003"
                    elif [ "$PROGRESS" -ge 50 ] && [ "$PROGRESS" -lt 55 ]; then
                      send_discord "üè• Soak Test: 50% Complete (Halfway!)" "Test ID: $TEST_ID - Running for ${ELAPSED_HOURS}h" "3447003"
                    elif [ "$PROGRESS" -ge 75 ] && [ "$PROGRESS" -lt 80 ]; then
                      send_discord "üè• Soak Test: 75% Complete" "Test ID: $TEST_ID - Running for ${ELAPSED_HOURS}h" "3447003"
                    fi

                    # Wait for next health check (unless test is complete)
                    if [ $(date +%s) -lt $END_TIME ]; then
                      SLEEP_TIME=$HEALTH_INTERVAL
                      # Don't sleep past end time
                      if [ $(($(date +%s) + SLEEP_TIME)) -gt $END_TIME ]; then
                        SLEEP_TIME=$((END_TIME - $(date +%s)))
                      fi
                      if [ "$SLEEP_TIME" -gt 0 ]; then
                        echo ""
                        echo "‚è≥ Next health check in $((SLEEP_TIME / 60)) minutes..."
                        sleep $SLEEP_TIME
                      fi
                    fi
                  done

                  echo ""
                  echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
                  echo "‚ïë              SOAK TEST DURATION COMPLETE                     ‚ïë"
                  echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
                  echo ""
                  echo "Total health checks: $CHECK_NUMBER"
                  echo "Potential issues detected: $FAILURES"

                  # Cleanup SSH key
                  rm -f ~/.ssh/soak_test_key

    # =========================================================================
    # STAGE 5: FINAL REPORT VIA SSH
    # =========================================================================
    final-report:
        name: üìä Final Report
        runs-on: ubuntu-latest
        timeout-minutes: 15
        needs: [setup, deploy, run-test]
        if: always() && needs.deploy.outputs.deployed == 'true'
        outputs:
            end_time: ${{ steps.end_time.outputs.value }}
        steps:
            - name: üîå Connect to Tailscale
              uses: nuniesmith/actions/.github/actions/tailscale-connect@main
              with:
                  oauth-client-id: ${{ secrets.TAILSCALE_OAUTH_CLIENT_ID }}
                  oauth-secret: ${{ secrets.TAILSCALE_OAUTH_SECRET }}
                  target-ip: ${{ needs.setup.outputs.target_host }}
                  target-ssh-port: ${{ secrets.PROD_SSH_PORT || '22' }}

            - name: üìä Generate final report via SSH
              id: report
              uses: appleboy/ssh-action@v1.0.3
              with:
                  host: ${{ needs.setup.outputs.target_host }}
                  port: ${{ secrets.PROD_SSH_PORT || '22' }}
                  username: ${{ secrets.PROD_SSH_USER || 'actions' }}
                  key: ${{ secrets.PROD_SSH_KEY }}
                  script: |
                      cd ${{ env.PROJECT_PATH }}
                      END_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

                      echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
                      echo "üìä FINAL REPORT - ${{ needs.setup.outputs.test_id }}"
                      echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"

                      TEST_LOG_DIR=$(grep TEST_LOG_DIR .env.soak-test 2>/dev/null | cut -d= -f2 || echo "logs")

                      echo ""
                      echo "üì¶ Final Container Status:"
                      docker ps -a --format "table {{.Names}}\t{{.Status}}\t{{.RunningFor}}"

                      echo ""
                      echo "üíæ Final Resource Usage:"
                      docker stats --no-stream --format "table {{.Name}}\t{{.MemUsage}}\t{{.MemPerc}}\t{{.CPUPerc}}"

                      echo ""
                      echo "‚ö†Ô∏è Error Summary:"
                      for container in ${{ env.MONITORED_CONTAINERS }}; do
                        ERROR_COUNT=$(docker logs "$container" 2>&1 | grep -ci "error\|panic\|fatal" || echo "0")
                        echo "  $container: $ERROR_COUNT errors"
                      done

                      echo ""
                      echo "üìÅ Log files saved to: $TEST_LOG_DIR"
                      ls -la "$TEST_LOG_DIR" 2>/dev/null || echo "Log directory not found"

                      # Stop log collector
                      if [ -f "$TEST_LOG_DIR/log-collector.pid" ]; then
                        kill $(cat "$TEST_LOG_DIR/log-collector.pid") 2>/dev/null || true
                      fi

                      # Create summary file
                      cat > "$TEST_LOG_DIR/final-report.txt" << EOF
                      ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                      SOAK TEST - FINAL REPORT
                      ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                      Test ID: ${{ needs.setup.outputs.test_id }}
                      Duration: ${{ inputs.duration_hours }} hours
                      Start: ${{ needs.setup.outputs.start_time }}
                      End: $END_TIME
                      Test Targets: ${{ inputs.test_targets }}

                      Container Status:
                      $(docker ps -a --format "{{.Names}}: {{.Status}}")

                      Resource Usage:
                      $(docker stats --no-stream --format "{{.Name}}: {{.MemUsage}} ({{.CPUPerc}} CPU)")
                      ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                      EOF

                      echo ""
                      echo "‚úÖ Test completed!"

            - name: üïê Capture end time
              id: end_time
              run: echo "value=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" >> $GITHUB_OUTPUT

            - name: üì£ Notify test complete
              uses: nuniesmith/actions/.github/actions/discord-notify@main
              continue-on-error: true
              with:
                  webhook-url: ${{ secrets.DISCORD_WEBHOOK_ACTIONS }}
                  title: "‚úÖ Soak Test Complete!"
                  description: "The ${{ inputs.duration_hours }}-hour soak test has finished on production server."
                  status: ${{ needs.run-test.result == 'success' && 'success' || 'warning' }}
                  include-repo-info: true
                  fields: |
                      Test ID|${{ needs.setup.outputs.test_id }}|true
                      Duration|${{ inputs.duration_hours }} hours|true
                      Test Targets|${{ inputs.test_targets }}|true
                      Result|${{ needs.run-test.result }}|true
                      Start Time|${{ needs.setup.outputs.start_time }}|false
                      End Time|${{ steps.end_time.outputs.value }}|false

    # =========================================================================
    # CLEANUP ON FAILURE
    # =========================================================================
    cleanup-on-failure:
        name: üßπ Cleanup on Failure
        runs-on: ubuntu-latest
        timeout-minutes: 10
        needs: [setup, deploy, run-test]
        if: failure()
        steps:
            - name: üì£ Notify failure
              uses: nuniesmith/actions/.github/actions/discord-notify@main
              continue-on-error: true
              with:
                  webhook-url: ${{ secrets.DISCORD_WEBHOOK_ACTIONS }}
                  title: "‚ùå Soak Test Failed"
                  description: "The soak test failed to complete successfully on production server."
                  status: failure
                  include-repo-info: true
                  fields: |
                      Test ID|${{ needs.setup.outputs.test_id }}|true
                      Failed Stage|Check workflow logs|true
                      Duration Planned|${{ inputs.duration_hours }} hours|true
