# =============================================================================
# FKS CI/CD Pipeline
# =============================================================================
# Streamlined pipeline using reusable composite actions from nuniesmith/actions.
#
# Pipeline Flow:
# 1. Setup - Determine environment, build strategy, target host
# 2. Tests - Rust & KMP (skippable)
# 3. Docker Build & Push - Multi-service matrix build (dockerhub strategy only)
# 4. Deploy - Tailscale â†’ DNS â†’ SSL â†’ SSH Deploy â†’ Health Checks
# 5. Summary - Pipeline results
#
# Build Strategies:
# - server-build: Build Docker images directly on the prod server (default)
# - dockerhub:    Build in CI, push to DockerHub, pull on server
#
# Required Secrets:
# - PROD_TAILSCALE_IP, PROD_SSH_KEY, PROD_SSH_USER, PROD_SSH_PORT
# - PROD_ROOT_SSH_KEY (root SSH key for SSL cert deployment)
# - TAILSCALE_OAUTH_CLIENT_ID, TAILSCALE_OAUTH_SECRET
# - DOCKER_USERNAME, DOCKER_TOKEN
# - CLOUDFLARE_API_KEY, CLOUDFLARE_ZONE_ID
# - SSL_EMAIL
# - DISCORD_WEBHOOK_ACTIONS (optional)
# =============================================================================

name: ðŸš€ CI/CD Pipeline

on:
    push:
        branches: [main, develop]
        paths-ignore:
            - "**.md"
            - "docs/**"
            - ".github/workflows/llm-audit.yml"
    pull_request:
        branches: [main, develop]
    workflow_dispatch:
        inputs:
            skip_deploy:
                description: "Skip deployment"
                required: false
                type: boolean
                default: false
            skip_ssl:
                description: "Skip SSL certificate generation"
                required: false
                type: boolean
                default: false
            skip_tests:
                description: "Skip all Rust tests including ML/Backward crates (faster deploys)"
                required: false
                type: boolean
                default: false
            build_strategy:
                description: "Docker build strategy"
                required: false
                type: choice
                options:
                    - server-build
                    - dockerhub
                default: dockerhub
            environment:
                description: "Target environment"
                required: false
                type: choice
                options:
                    - auto
                    - staging
                    - production
                default: auto

permissions:
    contents: write
    pull-requests: write
    packages: write
    checks: write
    actions: read

env:
    RUST_VERSION: "1.92.0"
    CARGO_TERM_COLOR: always
    REGISTRY: docker.io
    IMAGE_NAME: nuniesmith/fks
    DOMAIN: fkstrading.xyz
    STAGING_DOMAIN: staging.fkstrading.xyz

concurrency:
    group: ${{ github.workflow }}-${{ github.ref }}
    cancel-in-progress: true

defaults:
    run:
        shell: bash

jobs:
    # =========================================================================
    # STAGE 1: SETUP
    # =========================================================================
    setup:
        name: ðŸ“‹ Setup
        runs-on: ubuntu-latest
        timeout-minutes: 5
        outputs:
            deploy_env: ${{ steps.determine-env.outputs.environment }}
            target_domain: ${{ steps.determine-env.outputs.domain }}
            build_strategy: ${{ steps.determine-env.outputs.build_strategy }}
            # NOTE: target_host is NOT passed cross-job (GitHub Actions drops it).
            # Instead, the deploy job resolves the host IP directly from secrets
            # via the 'resolve-host' step. See STAGE 4.
        steps:
            - name: ðŸŽ¯ Determine deployment environment
              id: determine-env
              env:
                  HAS_PROD_IP: ${{ secrets.PROD_TAILSCALE_IP != '' }}
                  HAS_SSH_KEY: ${{ secrets.PROD_SSH_KEY != '' }}
                  HAS_TAILSCALE: ${{ secrets.TAILSCALE_OAUTH_CLIENT_ID != '' }}
                  PROD_TAILSCALE_IP: ${{ secrets.PROD_TAILSCALE_IP }}
                  STAGING_TAILSCALE_IP: ${{ secrets.STAGING_TAILSCALE_IP }}
                  INPUT_ENV: ${{ inputs.environment }}
                  INPUT_STRATEGY: ${{ inputs.build_strategy }}
                  GITHUB_REF: ${{ github.ref }}
                  PROD_DOMAIN: ${{ env.DOMAIN }}
                  STAGE_DOMAIN: ${{ env.STAGING_DOMAIN }}
              run: |
                  # NOTE: Do NOT use `set -euo pipefail` here â€” the `&&` pattern
                  # in the optional-secrets validation block causes `set -e` to
                  # terminate the script when the test returns false (exit 1).
                  # We handle errors explicitly with `exit 1` where needed.

                  # â”€â”€ Validate critical secrets â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                  if [ -z "$PROD_TAILSCALE_IP" ]; then
                    echo "âŒ FATAL: PROD_TAILSCALE_IP secret is not set or empty!"
                    cat >> $GITHUB_STEP_SUMMARY << 'EOFSUM'
                  ## âŒ Missing Required Secret
                  The `PROD_TAILSCALE_IP` secret must be configured in repository settings.

                  Go to: **Settings â†’ Secrets and variables â†’ Actions â†’ New repository secret**

                  Set `PROD_TAILSCALE_IP` to your production server's Tailscale IP (e.g., `100.x.x.x`)
                  EOFSUM
                    exit 1
                  fi

                  # â”€â”€ Determine environment â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                  if [ -n "$INPUT_ENV" ] && [ "$INPUT_ENV" != "auto" ]; then
                    ENV="$INPUT_ENV"
                  elif [ "$GITHUB_REF" == "refs/heads/main" ]; then
                    ENV="production"
                  else
                    ENV="staging"
                  fi

                  # â”€â”€ Set domain â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                  if [ "$ENV" = "production" ]; then
                    DOMAIN="$PROD_DOMAIN"
                  else
                    DOMAIN="$STAGE_DOMAIN"
                  fi

                  # â”€â”€ Determine build strategy â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                  STRATEGY="${INPUT_STRATEGY:-server-build}"

                  # â”€â”€ Debug output â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                  echo "ðŸŽ¯ Environment:    $ENV"
                  echo "ðŸŒ Domain:         $DOMAIN"
                  echo "ðŸ”§ Build Strategy: $STRATEGY"

                  # â”€â”€ Write outputs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                  echo "environment=$ENV" >> "$GITHUB_OUTPUT"
                  echo "domain=$DOMAIN" >> "$GITHUB_OUTPUT"
                  echo "build_strategy=$STRATEGY" >> "$GITHUB_OUTPUT"

                  # â”€â”€ Validate optional secrets â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                  MISSING=""
                  if [ "$HAS_PROD_IP" != "true" ]; then MISSING="$MISSING PROD_TAILSCALE_IP"; fi
                  if [ "$HAS_SSH_KEY" != "true" ]; then MISSING="$MISSING PROD_SSH_KEY"; fi
                  if [ "$HAS_TAILSCALE" != "true" ]; then MISSING="$MISSING TAILSCALE_OAUTH_CLIENT_ID"; fi

                  if [ -n "$MISSING" ]; then
                    echo "âš ï¸ Missing secrets:$MISSING"
                    echo "## âš ï¸ Missing Secrets" >> $GITHUB_STEP_SUMMARY
                    echo "Configure these secrets:$MISSING" >> $GITHUB_STEP_SUMMARY
                  fi

                  # â”€â”€ Summary â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                  cat >> $GITHUB_STEP_SUMMARY << EOF
                  ## ðŸŽ¯ Environment Configuration
                  | Property | Value |
                  |----------|-------|
                  | Target | \`$ENV\` |
                  | Domain | \`$DOMAIN\` |
                  | Build Strategy | \`$STRATEGY\` |
                  | Branch | \`${{ github.ref_name }}\` |
                  | Trigger | \`${{ github.event_name }}\` |
                  EOF

    # =========================================================================
    # STAGE 2: TESTS
    # =========================================================================
    test-rust:
        name: ðŸ¦€ Rust Tests
        runs-on: ubuntu-latest
        timeout-minutes: 60
        needs: [setup]
        if: ${{ !inputs.skip_tests }}
        env:
            # Reduce build parallelism to avoid OOM on CI runners
            CARGO_BUILD_JOBS: 4
        steps:
            - name: ðŸ“¥ Checkout code
              uses: actions/checkout@v4

            - name: ðŸ¦€ Run Rust CI
              uses: nuniesmith/actions/.github/actions/rust-ci@main
              with:
                  toolchain: ${{ env.RUST_VERSION }}
                  components: clippy, rustfmt
                  install-protobuf: "true"
                  run-fmt: "true"
                  run-clippy: "true"
                  run-tests: "true"
                  run-build: "false"
                  workspace: "true"
                  all-features: "false"
                  clippy-args: "--all-targets"

    test-kmp:
        name: ðŸ“± KMP Tests
        runs-on: ubuntu-latest
        timeout-minutes: 30
        needs: [setup]
        if: ${{ !inputs.skip_tests }}
        steps:
            - name: ðŸ“¥ Checkout code
              uses: actions/checkout@v4

            - name: ðŸ“± Run KMP CI
              uses: nuniesmith/actions/.github/actions/kotlin-ci@main
              with:
                  java-version: "21"
                  java-distribution: "temurin"
                  working-directory: src/clients
                  run-tests: "true"
                  run-build: "true"
                  test-task: "check"
                  upload-test-results: "true"

    # =========================================================================
    # STAGE 3: DOCKER BUILD (only for dockerhub strategy)
    # =========================================================================
    docker-build:
        name: ðŸ³ Docker (${{ matrix.service.name }})
        runs-on: ubuntu-latest
        timeout-minutes: 45
        needs: [setup, test-rust, test-kmp]
        if: |
            always() &&
            needs.setup.result == 'success' &&
            (needs.test-rust.result == 'success' || needs.test-rust.result == 'skipped') &&
            (needs.test-kmp.result == 'success' || needs.test-kmp.result == 'skipped') &&
            needs.setup.outputs.build_strategy == 'dockerhub' &&
            (github.event_name == 'push' || github.event_name == 'workflow_dispatch') &&
            (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop') &&
            !inputs.skip_deploy
        strategy:
            fail-fast: false
            matrix:
                service:
                    - name: janus
                      dockerfile: infrastructure/docker/base/rust/Dockerfile
                      target: workspace
                      build_args: SERVICE_NAME=janus
                    - name: web
                      dockerfile: infrastructure/docker/services/web/Dockerfile
                      target: production
                      build_args: ""
                    - name: authelia
                      dockerfile: infrastructure/docker/services/authelia/Dockerfile
                      target: runtime
                      build_args: ""
                    - name: nginx
                      dockerfile: infrastructure/docker/services/nginx/Dockerfile
                      target: production
                      build_args: ""
        steps:
            - name: ðŸ“¥ Checkout code
              uses: actions/checkout@v4

            - name: ðŸ³ Build and Push
              uses: nuniesmith/actions/.github/actions/docker-build-push@main
              with:
                  image-name: ${{ env.IMAGE_NAME }}
                  username: ${{ secrets.DOCKER_USERNAME }}
                  password: ${{ secrets.DOCKER_TOKEN }}
                  dockerfile: ${{ matrix.service.dockerfile }}
                  context: .
                  platforms: linux/amd64
                  push: "true"
                  tags: |
                      type=raw,value=${{ matrix.service.name }}-latest
                      type=raw,value=${{ matrix.service.name }}-${{ github.sha }}
                      type=raw,value=${{ matrix.service.name }}-${{ needs.setup.outputs.deploy_env }}
                  build-args: ${{ matrix.service.build_args }}
                  target: ${{ matrix.service.target }}

    # =========================================================================
    # STAGE 4: DEPLOY
    # =========================================================================
    deploy:
        name: ðŸš€ Deploy to ${{ needs.setup.outputs.deploy_env }}
        runs-on: ubuntu-latest
        timeout-minutes: 45
        needs: [setup, test-rust, test-kmp, docker-build]
        if: |
            always() &&
            needs.setup.result == 'success' &&
            (needs.test-rust.result == 'success' || needs.test-rust.result == 'skipped') &&
            (needs.test-kmp.result == 'success' || needs.test-kmp.result == 'skipped') &&
            (needs.docker-build.result == 'success' || (needs.docker-build.result == 'skipped' && needs.setup.outputs.build_strategy != 'dockerhub')) &&
            (github.event_name == 'push' || github.event_name == 'workflow_dispatch') &&
            (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop') &&
            !inputs.skip_deploy
        environment:
            name: ${{ needs.setup.outputs.deploy_env }}
            url: https://${{ needs.setup.outputs.target_domain }}
        outputs:
            deployed: ${{ steps.deploy.outputs.deployed }}
            build_strategy_used: ${{ steps.deploy.outputs.build_strategy }}
            ssl_cert_type: ${{ steps.ssl.outputs.cert-type }}
            ssl_deployed: ${{ steps.ssl.outputs.deployed }}
            http_health: ${{ steps.health-checks.outputs.healthy }}
        steps:
            - name: ðŸ“¥ Checkout code
              uses: actions/checkout@v4

            # -----------------------------------------------------------------
            # RESOLVE TARGET HOST (in-job â€” secrets can't reliably pass cross-job)
            # -----------------------------------------------------------------
            - name: ðŸŽ¯ Resolve target host
              id: resolve-host
              env:
                  DEPLOY_ENV: ${{ needs.setup.outputs.deploy_env }}
                  PROD_IP: ${{ secrets.PROD_TAILSCALE_IP }}
                  STAGING_IP: ${{ secrets.STAGING_TAILSCALE_IP }}
              run: |
                  if [ "$DEPLOY_ENV" = "production" ]; then
                    HOST="$PROD_IP"
                  else
                    HOST="${STAGING_IP:-$PROD_IP}"
                  fi

                  if [ -z "$HOST" ]; then
                    echo "âŒ FATAL: Could not resolve target host IP!"
                    echo "   DEPLOY_ENV=$DEPLOY_ENV"
                    exit 1
                  fi

                  echo "target_host=$HOST" >> "$GITHUB_OUTPUT"
                  echo "âœ… Target host: $HOST (env: $DEPLOY_ENV)"

            # -----------------------------------------------------------------
            # TAILSCALE CONNECTION
            # -----------------------------------------------------------------
            - name: ðŸ”Œ Connect to Tailscale
              id: tailscale
              uses: nuniesmith/actions/.github/actions/tailscale-connect@main
              with:
                  oauth-client-id: ${{ secrets.TAILSCALE_OAUTH_CLIENT_ID }}
                  oauth-secret: ${{ secrets.TAILSCALE_OAUTH_SECRET }}
                  target-ip: ${{ steps.resolve-host.outputs.target_host }}
                  target-ssh-port: ${{ secrets.PROD_SSH_PORT || '22' }}

            # -----------------------------------------------------------------
            # DNS UPDATE
            # -----------------------------------------------------------------
            - name: ðŸŒ Update Cloudflare DNS
              if: steps.tailscale.outputs.connected == 'true' && steps.resolve-host.outputs.target_host != ''
              uses: nuniesmith/actions/.github/actions/cloudflare-dns-update@main
              continue-on-error: true
              with:
                  api-token: ${{ secrets.CLOUDFLARE_API_KEY }}
                  zone-id: ${{ secrets.CLOUDFLARE_ZONE_ID }}
                  record-name: ${{ needs.setup.outputs.target_domain }}
                  record-content: ${{ steps.resolve-host.outputs.target_host }}
                  additional-records: |
                      [
                        {"name": "www.${{ needs.setup.outputs.target_domain }}"},
                        {"name": "dev.${{ needs.setup.outputs.target_domain }}"},
                        {"name": "staging.${{ needs.setup.outputs.target_domain }}"}
                      ]

            # -----------------------------------------------------------------
            # SSL CERTIFICATE CHECK
            # -----------------------------------------------------------------
            - name: ðŸ” Check Existing SSL Certificates
              id: ssl-check
              if: github.ref == 'refs/heads/main' && !inputs.skip_ssl
              uses: nuniesmith/actions/.github/actions/ssl-check@main
              continue-on-error: true
              with:
                  ssh-host: ${{ steps.resolve-host.outputs.target_host }}
                  ssh-port: ${{ secrets.PROD_SSH_PORT || '22' }}
                  ssh-user: ${{ secrets.PROD_SSH_USER || 'actions' }}
                  ssh-key: ${{ secrets.PROD_SSH_KEY }}
                  domain: ${{ needs.setup.outputs.target_domain }}
                  cert-path: "/var/lib/docker/volumes/fks_ssl_certs/_data/live/{domain}/fullchain.pem"
                  renewal-threshold-days: "30"

            # -----------------------------------------------------------------
            # SSL CERTIFICATE GENERATION
            # -----------------------------------------------------------------
            - name: ðŸ” Generate & Deploy SSL Certificates
              id: ssl
              if: |
                  github.ref == 'refs/heads/main' &&
                  !inputs.skip_ssl &&
                  steps.ssl-check.outputs.skip-generation != 'true'
              continue-on-error: true
              uses: nuniesmith/actions/.github/actions/ssl-certbot-cloudflare@main
              with:
                  domain: ${{ needs.setup.outputs.target_domain }}
                  additional-domains: "www.${{ needs.setup.outputs.target_domain }}"
                  cloudflare-api-token: ${{ secrets.CLOUDFLARE_API_KEY }}
                  email: ${{ secrets.SSL_EMAIL }}
                  fallback-to-self-signed: "true"
                  self-signed-days: "365"
                  deploy-to-server: true
                  ssh-host: ${{ steps.resolve-host.outputs.target_host }}
                  ssh-port: ${{ secrets.PROD_SSH_PORT || '22' }}
                  ssh-user: ${{ secrets.PROD_SSH_USER || 'actions' }}
                  ssh-key: ${{ secrets.PROD_SSH_KEY }}
                  root-ssh-key: ${{ secrets.PROD_ROOT_SSH_KEY }}
                  docker-volume-name: "fks_ssl_certs"
                  docker-username: ${{ secrets.DOCKER_USERNAME }}
                  docker-token: ${{ secrets.DOCKER_TOKEN }}

            # -----------------------------------------------------------------
            # DEPLOYMENT
            # -----------------------------------------------------------------
            - name: ðŸš€ Deploy via SSH
              id: deploy
              uses: nuniesmith/actions/.github/actions/ssh-deploy@main
              with:
                  # â”€â”€ SSH Connection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                  host: ${{ steps.resolve-host.outputs.target_host }}
                  port: ${{ secrets.PROD_SSH_PORT || '22' }}
                  username: ${{ secrets.PROD_SSH_USER || 'actions' }}
                  ssh-key: ${{ secrets.PROD_SSH_KEY }}
                  ssh-retries: "3"
                  ssh-retry-delay: "10"

                  # â”€â”€ Project â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                  project-path: ~/fks
                  git-pull: "true"
                  git-branch: ${{ github.ref_name }}
                  git-repo-url: "https://github.com/nuniesmith/fks.git"

                  # â”€â”€ Build Strategy â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                  build-strategy: ${{ needs.setup.outputs.build_strategy }}

                  # â”€â”€ Docker Registry â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                  docker-registry: docker.io
                  docker-username: ${{ secrets.DOCKER_USERNAME }}
                  docker-password: ${{ secrets.DOCKER_TOKEN }}
                  docker-image-prefix: ${{ env.IMAGE_NAME }}
                  docker-image-tag: ${{ github.sha }}

                  # â”€â”€ Docker Compose â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                  compose-files: "infrastructure/compose/docker-compose.yml infrastructure/compose/docker-compose.prod.yml"
                  compose-project: fks
                  compose-env-file: .env

                  # â”€â”€ Services â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                  app-services: "janus web authelia nginx"
                  infra-services: "redis postgres questdb prometheus grafana alertmanager-discord-bridge alertmanager"

                  # â”€â”€ Cleanup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                  docker-prune: "true"

                  # â”€â”€ Pre-Deploy â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                  pre-deploy-command: |
                      echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                      echo "ðŸ“‹ PRE-DEPLOY: ${{ needs.setup.outputs.deploy_env }}"
                      echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                      echo "ðŸ–¥ï¸  Host: $(hostname) | $(date)"
                      echo "ðŸ’¾ Disk: $(df -h / | tail -1 | awk '{print $4}') free"

                      # Ensure all Docker volumes exist
                      echo "ðŸ“¦ Creating Docker volumes..."
                      for vol in fks_ssl_certs fks_certbot_www fks_postgres_data fks_questdb_data fks_redis_data fks_grafana_data fks_prometheus_data fks_loki_data fks_alertmanager_data fks_optimizer_data fks_promtail_positions fks_nginx_logs; do
                        docker volume create $vol 2>/dev/null || true
                      done
                      echo "âœ… Docker volumes ready"

                  # â”€â”€ Deploy (custom commands that run AFTER strategy build) â”€
                  deploy-command: |
                      echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                      echo "ðŸš€ DEPLOYING: ${{ needs.setup.outputs.deploy_env }}"
                      echo "   Strategy:  ${{ needs.setup.outputs.build_strategy }}"
                      echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

                      # â”€â”€ 1. Docker login â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                      echo "${{ secrets.DOCKER_TOKEN }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin docker.io || true

                      # â”€â”€ 2. Generate secrets & .env file â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                      echo "ðŸ” Setting up .env file..."
                      bash ./run.sh setup-env

                      # Inject CI-managed secrets into .env
                      DISCORD_GENERAL='${{ secrets.DISCORD_WEBHOOK_GENERAL }}'
                      if [ -n "$DISCORD_GENERAL" ]; then
                        if grep -q "^DISCORD_WEBHOOK_GENERAL=" .env 2>/dev/null; then
                          sed -i "s|^DISCORD_WEBHOOK_GENERAL=.*|DISCORD_WEBHOOK_GENERAL=${DISCORD_GENERAL}|" .env
                        else
                          echo "DISCORD_WEBHOOK_GENERAL=${DISCORD_GENERAL}" >> .env
                        fi
                        echo "âœ… DISCORD_WEBHOOK_GENERAL set from GitHub secret"
                      else
                        echo "âš ï¸  DISCORD_WEBHOOK_GENERAL secret not configured â€” alertmanager notifications will be disabled"
                      fi

                      # Source environment for subsequent commands
                      set -a && source .env && set +a

                      # â”€â”€ 3. Generate config files from templates â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                      TMPL="infrastructure/monitoring/alertmanager/alertmanager.yml.tmpl"
                      DEST="infrastructure/monitoring/alertmanager/alertmanager.yml"
                      if [ -f "$TMPL" ]; then
                        echo "ðŸ”§ Generating alertmanager.yml from template..."
                        cp "$TMPL" "$DEST"
                        echo "âœ… alertmanager.yml generated (webhook routed via discord bridge container)"
                      else
                        echo "âš ï¸  alertmanager template not found at $TMPL"
                      fi

                      # â”€â”€ 4. Build compose command â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                      COMPOSE_CMD="docker compose -p fks --env-file .env -f infrastructure/compose/docker-compose.yml -f infrastructure/compose/docker-compose.prod.yml"

                      # â”€â”€ 5. Stop app services (keep infra running) â”€â”€â”€â”€â”€â”€â”€â”€â”€
                      APP_SERVICES="janus web authelia nginx"
                      echo "ðŸ›‘ Stopping app services: $APP_SERVICES"
                      $COMPOSE_CMD stop $APP_SERVICES 2>/dev/null || true
                      $COMPOSE_CMD rm -f $APP_SERVICES 2>/dev/null || true
                      docker container prune -f --filter "label=com.docker.compose.project=fks" 2>/dev/null || true

                      # â”€â”€ 6. Build or pull based on strategy â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                      STRATEGY="${{ needs.setup.outputs.build_strategy }}"

                      if [ "$STRATEGY" = "dockerhub" ]; then
                        echo "ðŸ“¥ Pulling pre-built images from DockerHub..."
                        $COMPOSE_CMD pull $APP_SERVICES 2>&1 || {
                          echo "âš ï¸  Pull failed â€” falling back to server build"
                          STRATEGY="server-build"
                        }
                      fi

                      if [ "$STRATEGY" = "server-build" ]; then
                        echo "ðŸ”¨ Building app images on server..."
                        $COMPOSE_CMD build --parallel $APP_SERVICES 2>&1
                        echo "âœ… App images built"
                      fi

                      # â”€â”€ 7. Ensure infra services are running â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                      echo "ðŸ”§ Ensuring infrastructure services are running..."
                      $COMPOSE_CMD up -d --no-recreate redis postgres questdb prometheus grafana alertmanager-discord-bridge alertmanager 2>&1

                      # Reload alertmanager config
                      echo "ðŸ”„ Reloading alertmanager config..."
                      if docker kill --signal=HUP fks_alertmanager 2>/dev/null; then
                        echo "âœ… Alertmanager config reloaded (via SIGHUP)"
                      else
                        echo "âš ï¸  Could not reload alertmanager â€” will use config from startup"
                      fi

                      # â”€â”€ 8. Wait for Redis health â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                      echo "â³ Waiting for Redis to be healthy..."
                      for i in $(seq 1 30); do
                        if $COMPOSE_CMD exec -T redis redis-cli --no-auth-warning -a "${REDIS_PASSWORD:-}" ping 2>/dev/null | grep -q PONG; then
                          echo "âœ… Redis is healthy"
                          break
                        fi
                        echo "  Waiting for Redis... ($i/30)"
                        sleep 2
                      done

                      # â”€â”€ 9. Start all services â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                      echo "ðŸš€ Starting all services..."
                      $COMPOSE_CMD up -d 2>&1

                      sleep 30

                      echo ""
                      echo "ðŸ“Š Container Status:"
                      docker ps -a --filter "name=fks" --format "table {{.Names}}\t{{.Status}}" | head -20

                  # â”€â”€ Post-Deploy â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                  post-deploy-command: |
                      echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                      echo "ðŸ§¹ POST-DEPLOY"
                      echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

                      # Check if SSL certs exist in volume and nginx is using them
                      DOMAIN="${{ needs.setup.outputs.target_domain }}"
                      if docker run --rm -v fks_ssl_certs:/certs:ro busybox test -f "/certs/live/$DOMAIN/fullchain.pem" 2>/dev/null; then
                        echo "âœ… SSL certificates found in Docker volume"

                        # Restart nginx to pick up certs
                        if docker ps -q -f name=fks_nginx | grep -q .; then
                          echo "ðŸ”„ Restarting nginx to apply SSL certificates..."
                          docker restart fks_nginx
                          sleep 5
                        fi
                      else
                        echo "âš ï¸ No SSL certificates in volume â€” nginx using self-signed fallback"
                        echo "   Run './run.sh ssl-init' to get Let's Encrypt certificates"
                      fi

                      # Cleanup old images
                      docker image prune -f --filter "until=24h" 2>/dev/null || true

                      echo ""
                      echo "ðŸŒ Access URLs:"
                      echo "   Main:       https://${{ needs.setup.outputs.target_domain }}"
                      echo "   Grafana:    https://${{ needs.setup.outputs.target_domain }}/grafana"
                      echo "   Prometheus: https://${{ needs.setup.outputs.target_domain }}/prometheus"
                      echo ""
                      echo "âœ… Deployment complete!"

            # -----------------------------------------------------------------
            # HEALTH CHECKS
            # -----------------------------------------------------------------
            - name: ðŸ¥ Run Health Checks
              id: health-checks
              if: always() && steps.deploy.outcome == 'success'
              uses: nuniesmith/actions/.github/actions/health-check@main
              with:
                  endpoints: |
                      [
                        {"url": "http://${{ needs.setup.outputs.target_domain }}/health", "expected_status": 200},
                        {"url": "http://${{ needs.setup.outputs.target_domain }}/health/web", "expected_status": 200},
                        {"url": "http://${{ needs.setup.outputs.target_domain }}/health/janus", "expected_status": 200},
                        {"url": "http://${{ needs.setup.outputs.target_domain }}/health/grafana", "expected_status": 200}
                      ]
                  containers: fks_janus fks_nginx fks_web
                  ssh-host: ${{ steps.resolve-host.outputs.target_host }}
                  ssh-port: ${{ secrets.PROD_SSH_PORT || '22' }}
                  ssh-user: ${{ secrets.PROD_SSH_USER || 'actions' }}
                  ssh-key: ${{ secrets.PROD_SSH_KEY }}
                  custom-command: |
                      echo "ðŸ” Database connectivity check..."
                      docker exec fks_redis sh -c 'redis-cli --no-auth-warning -a "$REDIS_PASSWORD" ping' 2>/dev/null | grep -q "PONG" && echo "âœ… Redis OK" || echo "âŒ Redis failed"
                      docker exec fks_postgres pg_isready -U fks_user 2>/dev/null | grep -q "accepting" && echo "âœ… PostgreSQL OK" || echo "âŒ PostgreSQL failed"
                      curl -s "http://localhost:9000/exec?query=SELECT%201" 2>/dev/null | grep -q "dataset" && echo "âœ… QuestDB OK" || echo "âŒ QuestDB failed"
                  initial-delay: "30"
                  retry-count: "3"
                  retry-delay: "10"
                  fail-on-unhealthy: "false"

            # -----------------------------------------------------------------
            # NOTIFICATION
            # -----------------------------------------------------------------
            - name: ðŸ“£ Notify deployment
              if: always()
              uses: nuniesmith/actions/.github/actions/discord-notify@main
              continue-on-error: true
              with:
                  webhook-url: ${{ secrets.DISCORD_WEBHOOK_ACTIONS }}
                  title: "${{ steps.deploy.outcome == 'success' && 'ðŸš€ FKS Deployed' || 'âŒ FKS Deploy Failed' }}"
                  description: "Deployed to ${{ needs.setup.outputs.deploy_env }} via ${{ needs.setup.outputs.build_strategy }}"
                  status: ${{ steps.deploy.outcome == 'success' && 'success' || 'failure' }}
                  include-repo-info: "true"
                  fields: |
                      [
                        {"name": "Environment", "value": "${{ needs.setup.outputs.deploy_env }}", "inline": true},
                        {"name": "Domain", "value": "${{ needs.setup.outputs.target_domain }}", "inline": true},
                        {"name": "Strategy", "value": "${{ needs.setup.outputs.build_strategy }}", "inline": true},
                        {"name": "SSL", "value": "${{ steps.ssl.outputs.cert-type || steps.ssl-check.outputs.cert-type || 'skipped' }}", "inline": true},
                        {"name": "Health", "value": "${{ steps.health-checks.outputs.healthy == 'true' && 'âœ… healthy' || 'âš ï¸ degraded' }}", "inline": true}
                      ]

    # =========================================================================
    # PIPELINE SUMMARY
    # =========================================================================
    pipeline-summary:
        name: ðŸ“Š Pipeline Summary
        runs-on: ubuntu-latest
        timeout-minutes: 5
        needs: [setup, test-rust, test-kmp, docker-build, deploy]
        if: always()
        steps:
            - name: ðŸ“Š Generate summary
              run: |
                  cat >> $GITHUB_STEP_SUMMARY << EOF
                  # ðŸš€ FKS CI/CD Pipeline Summary

                  ## Environment
                  | Property | Value |
                  |----------|-------|
                  | Target | \`${{ needs.setup.outputs.deploy_env }}\` |
                  | Domain | \`${{ needs.setup.outputs.target_domain }}\` |
                  | Build Strategy | \`${{ needs.setup.outputs.build_strategy }}\` |
                  | Branch | \`${{ github.ref_name }}\` |

                  ## Jobs
                  | Job | Status |
                  |-----|--------|
                  | ðŸ¦€ Rust Tests | ${{ needs.test-rust.result || 'skipped' }} |
                  | ðŸ“± KMP Tests | ${{ needs.test-kmp.result || 'skipped' }} |
                  | ðŸ³ Docker Build | ${{ needs.docker-build.result || 'skipped' }} |
                  | ðŸš€ Deploy | ${{ needs.deploy.result || 'skipped' }} |

                  ## Docker Images
                  | Image | Tag |
                  |-------|-----|
                  | janus | \`janus-${{ github.sha }}\` |
                  | web | \`web-${{ github.sha }}\` |
                  | authelia | \`authelia-${{ github.sha }}\` |
                  | nginx | \`nginx-${{ github.sha }}\` |

                  ## Details
                  | Property | Value |
                  |----------|-------|
                  | Build Strategy | ${{ needs.setup.outputs.build_strategy }} |
                  | SSL Certificate | ${{ needs.deploy.outputs.ssl_cert_type || 'N/A' }} |
                  | Health Check | ${{ needs.deploy.outputs.http_health == 'true' && 'âœ… Healthy' || 'âš ï¸ Check logs' }} |

                  ---
                  **Actor:** \`${{ github.actor }}\` | **Run:** \`#${{ github.run_number }}\`
                  EOF

            - name: âŒ Fail on critical errors
              if: needs.test-rust.result == 'failure' || needs.test-kmp.result == 'failure' || needs.docker-build.result == 'failure' || needs.deploy.result == 'failure'
              run: |
                  echo "âŒ Pipeline failed"
                  exit 1
