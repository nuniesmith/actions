# ============================================================================
# FKS CI/CD Pipeline
# ============================================================================
# Complete pipeline using reusable composite actions for maintainability.
#
# Pipeline Flow:
# 1. Code Quality & Testing (GATE) - Must pass for pipeline to continue
# 2. Docker Build & Push - Only if tests pass
# 3. Tailscale & DNS Setup - Only if build succeeds
# 4. Production Deployment - Only if infrastructure ready
# 5. LLM Audit (Post-CI) - Runs after CI with full context
# ============================================================================
name: ðŸš€ CI/CD Pipeline

on:
    push:
        branches:
            - main
            - develop
        paths-ignore:
            - "**.md"
            - "docs/**"
            - ".github/workflows/llm-audit.yml"
    pull_request:
        branches:
            - main
            - develop
    workflow_dispatch:
        inputs:
            skip_tests:
                description: "Skip tests (deploy only)"
                required: false
                type: boolean
                default: false
            skip_deploy:
                description: "Skip deployment"
                required: false
                type: boolean
                default: false

permissions:
    contents: write
    pull-requests: write
    packages: write
    checks: write

env:
    RUST_VERSION: "1.92.0"
    CARGO_TERM_COLOR: always
    REDIS_URL: redis://localhost:6379/0
    REGISTRY: docker.io
    IMAGE_PREFIX: nuniesmith/fks
    DOMAIN: fkstrading.xyz

concurrency:
    group: ${{ github.workflow }}-${{ github.ref }}
    cancel-in-progress: true

defaults:
    run:
        shell: bash

jobs:
    # ========================================================================
    # STAGE 1: CODE QUALITY & TESTING (GATE)
    # ========================================================================

    rust-quality-and-tests:
        name: ðŸ¦€ Rust Quality & Tests
        runs-on: ubuntu-latest
        timeout-minutes: 45
        if: ${{ !inputs.skip_tests }}
        services:
            redis:
                image: redis:latest
                ports:
                    - 6379:6379
                options: >-
                    --health-cmd "redis-cli ping"
                    --health-interval 10s
                    --health-timeout 5s
                    --health-retries 5
        steps:
            - name: ðŸ§¹ Free disk space
              run: |
                  sudo rm -rf /usr/share/dotnet /usr/local/lib/android /opt/ghc /opt/hostedtoolcache/CodeQL
                  sudo apt-get clean
                  df -h

            - name: ðŸ“¥ Checkout code
              uses: actions/checkout@v4

            - name: ðŸ“¦ Install system dependencies
              run: |
                  sudo apt-get update
                  sudo apt-get install -y libfontconfig1-dev

            - name: ðŸ¦€ Setup Rust
              uses: nuniesmith/actions/.github/actions/setup-rust@main
              with:
                  rust-version: ${{ env.RUST_VERSION }}
                  components: rustfmt,clippy
                  install-protobuf: "true"
                  install-buf: "true"
                  cache-key-suffix: ci-rust

            - name: ðŸ” Lint Protocol Buffers
              working-directory: proto
              run: |
                  buf lint
                  echo "âœ… Proto files pass linting"

            - name: ðŸ”’ Check for breaking proto changes
              working-directory: proto
              if: github.event_name == 'pull_request'
              run: buf breaking --against '.git#branch=main' || true
              continue-on-error: true

            - name: âœ¨ Check formatting
              timeout-minutes: 5
              run: cargo fmt --all -- --check

            - name: ðŸ“Ž Run Clippy
              timeout-minutes: 15
              run: |
                  cargo clippy --workspace --lib -- \
                    -D warnings \
                    -A clippy::too-many-arguments \
                    -A clippy::manual-range-contains \
                    -A clippy::should-implement-trait

            - name: ðŸ”¨ Build fks-proto crate first
              timeout-minutes: 10
              run: cargo build -p fks-proto

            - name: ðŸ”¨ Build all services
              timeout-minutes: 25
              run: cargo build --release --workspace

            - name: ðŸ§¹ Clean debug artifacts before tests
              run: |
                  rm -rf target/debug/deps target/debug/build target/debug/.fingerprint
                  df -h

            - name: ðŸ§ª Run unit tests
              timeout-minutes: 15
              run: cargo test --lib --workspace --release
              env:
                  REDIS_URL: ${{ env.REDIS_URL }}
                  CARGO_INCREMENTAL: 0

            - name: ðŸ”— Run integration tests
              timeout-minutes: 15
              run: cargo test --tests --workspace --release
              env:
                  REDIS_URL: ${{ env.REDIS_URL }}
                  CARGO_INCREMENTAL: 0

    kotlin-kmp-quality-and-tests:
        name: ðŸŽ¯ Kotlin/KMP Quality & Tests
        runs-on: ubuntu-latest
        timeout-minutes: 30
        if: ${{ !inputs.skip_tests }}
        continue-on-error: true

        steps:
            - name: ðŸ“¥ Checkout code
              uses: actions/checkout@v4

            - name: ðŸŽ¯ Run Kotlin CI
              id: kotlin-ci
              uses: nuniesmith/actions/.github/actions/kotlin-ci@main
              with:
                  java-version: "21"
                  java-distribution: "temurin"
                  working-directory: "src/clients"
                  run-detekt: "true"
                  run-tests: "true"
                  run-build: "true"
                  test-module: ":shared"
                  test-task: "testDebugUnitTest"
                  build-task: "assemble"
                  known-test-failures: "20"
                  upload-test-results: "true"
                  continue-on-test-failure: "true"

    chaos-tests:
        name: ðŸ”¥ Chaos & Resilience Tests
        runs-on: ubuntu-latest
        timeout-minutes: 45
        if: github.event_name == 'push' && !inputs.skip_tests
        services:
            redis:
                image: redis:latest
                ports:
                    - 6379:6379
                options: >-
                    --health-cmd "redis-cli ping"
                    --health-interval 10s
                    --health-timeout 5s
                    --health-retries 5
        steps:
            - name: ðŸ“¥ Checkout code
              uses: actions/checkout@v4

            - name: ðŸ¦€ Setup Rust
              uses: nuniesmith/actions/.github/actions/setup-rust@main
              with:
                  rust-version: ${{ env.RUST_VERSION }}
                  cache-key-suffix: chaos

            - name: ðŸ³ Start Prometheus with alert rules
              run: |
                  docker run -d \
                      --name prometheus \
                      -p 9090:9090 \
                      -v ${{ github.workspace }}/scripts/chaos-test/ci-config/prometheus.yml:/etc/prometheus/prometheus.yml \
                      -v ${{ github.workspace }}/scripts/chaos-test/ci-config/alert-rules.yml:/etc/prometheus/alert-rules.yml \
                      prom/prometheus:latest \
                      --config.file=/etc/prometheus/prometheus.yml \
                      --web.enable-lifecycle

                  for i in {1..30}; do
                      curl -sf http://localhost:9090/-/healthy > /dev/null && break
                      sleep 2
                  done

            - name: ðŸ”¨ Build chaos-test tool
              working-directory: scripts/chaos-test
              run: cargo build --release

            - name: ðŸ§ª Run CI-safe chaos tests
              working-directory: scripts/chaos-test
              run: |
                  mkdir -p results
                  ./target/release/chaos-test \
                      --prometheus-url http://localhost:9090 \
                      --redis-url redis://localhost:6379/0 \
                      ci-mode --report
              env:
                  RUST_LOG: info

            - name: ðŸ§¹ Cleanup Prometheus
              if: always()
              run: docker stop prometheus && docker rm prometheus || true

            - name: ðŸ“Š Upload test results
              if: always()
              uses: actions/upload-artifact@v4
              with:
                  name: chaos-test-results
                  path: scripts/chaos-test/results/
                  retention-days: 7
              continue-on-error: true

    # ========================================================================
    # STATIC AUDIT (Runs in parallel with tests)
    # ========================================================================

    auto-format:
        name: âœ¨ Auto-Format Code
        runs-on: ubuntu-latest
        timeout-minutes: 15
        if: github.event_name == 'push'
        permissions:
            contents: write
        steps:
            - name: ðŸ“¥ Checkout code
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0
                  token: ${{ secrets.GITHUB_TOKEN }}

            - name: ðŸ¦€ Setup Rust
              uses: nuniesmith/actions/.github/actions/setup-rust@main
              with:
                  rust-version: ${{ env.RUST_VERSION }}
                  cache-key-suffix: auto-format

            - name: â˜• Setup JDK 21 (for ktlint)
              uses: actions/setup-java@v4
              with:
                  distribution: "temurin"
                  java-version: "21"

            - name: ðŸ“¦ Install ktlint
              run: |
                  curl -sSLO https://github.com/pinterest/ktlint/releases/download/1.0.1/ktlint
                  chmod +x ktlint
                  sudo mv ktlint /usr/local/bin/

            - name: ðŸ”¨ Build audit CLI
              run: cargo build --release -p fks-audit --bin audit-cli

            - name: âœ¨ Run auto-format
              id: format
              run: |
                  ./target/release/audit-cli format . --output format-report.json || true
                  if git diff --quiet; then
                      echo "changed=false" >> $GITHUB_OUTPUT
                  else
                      echo "changed=true" >> $GITHUB_OUTPUT
                  fi

            - name: ðŸ’¾ Commit formatting changes
              if: steps.format.outputs.changed == 'true'
              run: |
                  git config --local user.email "github-actions[bot]@users.noreply.github.com"
                  git config --local user.name "github-actions[bot]"
                  git add -A
                  git commit -m "style: auto-format code [skip ci]" || true
                  git push || true

    static-audit:
        name: ðŸ“‹ Static Audit
        runs-on: ubuntu-latest
        timeout-minutes: 15
        steps:
            - name: ðŸ“¥ Checkout code
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0
                  token: ${{ secrets.GITHUB_TOKEN }}

            - name: ðŸ¦€ Setup Rust
              uses: nuniesmith/actions/.github/actions/setup-rust@main
              with:
                  rust-version: ${{ env.RUST_VERSION }}
                  cache-key-suffix: static-audit

            - name: ðŸ”¨ Build audit CLI
              run: cargo build --release -p fks-audit

            - name: ðŸ“ Scan TODO comments
              id: scan-todos
              run: |
                  ./target/release/audit-cli todo src/janus --output todos.json || echo '[]' > todos.json
                  TODO_COUNT=$(cat todos.json | jq 'length' 2>/dev/null || echo "0")
                  HIGH_PRIORITY=$(cat todos.json | jq '[.[] | select(.priority == "High")] | length' 2>/dev/null || echo "0")
                  CRITICAL=$(cat todos.json | jq '[.[] | select(.priority == "Critical")] | length' 2>/dev/null || echo "0")
                  echo "todo_count=$TODO_COUNT" >> $GITHUB_OUTPUT
                  echo "high_priority=$HIGH_PRIORITY" >> $GITHUB_OUTPUT
                  echo "critical=$CRITICAL" >> $GITHUB_OUTPUT

            - name: ðŸ·ï¸ Scan audit tags
              id: scan-tags
              run: |
                  ./target/release/audit-cli tags src/janus --output audit-tags.json || echo '[]' > audit-tags.json
                  TAG_COUNT=$(cat audit-tags.json | jq 'length' 2>/dev/null || echo "0")
                  echo "tag_count=$TAG_COUNT" >> $GITHUB_OUTPUT

            - name: ðŸ“Š Run static analysis
              id: static-analysis
              run: |
                  ./target/release/audit-cli static src/janus --output static-analysis.json || echo '{"issues_by_severity":{"critical":0,"high":0}}' > static-analysis.json
                  CRITICAL=$(cat static-analysis.json | jq '.issues_by_severity.critical // 0' 2>/dev/null || echo "0")
                  HIGH=$(cat static-analysis.json | jq '.issues_by_severity.high // 0' 2>/dev/null || echo "0")
                  echo "critical_issues=$CRITICAL" >> $GITHUB_OUTPUT
                  echo "high_issues=$HIGH" >> $GITHUB_OUTPUT

            - name: ðŸ“„ Generate & Commit AUDIT_REPORT.md
              run: |
                  mkdir -p docs/audit
                  cat > docs/audit/AUDIT_REPORT.md << EOF
                  # ðŸ“‹ Audit Report

                  > Auto-generated by CI/CD static audit. Updated on every push.

                  **Last Updated:** $(date -u +"%Y-%m-%d %H:%M UTC")
                  **Branch:** \`${{ github.ref_name }}\`
                  **Commit:** \`${{ github.sha }}\`

                  ---

                  ## ðŸ“Š Summary

                  | Metric | Count |
                  |--------|-------|
                  | Total TODOs | ${{ steps.scan-todos.outputs.todo_count }} |
                  | High Priority TODOs | ${{ steps.scan-todos.outputs.high_priority }} |
                  | Critical TODOs | ${{ steps.scan-todos.outputs.critical }} |
                  | Audit Tags | ${{ steps.scan-tags.outputs.tag_count }} |
                  | Critical Issues | ${{ steps.static-analysis.outputs.critical_issues }} |
                  | High Issues | ${{ steps.static-analysis.outputs.high_issues }} |

                  ---

                  *Run \`gh workflow run llm-audit.yml\` for deeper AI-powered analysis.*
                  EOF

                  git config user.name "github-actions[bot]"
                  git config user.email "github-actions[bot]@users.noreply.github.com"
                  git add docs/audit/AUDIT_REPORT.md
                  git diff --staged --quiet || git commit -m "ðŸ“‹ Update audit report [skip ci]" && git push || true

            - name: ðŸ“Š Generate step summary
              run: |
                  echo "## ðŸ“‹ Static Audit Results" >> $GITHUB_STEP_SUMMARY
                  echo "| Metric | Count |" >> $GITHUB_STEP_SUMMARY
                  echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
                  echo "| TODOs | ${{ steps.scan-todos.outputs.todo_count }} |" >> $GITHUB_STEP_SUMMARY
                  echo "| High Priority | ${{ steps.scan-todos.outputs.high_priority }} |" >> $GITHUB_STEP_SUMMARY
                  echo "| Audit Tags | ${{ steps.scan-tags.outputs.tag_count }} |" >> $GITHUB_STEP_SUMMARY

    # ========================================================================
    # TEST GATE SUMMARY
    # ========================================================================

    test-summary:
        name: ðŸ“Š Test Gate Summary
        runs-on: ubuntu-latest
        timeout-minutes: 5
        needs:
            - kotlin-kmp-quality-and-tests
            - rust-quality-and-tests
            - chaos-tests
        if: always()
        steps:
            - name: ðŸ“Š Generate summary
              run: |
                  echo "# ðŸ§ª Test Results Summary" >> $GITHUB_STEP_SUMMARY
                  echo "" >> $GITHUB_STEP_SUMMARY
                  echo "| Job | Status |" >> $GITHUB_STEP_SUMMARY
                  echo "|-----|--------|" >> $GITHUB_STEP_SUMMARY
                  echo "| ðŸ¦€ Rust Quality & Tests | ${{ needs.rust-quality-and-tests.result }} |" >> $GITHUB_STEP_SUMMARY
                  echo "| ðŸŽ¯ Kotlin/KMP Quality & Tests | ${{ needs.kotlin-kmp-quality-and-tests.result }} |" >> $GITHUB_STEP_SUMMARY
                  echo "| ðŸ”¥ Chaos Tests | ${{ needs.chaos-tests.result }} |" >> $GITHUB_STEP_SUMMARY

            - name: âŒ Fail if critical tests failed
              if: |
                  needs.rust-quality-and-tests.result == 'failure' ||
                  needs.kotlin-kmp-quality-and-tests.result == 'failure'
              run: |
                  echo "âŒ Critical tests failed - blocking pipeline"
                  exit 1

    # ========================================================================
    # STAGE 2: DOCKER BUILD & PUSH
    # ========================================================================

    docker-build-and-push:
        name: ðŸ³ Docker Build & Push (${{ matrix.service.name }})
        runs-on: ubuntu-latest
        timeout-minutes: 60
        needs: test-summary
        if: |
            success() &&
            github.event_name == 'push' &&
            (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop')
        strategy:
            fail-fast: false
            matrix:
                service:
                    - name: janus
                      dockerfile: infrastructure/docker/base/rust/Dockerfile
                      target: workspace
                      build_args: SERVICE_NAME=janus
                    - name: execution
                      dockerfile: infrastructure/docker/base/rust/Dockerfile
                      target: execution
                      build_args: SERVICE_NAME=execution
        steps:
            - name: ðŸ“¥ Checkout code
              uses: actions/checkout@v4

            - name: ðŸ³ Build and Push
              uses: nuniesmith/actions/.github/actions/docker-build-push@main
              with:
                  image-name: ${{ env.IMAGE_PREFIX }}-${{ matrix.service.name }}
                  username: ${{ secrets.DOCKER_USERNAME }}
                  password: ${{ secrets.DOCKER_TOKEN }}
                  dockerfile: ${{ matrix.service.dockerfile }}
                  context: "."
                  platforms: "linux/amd64"
                  push: "true"
                  tags: |
                      type=raw,value=latest
                      type=sha,prefix=
                  build-args: ${{ matrix.service.build_args }}

    # ========================================================================
    # STAGE 3: TAILSCALE & DNS SETUP
    # ========================================================================

    tailscale-setup:
        name: ðŸ” Tailscale & DNS Setup
        runs-on: ubuntu-latest
        timeout-minutes: 15
        needs: docker-build-and-push
        if: |
            always() &&
            needs.docker-build-and-push.result == 'success' &&
            github.event_name == 'push' &&
            github.ref == 'refs/heads/main' &&
            !inputs.skip_deploy
        outputs:
            tailscale_ip: ${{ steps.tailscale.outputs.tailscale-ip }}

        steps:
            - name: ðŸ“¥ Checkout code
              uses: actions/checkout@v4

            - name: âœ… Validate Tailscale ACL
              run: |
                  jq empty infrastructure/configs/tailscale/tailscale-acl.json || echo "âš ï¸ ACL file not found"

            - name: ðŸ”Œ Connect to Tailscale
              id: tailscale
              uses: nuniesmith/actions/.github/actions/tailscale-connect@main
              with:
                  oauth-client-id: ${{ secrets.TAILSCALE_OAUTH_CLIENT_ID }}
                  oauth-secret: ${{ secrets.TAILSCALE_OAUTH_SECRET }}
                  target-ip: ${{ secrets.PROD_TAILSCALE_IP }}

            - name: ðŸŒ Update Cloudflare DNS
              if: steps.tailscale.outputs.connected == 'true'
              run: |
                  TAILSCALE_IP="${{ steps.tailscale.outputs.tailscale-ip }}"

                  # Function to update or create DNS record
                  update_dns_record() {
                    local RECORD_NAME="$1"
                    local DISPLAY_NAME="$2"

                    echo "ðŸ“¡ Updating DNS record: $DISPLAY_NAME"

                    RECORD_RESPONSE=$(curl -s -X GET \
                      "https://api.cloudflare.com/client/v4/zones/${{ secrets.CLOUDFLARE_ZONE_ID }}/dns_records?type=A&name=${RECORD_NAME}" \
                      -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_KEY }}" \
                      -H "Content-Type: application/json")

                    RECORD_ID=$(echo "$RECORD_RESPONSE" | jq -r '.result[0].id // empty')

                    if [ -z "$RECORD_ID" ]; then
                      echo "  Creating new record..."
                      curl -s -X POST "https://api.cloudflare.com/client/v4/zones/${{ secrets.CLOUDFLARE_ZONE_ID }}/dns_records" \
                        -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_KEY }}" \
                        -H "Content-Type: application/json" \
                        --data "{\"type\":\"A\",\"name\":\"${RECORD_NAME}\",\"content\":\"$TAILSCALE_IP\",\"ttl\":1,\"proxied\":false}"
                    else
                      echo "  Updating existing record..."
                      curl -s -X PUT "https://api.cloudflare.com/client/v4/zones/${{ secrets.CLOUDFLARE_ZONE_ID }}/dns_records/$RECORD_ID" \
                        -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_KEY }}" \
                        -H "Content-Type: application/json" \
                        --data "{\"type\":\"A\",\"name\":\"${RECORD_NAME}\",\"content\":\"$TAILSCALE_IP\",\"ttl\":1,\"proxied\":false}"
                    fi
                    echo "  âœ… Done"
                  }

                  # Update root domain (fkstrading.xyz)
                  update_dns_record "${{ env.DOMAIN }}" "${{ env.DOMAIN }}"

                  # Update www subdomain (www.fkstrading.xyz)
                  update_dns_record "www.${{ env.DOMAIN }}" "www.${{ env.DOMAIN }}"

                  echo "## ðŸŒ DNS Update" >> $GITHUB_STEP_SUMMARY
                  echo "âœ… Updated ${{ env.DOMAIN }} â†’ $TAILSCALE_IP" >> $GITHUB_STEP_SUMMARY
                  echo "âœ… Updated www.${{ env.DOMAIN }} â†’ $TAILSCALE_IP" >> $GITHUB_STEP_SUMMARY

    # ========================================================================
    # STAGE 4: PRODUCTION DEPLOYMENT
    # ========================================================================

    deploy-production:
        name: ðŸš€ Deploy to Production
        runs-on: ubuntu-latest
        timeout-minutes: 30
        needs: tailscale-setup
        if: |
            always() &&
            needs.tailscale-setup.result == 'success' &&
            github.event_name == 'push' &&
            github.ref == 'refs/heads/main' &&
            !inputs.skip_deploy
        environment:
            name: production
            url: https://fkstrading.xyz

        steps:
            - name: ðŸ“¥ Checkout code
              uses: actions/checkout@v4

            - name: ðŸ”Œ Connect to Tailscale
              uses: nuniesmith/actions/.github/actions/tailscale-connect@main
              with:
                  oauth-client-id: ${{ secrets.TAILSCALE_OAUTH_CLIENT_ID }}
                  oauth-secret: ${{ secrets.TAILSCALE_OAUTH_SECRET }}
                  target-ip: ${{ secrets.PROD_TAILSCALE_IP }}
                  target-ssh-port: ${{ secrets.PROD_SSH_PORT || '22' }}

            - name: ðŸš€ Deploy via SSH
              uses: nuniesmith/actions/.github/actions/ssh-deploy@main
              with:
                  host: ${{ secrets.PROD_TAILSCALE_IP }}
                  port: ${{ secrets.PROD_SSH_PORT || '22' }}
                  username: ${{ secrets.PROD_SSH_USER || 'actions' }}
                  ssh-key: ${{ secrets.PROD_SSH_KEY }}
                  project-path: ~/fks
                  git-pull: "true"
                  docker-pull: "true"
                  docker-prune: "true"
                  pre-deploy-command: |
                      if [ ! -d ~/fks/.git ]; then
                        echo "ðŸ“¦ Cloning repository for first-time setup..."
                        rm -rf ~/fks
                        git clone https://github.com/nuniesmith/fks.git ~/fks
                      fi
                  deploy-command: |
                      # Generate .env if not exists
                      if [ ! -f .env ]; then
                        echo "ðŸ“ Generating .env file with secure secrets..."
                        {
                          echo "# Auto-generated by CI/CD on $(date)"
                          echo "POSTGRES_PASSWORD=$(openssl rand -hex 16)"
                          echo "REDIS_PASSWORD=$(openssl rand -hex 16)"
                          echo "QUESTDB_PASSWORD=$(openssl rand -hex 16)"
                          echo "GRAFANA_PASSWORD=$(openssl rand -hex 16)"
                          echo "GRAFANA_USER=admin"
                          echo "TRADING_MODE=simulation"
                          echo "REAL_ORDERS_ENABLED=false"
                          echo "BYBIT_API_KEY=placeholder"
                          echo "BYBIT_API_SECRET=placeholder"
                          echo "BYBIT_TESTNET=true"
                          echo "ENABLE_EXECUTION=true"
                        } > .env
                        echo "âœ… .env file created"
                      fi

                      # Ensure required production variables exist in .env
                      grep -q "^TRADING_MODE=" .env || echo "TRADING_MODE=simulation" >> .env
                      grep -q "^REAL_ORDERS_ENABLED=" .env || echo "REAL_ORDERS_ENABLED=false" >> .env
                      grep -q "^BYBIT_API_KEY=" .env || echo "BYBIT_API_KEY=placeholder" >> .env
                      grep -q "^BYBIT_API_SECRET=" .env || echo "BYBIT_API_SECRET=placeholder" >> .env

                      # Source .env to export variables for docker-compose
                      set -a
                      source .env
                      set +a

                      # Pull latest images
                      docker compose -f infrastructure/compose/docker-compose.yml \
                        -f infrastructure/compose/docker-compose.prod.yml pull

                      # Deploy services
                      ./run.sh prod up 2>/dev/null || \
                        docker compose -f infrastructure/compose/docker-compose.yml \
                          -f infrastructure/compose/docker-compose.prod.yml up -d

                      # Show status
                      docker compose -f infrastructure/compose/docker-compose.yml \
                        -f infrastructure/compose/docker-compose.prod.yml ps
                  post-deploy-command: |
                      echo "âœ… FKS services deployed"

            - name: ðŸ¥ Health check
              timeout-minutes: 5
              run: |
                  sleep 30
                  curl -sSf https://${{ env.DOMAIN }}/health > /dev/null 2>&1 && \
                    echo "âœ… Health check passed" || \
                    echo "âš ï¸ Health check failed - manual verification needed"
              continue-on-error: true

            - name: ðŸ“£ Notify deployment success
              if: success()
              uses: nuniesmith/actions/.github/actions/discord-notify@main
              continue-on-error: true
              env:
                  DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK_GITHUB }}
              with:
                  webhook-url: ${{ secrets.DISCORD_WEBHOOK_GITHUB }}
                  title: "ðŸš€ FKS Deployed to Production"
                  description: "Services deployed successfully to ${{ env.DOMAIN }}"
                  status: success
                  include-repo-info: "true"
                  fields: |
                      [
                        {"name": "Environment", "value": "production", "inline": true},
                        {"name": "Domain", "value": "${{ env.DOMAIN }}", "inline": true}
                      ]

            - name: ðŸ“£ Notify deployment failure
              if: failure()
              uses: nuniesmith/actions/.github/actions/discord-notify@main
              continue-on-error: true
              env:
                  DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK_GITHUB }}
              with:
                  webhook-url: ${{ secrets.DISCORD_WEBHOOK_GITHUB }}
                  title: "âŒ FKS Deployment Failed"
                  description: "Production deployment failed. Check logs for details."
                  status: failure
                  include-repo-info: "true"

    # ========================================================================
    # LLM AUDIT (POST-CI ANALYSIS)
    # ========================================================================

    grok-audit-post-ci:
        name: ðŸ§  Grok Audit (Post-CI)
        runs-on: ubuntu-latest
        timeout-minutes: 45
        needs:
            - rust-quality-and-tests
            - kotlin-kmp-quality-and-tests
            - static-audit
        if: |
            always() &&
            (needs.rust-quality-and-tests.result == 'success' || needs.rust-quality-and-tests.result == 'failure') &&
            github.event_name != 'workflow_dispatch'

        steps:
            - name: ðŸ“¥ Checkout code
              uses: actions/checkout@v4
              with:
                  fetch-depth: 50
                  token: ${{ secrets.GITHUB_TOKEN }}

            - name: ðŸ¦€ Setup Rust
              uses: nuniesmith/actions/.github/actions/setup-rust@main
              with:
                  rust-version: ${{ env.RUST_VERSION }}
                  cache-key-suffix: grok-audit

            - name: ðŸ“¦ Restore Grok audit cache
              uses: actions/cache@v4
              with:
                  path: .audit-cache
                  key: grok-audit-cache-${{ github.ref_name }}-${{ hashFiles('src/**/*.rs', 'src/**/*.kt') }}
                  restore-keys: |
                      grok-audit-cache-${{ github.ref_name }}-
                      grok-audit-cache-main-
                      grok-audit-cache-

            - name: ðŸ”¨ Build audit CLI
              run: cargo build --release -p fks-audit --bin audit-cli

            - name: ðŸ“Š Collect CI Context
              id: ci_context
              run: |
                  COMMIT_SHA="${{ github.sha }}"
                  BEFORE_SHA="${{ github.event.before }}"

                  if [ "${{ github.event_name }}" = "push" ] && [ -n "$BEFORE_SHA" ] && [ "$BEFORE_SHA" != "0000000000000000000000000000000000000000" ]; then
                      CHANGED_FILES=$(git diff --name-only "$BEFORE_SHA..$COMMIT_SHA" 2>/dev/null | head -100)
                  else
                      CHANGED_FILES=$(git diff --name-only HEAD~1 2>/dev/null || echo "")
                  fi

                  CHANGED_COUNT=$(echo "$CHANGED_FILES" | grep -c '.' 2>/dev/null || echo "0")
                  RS_COUNT=$(echo "$CHANGED_FILES" | grep -c '\.rs$' 2>/dev/null || echo "0")
                  KT_COUNT=$(echo "$CHANGED_FILES" | grep -c '\.kt$' 2>/dev/null || echo "0")

                  cat > ci-context.json << EOF
                  {
                    "workflow": {
                      "run_id": "${{ github.run_id }}",
                      "event": "${{ github.event_name }}",
                      "branch": "${{ github.ref_name }}"
                    },
                    "commit": {
                      "sha": "$COMMIT_SHA",
                      "message": $(git log -1 --pretty=format:'"%s"')
                    },
                    "changes": {
                      "total_files": $CHANGED_COUNT,
                      "rust_files": $RS_COUNT,
                      "kotlin_files": $KT_COUNT
                    },
                    "ci_results": {
                      "rust_quality": "${{ needs.rust-quality-and-tests.result }}",
                      "kotlin_quality": "${{ needs.kotlin-kmp-quality-and-tests.result }}",
                      "static_audit": "${{ needs.static-audit.result }}"
                    }
                  }
                  EOF

                  echo "changed_count=$CHANGED_COUNT" >> $GITHUB_OUTPUT
                  echo "$CHANGED_FILES" > changed-files.txt

            - name: ðŸ¤– Run LLM Audit
              if: steps.ci_context.outputs.changed_count != '0'
              uses: nuniesmith/actions/.github/actions/llm-audit@main
              with:
                  provider: "xai"
                  audit-mode: "regular"
                  source-path: "src"
                  file-patterns: "*.rs,*.kt"
                  exclude-patterns: "target/*,build/*,.git/*"
                  output-dir: "./audit-results"
                  max-files: "30"
                  xai-api-key: ${{ secrets.XAI_API_KEY }}
                  upload-artifacts: "true"
                  commit-results: "false"

            - name: ðŸ’¾ Save audit cache
              uses: actions/cache/save@v4
              if: always()
              with:
                  path: .audit-cache
                  key: grok-audit-cache-${{ github.ref_name }}-${{ hashFiles('src/**/*.rs', 'src/**/*.kt') }}

            - name: ðŸ’¬ PR Comment with Audit Results
              if: github.event_name == 'pull_request'
              uses: actions/github-script@v7
              with:
                  script: |
                      const fs = require('fs');
                      let body = '## ðŸ§  LLM Code Audit Results\n\n';

                      try {
                        if (fs.existsSync('./audit-results/audit-report.json')) {
                          const data = JSON.parse(fs.readFileSync('./audit-results/audit-report.json', 'utf8'));
                          body += `**Status:** ${data.status}\n`;
                          body += `**Files Analyzed:** ${data.files_analyzed || 0}\n`;
                          body += `**Provider:** ${data.provider || 'xai'}\n`;
                        } else {
                          body += 'No audit results available.\n';
                        }
                      } catch (e) {
                        body += `Error reading audit results: ${e.message}\n`;
                      }

                      await github.rest.issues.createComment({
                        issue_number: context.issue.number,
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        body: body
                      });
              continue-on-error: true

    # ========================================================================
    # PIPELINE SUMMARY
    # ========================================================================

    pipeline-summary:
        name: ðŸ“Š Pipeline Summary
        runs-on: ubuntu-latest
        timeout-minutes: 5
        needs:
            - rust-quality-and-tests
            - kotlin-kmp-quality-and-tests
            - chaos-tests
            - static-audit
            - auto-format
            - test-summary
            - docker-build-and-push
            - tailscale-setup
            - deploy-production
            - grok-audit-post-ci
        if: always()

        steps:
            - name: ðŸ“Š Generate consolidated CI report
              run: |
                  cat >> $GITHUB_STEP_SUMMARY << EOF
                  # ðŸš€ FKS CI/CD Pipeline Summary

                  ## Test Results
                  | Job | Status |
                  |-----|--------|
                  | ðŸ¦€ Rust Quality & Tests | ${{ needs.rust-quality-and-tests.result || 'skipped' }} |
                  | ðŸŽ¯ Kotlin/KMP Tests | ${{ needs.kotlin-kmp-quality-and-tests.result || 'skipped' }} |
                  | ðŸ”¥ Chaos Tests | ${{ needs.chaos-tests.result || 'skipped' }} |
                  | ðŸ“‹ Static Audit | ${{ needs.static-audit.result || 'skipped' }} |
                  | âœ¨ Auto-Format | ${{ needs.auto-format.result || 'skipped' }} |

                  ## Build & Deploy
                  | Stage | Status |
                  |-------|--------|
                  | ðŸ³ Docker Build | ${{ needs.docker-build-and-push.result || 'skipped' }} |
                  | ðŸ” Tailscale Setup | ${{ needs.tailscale-setup.result || 'skipped' }} |
                  | ðŸš€ Deploy Production | ${{ needs.deploy-production.result || 'skipped' }} |
                  | ðŸ§  LLM Audit | ${{ needs.grok-audit-post-ci.result || 'skipped' }} |

                  ## Build Info
                  | Property | Value |
                  |----------|-------|
                  | Branch | \`${{ github.ref_name }}\` |
                  | Commit | \`${{ github.sha }}\` |
                  | Event | \`${{ github.event_name }}\` |
                  | Actor | \`${{ github.actor }}\` |
                  EOF

            - name: âŒ Mark pipeline as failed
              if: |
                  needs.rust-quality-and-tests.result == 'failure' ||
                  needs.docker-build-and-push.result == 'failure' ||
                  needs.deploy-production.result == 'failure'
              run: |
                  echo "âŒ Pipeline failed due to critical job failure"
                  exit 1
