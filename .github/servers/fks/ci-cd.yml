# =============================================================================
# FKS CI/CD Pipeline
# =============================================================================
# Streamlined pipeline using reusable composite actions from nuniesmith/actions.
#
# Pipeline Flow:
# 1. Setup - Determine environment
# 2. Docker Build & Push - Multi-service matrix build
# 3. Deploy - Tailscale, DNS, SSL, Deploy, Health Checks
# 4. Summary - Pipeline results
#
# Required Secrets:
# - PROD_TAILSCALE_IP, PROD_SSH_KEY, PROD_SSH_USER, PROD_SSH_PORT
# - TAILSCALE_OAUTH_CLIENT_ID, TAILSCALE_OAUTH_SECRET
# - DOCKER_USERNAME, DOCKER_TOKEN
# - CLOUDFLARE_API_KEY, CLOUDFLARE_ZONE_ID
# - SSL_EMAIL
# - DISCORD_WEBHOOK_ACTIONS (optional)
# =============================================================================

name: ðŸš€ CI/CD Pipeline

on:
    push:
        branches: [main, develop]
        paths-ignore:
            - "**.md"
            - "docs/**"
            - ".github/workflows/llm-audit.yml"
    pull_request:
        branches: [main, develop]
    workflow_dispatch:
        inputs:
            skip_deploy:
                description: "Skip deployment"
                required: false
                type: boolean
                default: false
            skip_ssl:
                description: "Skip SSL certificate generation"
                required: false
                type: boolean
                default: false
            environment:
                description: "Target environment"
                required: false
                type: choice
                options:
                    - auto
                    - staging
                    - production
                default: auto

permissions:
    contents: write
    pull-requests: write
    packages: write
    checks: write

env:
    RUST_VERSION: "1.92.0"
    CARGO_TERM_COLOR: always
    REGISTRY: docker.io
    IMAGE_NAME: nuniesmith/fks
    DOMAIN: fkstrading.xyz
    STAGING_DOMAIN: staging.fkstrading.xyz

concurrency:
    group: ${{ github.workflow }}-${{ github.ref }}
    cancel-in-progress: true

defaults:
    run:
        shell: bash

jobs:
    # =========================================================================
    # STAGE 1: SETUP
    # =========================================================================
    setup:
        name: ðŸ“‹ Setup
        runs-on: ubuntu-latest
        timeout-minutes: 5
        outputs:
            deploy_env: ${{ steps.determine-env.outputs.environment }}
            target_host: ${{ steps.determine-env.outputs.host }}
            target_domain: ${{ steps.determine-env.outputs.domain }}
        steps:
            - name: ðŸŽ¯ Determine deployment environment
              id: determine-env
              env:
                  HAS_PROD_IP: ${{ secrets.PROD_TAILSCALE_IP != '' }}
                  HAS_SSH_KEY: ${{ secrets.PROD_SSH_KEY != '' }}
                  HAS_TAILSCALE: ${{ secrets.TAILSCALE_OAUTH_CLIENT_ID != '' }}
              run: |
                  # Determine environment
                  if [ "${{ inputs.environment }}" != "" ] && [ "${{ inputs.environment }}" != "auto" ]; then
                    ENV="${{ inputs.environment }}"
                  elif [ "${{ github.ref }}" == "refs/heads/main" ]; then
                    ENV="production"
                  else
                    ENV="staging"
                  fi

                  # Set host and domain based on environment
                  if [ "$ENV" = "production" ]; then
                    HOST="${{ secrets.PROD_TAILSCALE_IP }}"
                    DOMAIN="${{ env.DOMAIN }}"
                  else
                    HOST="${{ secrets.STAGING_TAILSCALE_IP || secrets.PROD_TAILSCALE_IP }}"
                    DOMAIN="${{ env.STAGING_DOMAIN }}"
                  fi

                  echo "environment=$ENV" >> $GITHUB_OUTPUT
                  echo "host=$HOST" >> $GITHUB_OUTPUT
                  echo "domain=$DOMAIN" >> $GITHUB_OUTPUT

                  # Validate required secrets
                  MISSING=""
                  [ "$HAS_PROD_IP" != "true" ] && MISSING="$MISSING PROD_TAILSCALE_IP"
                  [ "$HAS_SSH_KEY" != "true" ] && MISSING="$MISSING PROD_SSH_KEY"
                  [ "$HAS_TAILSCALE" != "true" ] && MISSING="$MISSING TAILSCALE_OAUTH_CLIENT_ID"

                  if [ -n "$MISSING" ]; then
                    echo "âš ï¸ Missing secrets:$MISSING"
                    echo "## âš ï¸ Missing Secrets" >> $GITHUB_STEP_SUMMARY
                    echo "Configure these secrets:$MISSING" >> $GITHUB_STEP_SUMMARY
                  fi

                  # Summary
                  cat >> $GITHUB_STEP_SUMMARY << EOF
                  ## ðŸŽ¯ Environment Configuration
                  | Property | Value |
                  |----------|-------|
                  | Target | \`$ENV\` |
                  | Domain | \`$DOMAIN\` |
                  | Branch | \`${{ github.ref_name }}\` |
                  | Trigger | \`${{ github.event_name }}\` |
                  EOF

    # =========================================================================
    # STAGE 2: DOCKER BUILD
    # =========================================================================
    docker-build:
        name: ðŸ³ Docker (${{ matrix.service.name }})
        runs-on: ubuntu-latest
        timeout-minutes: 45
        needs: [setup]
        if: |
            github.event_name == 'push' &&
            (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop') &&
            !inputs.skip_deploy
        strategy:
            fail-fast: false
            matrix:
                service:
                    - name: janus
                      dockerfile: infrastructure/docker/base/rust/Dockerfile
                      target: workspace
                      build_args: SERVICE_NAME=janus
                    - name: execution
                      dockerfile: infrastructure/docker/base/rust/Dockerfile
                      target: execution
                      build_args: SERVICE_NAME=execution
        steps:
            - name: ðŸ“¥ Checkout code
              uses: actions/checkout@v4

            - name: ðŸ³ Build and Push
              uses: nuniesmith/actions/.github/actions/docker-build-push@main
              with:
                  image-name: ${{ env.IMAGE_NAME }}
                  username: ${{ secrets.DOCKER_USERNAME }}
                  password: ${{ secrets.DOCKER_TOKEN }}
                  dockerfile: ${{ matrix.service.dockerfile }}
                  context: .
                  platforms: linux/amd64
                  push: "true"
                  tags: |
                      type=raw,value=${{ matrix.service.name }}-latest
                      type=raw,value=${{ matrix.service.name }}-${{ github.sha }}
                      type=raw,value=${{ matrix.service.name }}-${{ needs.setup.outputs.deploy_env }}
                  build-args: ${{ matrix.service.build_args }}
                  target: ${{ matrix.service.target }}

    # =========================================================================
    # STAGE 3: DEPLOY
    # =========================================================================
    deploy:
        name: ðŸš€ Deploy to ${{ needs.setup.outputs.deploy_env }}
        runs-on: ubuntu-latest
        timeout-minutes: 30
        needs: [setup, docker-build]
        if: |
            always() &&
            needs.docker-build.result == 'success' &&
            github.event_name == 'push' &&
            (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop') &&
            !inputs.skip_deploy
        environment:
            name: ${{ needs.setup.outputs.deploy_env }}
            url: https://${{ needs.setup.outputs.target_domain }}
        outputs:
            deployed: ${{ steps.deploy.outputs.deployed }}
            ssl_cert_type: ${{ steps.ssl.outputs.cert-type }}
            ssl_deployed: ${{ steps.ssl.outputs.deployed }}
            http_health: ${{ steps.health-checks.outputs.healthy }}
        steps:
            - name: ðŸ“¥ Checkout code
              uses: actions/checkout@v4

            # -----------------------------------------------------------------
            # TAILSCALE CONNECTION
            # -----------------------------------------------------------------
            - name: ðŸ”Œ Connect to Tailscale
              id: tailscale
              uses: nuniesmith/actions/.github/actions/tailscale-connect@main
              with:
                  oauth-client-id: ${{ secrets.TAILSCALE_OAUTH_CLIENT_ID }}
                  oauth-secret: ${{ secrets.TAILSCALE_OAUTH_SECRET }}
                  target-ip: ${{ needs.setup.outputs.target_host }}
                  target-ssh-port: ${{ secrets.PROD_SSH_PORT || '22' }}

            # -----------------------------------------------------------------
            # DNS UPDATE
            # -----------------------------------------------------------------
            - name: ðŸŒ Update Cloudflare DNS
              if: steps.tailscale.outputs.connected == 'true'
              uses: nuniesmith/actions/.github/actions/cloudflare-dns-update@main
              with:
                  api-token: ${{ secrets.CLOUDFLARE_API_KEY }}
                  zone-id: ${{ secrets.CLOUDFLARE_ZONE_ID }}
                  record-name: ${{ needs.setup.outputs.target_domain }}
                  record-content: ${{ needs.setup.outputs.target_host }}
                  additional-records: '[{"name": "www.${{ needs.setup.outputs.target_domain }}"}]'

            # -----------------------------------------------------------------
            # SSL CERTIFICATE CHECK
            # -----------------------------------------------------------------
            - name: ðŸ” Check Existing SSL Certificates
              id: ssl-check
              if: github.ref == 'refs/heads/main' && !inputs.skip_ssl
              uses: nuniesmith/actions/.github/actions/ssl-check@main
              continue-on-error: true
              with:
                  ssh-host: ${{ needs.setup.outputs.target_host }}
                  ssh-port: ${{ secrets.PROD_SSH_PORT || '22' }}
                  ssh-user: ${{ secrets.PROD_SSH_USER || 'actions' }}
                  ssh-key: ${{ secrets.PROD_SSH_KEY }}
                  domain: ${{ needs.setup.outputs.target_domain }}
                  cert-path: "/var/lib/docker/volumes/fks_certbot_certs/_data/live/{domain}/fullchain.pem"
                  renewal-threshold-days: "30"

            # -----------------------------------------------------------------
            # SSL CERTIFICATE GENERATION
            # -----------------------------------------------------------------
            - name: ðŸ” Generate & Deploy SSL Certificates
              id: ssl
              if: |
                  github.ref == 'refs/heads/main' &&
                  !inputs.skip_ssl &&
                  steps.ssl-check.outputs.skip-generation != 'true'
              uses: nuniesmith/actions/.github/actions/ssl-certbot-cloudflare@main
              with:
                  domain: ${{ needs.setup.outputs.target_domain }}
                  additional-domains: "www.${{ needs.setup.outputs.target_domain }}"
                  cloudflare-api-token: ${{ secrets.CLOUDFLARE_API_KEY }}
                  email: ${{ secrets.SSL_EMAIL }}
                  fallback-to-self-signed: "true"
                  self-signed-days: "365"
                  deploy-to-server: "true"
                  ssh-host: ${{ needs.setup.outputs.target_host }}
                  ssh-port: ${{ secrets.PROD_SSH_PORT || '22' }}
                  ssh-user: ${{ secrets.PROD_SSH_USER || 'actions' }}
                  ssh-key: ${{ secrets.PROD_SSH_KEY }}
                  docker-volume-name: "fks_certbot_certs"
                  docker-username: ${{ secrets.DOCKER_USERNAME }}
                  docker-token: ${{ secrets.DOCKER_TOKEN }}

            # -----------------------------------------------------------------
            # DEPLOYMENT
            # -----------------------------------------------------------------
            - name: ðŸš€ Deploy via SSH
              id: deploy
              uses: nuniesmith/actions/.github/actions/ssh-deploy@main
              with:
                  host: ${{ needs.setup.outputs.target_host }}
                  port: ${{ secrets.PROD_SSH_PORT || '22' }}
                  username: ${{ secrets.PROD_SSH_USER || 'actions' }}
                  ssh-key: ${{ secrets.PROD_SSH_KEY }}
                  project-path: ~/fks
                  git-pull: "true"
                  git-branch: ${{ github.ref_name }}
                  docker-pull: "true"
                  docker-prune: "false"
                  pre-deploy-command: |
                      echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                      echo "ðŸ“‹ PRE-DEPLOY: ${{ needs.setup.outputs.deploy_env }}"
                      echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                      echo "ðŸ–¥ï¸  Host: $(hostname) | $(date)"
                      echo "ðŸ’¾ Disk: $(df -h / | tail -1 | awk '{print $4}') free"

                      # First-time setup
                      [ ! -d ~/fks/.git ] && git clone https://github.com/nuniesmith/fks.git ~/fks

                      # Ensure Docker volumes
                      for vol in fks_certbot_certs fks_certbot_www fks_postgres_data fks_questdb_data fks_redis_data fks_grafana_data fks_prometheus_data fks_loki_data fks_alertmanager_data fks_optimizer_data fks_promtail_positions; do
                        docker volume create $vol 2>/dev/null || true
                      done

                  deploy-command: |
                      echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                      echo "ðŸš€ DEPLOYING: ${{ needs.setup.outputs.deploy_env }}"
                      echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

                      # Docker login
                      echo "${{ secrets.DOCKER_TOKEN }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin docker.io || true

                      # Environment setup
                      [ ! -f .env ] && touch .env
                      ensure_env() { grep -q "^${1}=" .env || echo "${1}=${2}" >> .env; }
                      ensure_env "POSTGRES_PASSWORD" "$(openssl rand -hex 16)"
                      ensure_env "POSTGRES_USER" "fks_user"
                      ensure_env "POSTGRES_DB" "fks"
                      ensure_env "REDIS_PASSWORD" "$(openssl rand -hex 16)"
                      ensure_env "QUESTDB_PASSWORD" "$(openssl rand -hex 16)"
                      ensure_env "GRAFANA_PASSWORD" "$(openssl rand -hex 16)"
                      ensure_env "GRAFANA_USER" "admin"
                      ensure_env "TRADING_MODE" "simulation"
                      ensure_env "REAL_ORDERS_ENABLED" "false"
                      ensure_env "ENABLE_EXECUTION" "true"
                      ensure_env "REGISTRY" "docker.io"
                      ensure_env "IMAGE_NAME" "nuniesmith/fks"
                      ensure_env "ENVIRONMENT" "${{ needs.setup.outputs.deploy_env }}"
                      set -a && source .env && set +a

                      # Deploy with run.sh or fallback to docker compose
                      chmod +x ./run.sh 2>/dev/null || true
                      if [ -x "./run.sh" ]; then
                        ./run.sh prod down 2>/dev/null || true
                        docker compose --env-file .env -f infrastructure/compose/docker-compose.yml -f infrastructure/compose/docker-compose.prod.yml pull --ignore-pull-failures 2>&1 || true
                        ./run.sh prod start 2>&1
                      else
                        COMPOSE_CMD="docker compose --env-file .env -f infrastructure/compose/docker-compose.yml -f infrastructure/compose/docker-compose.prod.yml"
                        $COMPOSE_CMD down --remove-orphans 2>/dev/null || true
                        $COMPOSE_CMD pull --ignore-pull-failures 2>&1 || true
                        $COMPOSE_CMD up -d 2>&1
                      fi

                      sleep 30
                      echo "ðŸ“Š Container Status:"
                      docker ps -a --filter "name=fks" --format "table {{.Names}}\t{{.Status}}" | head -15

                  post-deploy-command: |
                      docker image prune -f --filter "until=24h" 2>/dev/null || true
                      echo "âœ… Deployment complete!"

            # -----------------------------------------------------------------
            # HEALTH CHECKS
            # -----------------------------------------------------------------
            - name: ðŸ¥ Run Health Checks
              id: health-checks
              if: always() && steps.deploy.outcome == 'success'
              uses: nuniesmith/actions/.github/actions/health-check@main
              with:
                  endpoints: |
                      [
                        {"url": "http://${{ needs.setup.outputs.target_host }}/health", "expected_status": 200},
                        {"url": "http://${{ needs.setup.outputs.target_host }}/health/web", "expected_status": 200},
                        {"url": "http://${{ needs.setup.outputs.target_host }}/health/janus", "expected_status": 200},
                        {"url": "http://${{ needs.setup.outputs.target_host }}/health/execution", "expected_status": 200},
                        {"url": "http://${{ needs.setup.outputs.target_host }}/health/grafana", "expected_status": 200}
                      ]
                  containers: "fks_janus fks_execution fks_postgres fks_redis fks_questdb fks_prometheus fks_grafana fks_nginx"
                  ssh-host: ${{ needs.setup.outputs.target_host }}
                  ssh-port: ${{ secrets.PROD_SSH_PORT || '22' }}
                  ssh-user: ${{ secrets.PROD_SSH_USER || 'actions' }}
                  ssh-key: ${{ secrets.PROD_SSH_KEY }}
                  custom-command: |
                      echo "ðŸ” Database connectivity check..."
                      docker exec fks_redis redis-cli ping 2>/dev/null | grep -q "PONG" && echo "âœ… Redis OK" || echo "âŒ Redis failed"
                      docker exec fks_postgres pg_isready -U postgres 2>/dev/null | grep -q "accepting" && echo "âœ… PostgreSQL OK" || echo "âŒ PostgreSQL failed"
                      curl -s "http://localhost:9000/exec?query=SELECT%201" 2>/dev/null | grep -q "dataset" && echo "âœ… QuestDB OK" || echo "âŒ QuestDB failed"
                  initial-delay: "30"
                  retry-count: "3"
                  retry-delay: "10"
                  fail-on-unhealthy: "false"

            # -----------------------------------------------------------------
            # NOTIFICATION
            # -----------------------------------------------------------------
            - name: ðŸ“£ Notify deployment
              if: always()
              uses: nuniesmith/actions/.github/actions/discord-notify@main
              continue-on-error: true
              with:
                  webhook-url: ${{ secrets.DISCORD_WEBHOOK_ACTIONS }}
                  title: "${{ steps.deploy.outcome == 'success' && 'ðŸš€ FKS Deployed' || 'âŒ FKS Deploy Failed' }}"
                  description: "Deployed to ${{ needs.setup.outputs.deploy_env }}"
                  status: ${{ steps.deploy.outcome == 'success' && 'success' || 'failure' }}
                  include-repo-info: "true"
                  fields: |
                      [
                        {"name": "Environment", "value": "${{ needs.setup.outputs.deploy_env }}", "inline": true},
                        {"name": "Domain", "value": "${{ needs.setup.outputs.target_domain }}", "inline": true},
                        {"name": "SSL", "value": "${{ steps.ssl.outputs.cert-type || steps.ssl-check.outputs.cert-type || 'skipped' }}", "inline": true},
                        {"name": "Health", "value": "${{ steps.health-checks.outputs.healthy == 'true' && 'âœ… healthy' || 'âš ï¸ degraded' }}", "inline": true}
                      ]

    # =========================================================================
    # PIPELINE SUMMARY
    # =========================================================================
    pipeline-summary:
        name: ðŸ“Š Pipeline Summary
        runs-on: ubuntu-latest
        timeout-minutes: 5
        needs: [setup, docker-build, deploy]
        if: always()
        steps:
            - name: ðŸ“Š Generate summary
              run: |
                  cat >> $GITHUB_STEP_SUMMARY << EOF
                  # ðŸš€ FKS CI/CD Pipeline Summary

                  ## Environment
                  | Property | Value |
                  |----------|-------|
                  | Target | \`${{ needs.setup.outputs.deploy_env }}\` |
                  | Domain | \`${{ needs.setup.outputs.target_domain }}\` |
                  | Branch | \`${{ github.ref_name }}\` |

                  ## Jobs
                  | Job | Status |
                  |-----|--------|
                  | ðŸ³ Docker Build | ${{ needs.docker-build.result || 'skipped' }} |
                  | ðŸš€ Deploy | ${{ needs.deploy.result || 'skipped' }} |

                  ## Details
                  | Property | Value |
                  |----------|-------|
                  | SSL Certificate | ${{ needs.deploy.outputs.ssl_cert_type || 'N/A' }} |
                  | Health Check | ${{ needs.deploy.outputs.http_health == 'true' && 'âœ… Healthy' || 'âš ï¸ Check logs' }} |

                  ---
                  **Actor:** \`${{ github.actor }}\` | **Run:** \`#${{ github.run_number }}\`
                  EOF

            - name: âŒ Fail on critical errors
              if: needs.docker-build.result == 'failure' || needs.deploy.result == 'failure'
              run: |
                  echo "âŒ Pipeline failed"
                  exit 1
