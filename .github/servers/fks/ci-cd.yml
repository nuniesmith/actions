# =============================================================================
# FKS CI/CD Pipeline
# =============================================================================
# Streamlined pipeline using reusable composite actions from nuniesmith/actions.
#
# Pipeline Flow:
# 1. Docker Build & Push - Multi-service matrix build
# 2. Infrastructure Setup - Tailscale, DNS
# 3. SSL Certificates - Let's Encrypt with self-signed fallback
# 4. Deployment - Staging (develop) or Production (main)
# 5. Health Checks - Verify deployment success
# 6. Post-CI - LLM audit, notifications
#
# NOTE: Tests are currently disabled to focus on deployment process
# =============================================================================

name: üöÄ CI/CD Pipeline

on:
    push:
        branches: [main, develop]
        paths-ignore:
            - "**.md"
            - "docs/**"
            - ".github/workflows/llm-audit.yml"
    pull_request:
        branches: [main, develop]
    workflow_dispatch:
        inputs:
            skip_deploy:
                description: "Skip deployment"
                required: false
                type: boolean
                default: false
            skip_ssl:
                description: "Skip SSL certificate generation"
                required: false
                type: boolean
                default: true
            environment:
                description: "Target environment"
                required: false
                type: choice
                options:
                    - auto
                    - staging
                    - production
                default: auto

permissions:
    contents: write
    pull-requests: write
    packages: write
    checks: write

env:
    RUST_VERSION: "1.92.0"
    CARGO_TERM_COLOR: always
    REDIS_URL: redis://localhost:6379/0
    REGISTRY: docker.io
    IMAGE_NAME: nuniesmith/fks
    DOMAIN: fkstrading.xyz
    STAGING_DOMAIN: staging.fkstrading.xyz

concurrency:
    group: ${{ github.workflow }}-${{ github.ref }}
    cancel-in-progress: true

defaults:
    run:
        shell: bash

# =============================================================================
# JOBS
# =============================================================================
jobs:
    # =========================================================================
    # STAGE 1: ENVIRONMENT SETUP
    # =========================================================================

    setup:
        name: üìã Setup
        runs-on: ubuntu-latest
        timeout-minutes: 5
        outputs:
            deploy_env: ${{ steps.determine-env.outputs.environment }}
        steps:
            - name: üéØ Determine deployment environment
              id: determine-env
              run: |
                  # Check workflow dispatch input first
                  if [ "${{ inputs.environment }}" != "" ] && [ "${{ inputs.environment }}" != "auto" ]; then
                    ENV="${{ inputs.environment }}"
                  elif [ "${{ github.ref }}" = "refs/heads/main" ]; then
                    ENV="production"
                  elif [ "${{ github.ref }}" = "refs/heads/develop" ]; then
                    ENV="staging"
                  else
                    ENV="none"
                  fi

                  echo "environment=$ENV" >> $GITHUB_OUTPUT
                  echo "üìç Target environment: $ENV"

                  echo "## üìã Pipeline Configuration" >> $GITHUB_STEP_SUMMARY
                  echo "" >> $GITHUB_STEP_SUMMARY
                  echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
                  echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
                  echo "| Environment | \`$ENV\` |" >> $GITHUB_STEP_SUMMARY
                  echo "| Branch | \`${{ github.ref_name }}\` |" >> $GITHUB_STEP_SUMMARY
                  echo "| Commit | \`${{ github.sha }}\` |" >> $GITHUB_STEP_SUMMARY
                  echo "| Tests | \`disabled\` |" >> $GITHUB_STEP_SUMMARY

    # =========================================================================
    # STAGE 2: DOCKER BUILD & PUSH
    # =========================================================================

    docker-build:
        name: üê≥ Docker (${{ matrix.service.name }})
        runs-on: ubuntu-latest
        timeout-minutes: 60
        needs: setup
        if: |
            github.event_name == 'push' &&
            (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop')
        strategy:
            fail-fast: false
            matrix:
                service:
                    - name: janus
                      dockerfile: infrastructure/docker/base/rust/Dockerfile
                      target: workspace
                      build_args: SERVICE_NAME=janus
                    - name: execution
                      dockerfile: infrastructure/docker/base/rust/Dockerfile
                      target: execution
                      build_args: SERVICE_NAME=execution
        steps:
            - name: üì• Checkout code
              uses: actions/checkout@v4

            - name: üê≥ Build and Push
              uses: nuniesmith/actions/.github/actions/docker-build-push@main
              with:
                  image-name: ${{ env.IMAGE_NAME }}
                  username: ${{ secrets.DOCKER_USERNAME }}
                  password: ${{ secrets.DOCKER_TOKEN }}
                  dockerfile: ${{ matrix.service.dockerfile }}
                  context: "."
                  platforms: "linux/amd64"
                  push: "true"
                  tags: |
                      type=raw,value=${{ matrix.service.name }}-latest
                      type=raw,value=${{ matrix.service.name }}-${{ github.sha }}
                      type=raw,value=${{ matrix.service.name }}-${{ needs.setup.outputs.deploy_env }}
                  build-args: ${{ matrix.service.build_args }}
                  target: ${{ matrix.service.target }}

            - name: üîç Verify Image Contents
              run: |
                  echo "üîç Verifying ${{ matrix.service.name }} image contents..."
                  IMAGE="${{ env.IMAGE_NAME }}:${{ matrix.service.name }}-latest"

                  # Pull the image we just pushed
                  docker pull "$IMAGE"

                  # List contents of /app directory
                  echo "üìÅ Contents of /app:"
                  docker run --rm --entrypoint ls "$IMAGE" -la /app

                  # Verify the service binary exists and is executable
                  echo "üîé Checking /app/service binary:"
                  docker run --rm --entrypoint file "$IMAGE" /app/service || true

                  # Try to get version/help from the binary (if supported)
                  echo "üìã Binary info:"
                  docker run --rm "$IMAGE" --version 2>/dev/null || \
                  docker run --rm "$IMAGE" --help 2>/dev/null | head -5 || \
                  echo "Note: Binary does not support --version or --help flags"

                  echo "‚úÖ Image verification complete for ${{ matrix.service.name }}"

    # =========================================================================
    # STAGE 3: INFRASTRUCTURE SETUP
    # =========================================================================

    infrastructure-setup:
        name: üîê Infrastructure (${{ needs.setup.outputs.deploy_env }})
        runs-on: ubuntu-latest
        timeout-minutes: 15
        needs: [setup, docker-build]
        if: |
            needs.docker-build.result == 'success' &&
            github.event_name == 'push' &&
            (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop') &&
            !inputs.skip_deploy
        outputs:
            tailscale_connected: ${{ steps.tailscale.outputs.connected }}
            target_host: ${{ steps.config.outputs.host }}
            target_domain: ${{ steps.config.outputs.domain }}
            target_hostname: ${{ steps.config.outputs.hostname }}
        steps:
            - name: üì• Checkout code
              uses: actions/checkout@v4

            - name: üîç Validate required secrets
              run: |
                  ENV="${{ needs.setup.outputs.deploy_env }}"
                  MISSING_SECRETS=""

                  # Check PROD_TAILSCALE_IP (always required)
                  if [ -z "${{ secrets.PROD_TAILSCALE_IP }}" ]; then
                    MISSING_SECRETS="${MISSING_SECRETS}\n  - PROD_TAILSCALE_IP (required for all deployments)"
                  fi

                  # Check PROD_SSH_KEY (always required)
                  if [ -z "${{ secrets.PROD_SSH_KEY }}" ]; then
                    MISSING_SECRETS="${MISSING_SECRETS}\n  - PROD_SSH_KEY (required for SSH deployment)"
                  fi

                  # Check Tailscale OAuth (required for VPN connection)
                  if [ -z "${{ secrets.TAILSCALE_OAUTH_CLIENT_ID }}" ]; then
                    MISSING_SECRETS="${MISSING_SECRETS}\n  - TAILSCALE_OAUTH_CLIENT_ID (required for Tailscale connection)"
                  fi
                  if [ -z "${{ secrets.TAILSCALE_OAUTH_SECRET }}" ]; then
                    MISSING_SECRETS="${MISSING_SECRETS}\n  - TAILSCALE_OAUTH_SECRET (required for Tailscale connection)"
                  fi

                  if [ -n "$MISSING_SECRETS" ]; then
                    echo "‚ùå Missing required secrets for $ENV deployment:"
                    echo -e "$MISSING_SECRETS"
                    echo ""
                    echo "üìù Please add these secrets in: Settings ‚Üí Secrets and variables ‚Üí Actions"
                    echo ""
                    echo "## ‚ùå Missing Secrets" >> $GITHUB_STEP_SUMMARY
                    echo "The following secrets are required but not configured:" >> $GITHUB_STEP_SUMMARY
                    echo -e "$MISSING_SECRETS" >> $GITHUB_STEP_SUMMARY
                    exit 1
                  fi

                  echo "‚úÖ All required secrets are configured"

            - name: ‚öôÔ∏è Configure environment
              id: config
              run: |
                  ENV="${{ needs.setup.outputs.deploy_env }}"
                  if [ "$ENV" = "production" ]; then
                    HOST="${{ secrets.PROD_TAILSCALE_IP }}"
                    HOSTNAME="${{ secrets.PROD_HOSTNAME }}"
                    echo "host=$HOST" >> $GITHUB_OUTPUT
                    echo "hostname=$HOSTNAME" >> $GITHUB_OUTPUT
                    echo "domain=${{ env.DOMAIN }}" >> $GITHUB_OUTPUT
                    echo "ssh_port=${{ secrets.PROD_SSH_PORT || '22' }}" >> $GITHUB_OUTPUT
                  else
                    HOST="${{ secrets.STAGING_TAILSCALE_IP || secrets.PROD_TAILSCALE_IP }}"
                    HOSTNAME="${{ secrets.STAGING_HOSTNAME || secrets.PROD_HOSTNAME }}"
                    echo "host=$HOST" >> $GITHUB_OUTPUT
                    echo "hostname=$HOSTNAME" >> $GITHUB_OUTPUT
                    echo "domain=${{ env.STAGING_DOMAIN }}" >> $GITHUB_OUTPUT
                    echo "ssh_port=${{ secrets.STAGING_SSH_PORT || secrets.PROD_SSH_PORT || '22' }}" >> $GITHUB_OUTPUT
                  fi

                  # Double-check host is not empty
                  if [ -z "$HOST" ]; then
                    echo "‚ùå Host IP is empty after configuration!"
                    echo "Environment: $ENV"
                    echo "This should not happen if secrets validation passed."
                    exit 1
                  fi

                  echo "‚úÖ Configured for $ENV: host=$HOST, hostname=${HOSTNAME:-not set}"

            - name: ‚úÖ Validate Tailscale ACL
              run: |
                  jq empty infrastructure/configs/tailscale/tailscale-acl.json || echo "‚ö†Ô∏è ACL file not found"

            - name: üîå Connect to Tailscale
              id: tailscale
              uses: nuniesmith/actions/.github/actions/tailscale-connect@main
              with:
                  oauth-client-id: ${{ secrets.TAILSCALE_OAUTH_CLIENT_ID }}
                  oauth-secret: ${{ secrets.TAILSCALE_OAUTH_SECRET }}
                  target-ip: ${{ steps.config.outputs.host }}

            - name: üåê Update Cloudflare DNS
              if: steps.tailscale.outputs.connected == 'true'
              uses: nuniesmith/actions/.github/actions/cloudflare-dns-update@main
              with:
                  api-token: ${{ secrets.CLOUDFLARE_API_KEY }}
                  zone-id: ${{ secrets.CLOUDFLARE_ZONE_ID }}
                  record-name: ${{ steps.config.outputs.domain }}
                  record-content: ${{ steps.config.outputs.host }}
                  additional-records: '[{"name": "www.${{ steps.config.outputs.domain }}"}]'

    # =========================================================================
    # STAGE 3.5: SSL CERTIFICATES
    # =========================================================================

    ssl-certificates:
        name: üîê SSL Certificates
        runs-on: ubuntu-latest
        timeout-minutes: 15
        needs: [setup, infrastructure-setup]
        if: |
            needs.infrastructure-setup.result == 'success' &&
            github.event_name == 'push' &&
            github.ref == 'refs/heads/main' &&
            !inputs.skip_deploy &&
            !inputs.skip_ssl
        outputs:
            cert_ready: ${{ steps.ssl.outputs.cert-ready }}
            cert_type: ${{ steps.ssl.outputs.cert-type }}
            deployed: ${{ steps.ssl.outputs.deployed }}
        steps:
            - name: üì• Checkout code
              uses: actions/checkout@v4

            - name: ‚öôÔ∏è Configure SSL target
              id: ssl-config
              run: |
                  # Use secrets directly for reliability
                  TARGET_HOST="${{ secrets.PROD_TAILSCALE_IP }}"
                  TARGET_DOMAIN="${{ env.DOMAIN }}"
                  TARGET_HOSTNAME="${{ secrets.PROD_HOSTNAME }}"

                  # Final validation
                  if [ -z "$TARGET_HOST" ]; then
                    echo "‚ùå ERROR: PROD_TAILSCALE_IP secret is not configured!"
                    echo "## ‚ùå Missing: PROD_TAILSCALE_IP" >> $GITHUB_STEP_SUMMARY
                    exit 1
                  fi

                  echo "host=$TARGET_HOST" >> $GITHUB_OUTPUT
                  echo "domain=$TARGET_DOMAIN" >> $GITHUB_OUTPUT
                  echo "hostname=$TARGET_HOSTNAME" >> $GITHUB_OUTPUT

                  echo "‚úÖ SSL target configured:"
                  echo "   Host: $TARGET_HOST"
                  echo "   Hostname: ${TARGET_HOSTNAME:-not set}"
                  echo "   Domain: $TARGET_DOMAIN"

            - name: üîå Connect to Tailscale
              uses: nuniesmith/actions/.github/actions/tailscale-connect@main
              with:
                  oauth-client-id: ${{ secrets.TAILSCALE_OAUTH_CLIENT_ID }}
                  oauth-secret: ${{ secrets.TAILSCALE_OAUTH_SECRET }}
                  target-ip: ${{ steps.ssl-config.outputs.host }}

            - name: üîê Generate & Deploy SSL Certificates
              id: ssl
              uses: nuniesmith/actions/.github/actions/ssl-certbot-cloudflare@main
              with:
                  domain: ${{ steps.ssl-config.outputs.domain }}
                  additional-domains: "www.${{ steps.ssl-config.outputs.domain }}"
                  cloudflare-api-token: ${{ secrets.CLOUDFLARE_API_KEY }}
                  email: ${{ secrets.SSL_EMAIL }}
                  fallback-to-self-signed: "true"
                  self-signed-days: "365"
                  deploy-to-server: "true"
                  ssh-host: ${{ steps.ssl-config.outputs.host }}
                  ssh-port: ${{ secrets.PROD_SSH_PORT || '22' }}
                  ssh-user: ${{ secrets.PROD_SSH_USER || 'actions' }}
                  ssh-key: ${{ secrets.PROD_SSH_KEY }}
                  docker-volume-name: "fks_certbot_certs"
                  docker-username: ${{ secrets.DOCKER_USERNAME }}
                  docker-token: ${{ secrets.DOCKER_TOKEN }}

    # =========================================================================
    # STAGE 4: DEPLOYMENT
    # =========================================================================

    deploy:
        name: üöÄ Deploy to ${{ needs.setup.outputs.deploy_env }}
        runs-on: ubuntu-latest
        timeout-minutes: 30
        needs: [setup, docker-build, infrastructure-setup, ssl-certificates]
        if: |
            always() &&
            needs.docker-build.result == 'success' &&
            needs.infrastructure-setup.result == 'success' &&
            (needs.ssl-certificates.result == 'success' || needs.ssl-certificates.result == 'skipped') &&
            github.event_name == 'push' &&
            (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop') &&
            !inputs.skip_deploy
        environment:
            name: ${{ needs.setup.outputs.deploy_env }}
            url: https://${{ needs.infrastructure-setup.outputs.target_domain }}
        outputs:
            deployed: ${{ steps.deploy.outputs.deployed }}
        steps:
            - name: üì• Checkout code
              uses: actions/checkout@v4

            - name: ‚öôÔ∏è Configure deploy target
              id: deploy-config
              run: |
                  # Use secrets directly for reliability
                  TARGET_HOST="${{ secrets.PROD_TAILSCALE_IP }}"
                  TARGET_DOMAIN="${{ env.DOMAIN }}"
                  TARGET_HOSTNAME="${{ secrets.PROD_HOSTNAME }}"

                  # Final validation
                  if [ -z "$TARGET_HOST" ]; then
                    echo "‚ùå ERROR: PROD_TAILSCALE_IP secret is not configured!"
                    echo "## ‚ùå Missing: PROD_TAILSCALE_IP" >> $GITHUB_STEP_SUMMARY
                    exit 1
                  fi

                  echo "host=$TARGET_HOST" >> $GITHUB_OUTPUT
                  echo "domain=$TARGET_DOMAIN" >> $GITHUB_OUTPUT
                  echo "hostname=$TARGET_HOSTNAME" >> $GITHUB_OUTPUT

                  echo "‚úÖ Deploy target configured:"
                  echo "   Host: $TARGET_HOST"
                  echo "   Hostname: ${TARGET_HOSTNAME:-not set}"
                  echo "   Domain: $TARGET_DOMAIN"

            - name: üîå Connect to Tailscale
              uses: nuniesmith/actions/.github/actions/tailscale-connect@main
              with:
                  oauth-client-id: ${{ secrets.TAILSCALE_OAUTH_CLIENT_ID }}
                  oauth-secret: ${{ secrets.TAILSCALE_OAUTH_SECRET }}
                  target-ip: ${{ steps.deploy-config.outputs.host }}
                  target-ssh-port: ${{ secrets.PROD_SSH_PORT || '22' }}

            - name: üöÄ Deploy via SSH
              id: deploy
              uses: nuniesmith/actions/.github/actions/ssh-deploy@main
              with:
                  host: ${{ steps.deploy-config.outputs.host }}
                  port: ${{ secrets.PROD_SSH_PORT || '22' }}
                  username: ${{ secrets.PROD_SSH_USER || 'actions' }}
                  ssh-key: ${{ secrets.PROD_SSH_KEY }}
                  project-path: ~/fks
                  git-pull: "true"
                  git-branch: ${{ github.ref_name }}
                  docker-pull: "true"
                  docker-prune: "false"
                  pre-deploy-command: |
                      echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
                      echo "üìã PRE-DEPLOY: ${{ needs.setup.outputs.deploy_env }}"
                      echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"

                      # System info
                      echo "üñ•Ô∏è  Host: $(hostname) | $(date)"
                      echo "üíæ Disk: $(df -h / | tail -1 | awk '{print $4}') free | Memory: $(free -h | grep Mem | awk '{print $7}') available"

                      # First-time setup
                      if [ ! -d ~/fks/.git ]; then
                        echo "üì¶ First-time setup - cloning repository..."
                        rm -rf ~/fks
                        git clone https://github.com/nuniesmith/fks.git ~/fks
                      fi

                      # Ensure Docker volumes (must match docker-compose.yml external volumes)
                      echo "üì¶ Ensuring Docker volumes..."
                      for vol in fks_certbot_certs fks_certbot_www fks_postgres_data fks_questdb_data fks_redis_data fks_grafana_data fks_prometheus_data fks_loki_data fks_alertmanager_data fks_optimizer_data fks_promtail_positions; do
                        docker volume create $vol 2>/dev/null || true
                      done
                      echo "‚úÖ Volumes ready"

                  deploy-command: |
                      echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
                      echo "üöÄ DEPLOYING: ${{ needs.setup.outputs.deploy_env }}"
                      echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"

                      # Docker login
                      echo "${{ secrets.DOCKER_TOKEN }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin docker.io || true

                      # Environment setup - create .env if missing
                      [ ! -f .env ] && touch .env

                      # Ensure required env vars
                      ensure_env() {
                        local VAR="$1" DEFAULT="$2"
                        grep -q "^${VAR}=" .env || echo "${VAR}=${DEFAULT}" >> .env
                      }

                      ensure_env "POSTGRES_PASSWORD" "$(openssl rand -hex 16)"
                      ensure_env "POSTGRES_USER" "fks_user"
                      ensure_env "POSTGRES_DB" "fks"
                      ensure_env "REDIS_PASSWORD" "$(openssl rand -hex 16)"
                      ensure_env "QUESTDB_PASSWORD" "$(openssl rand -hex 16)"
                      ensure_env "GRAFANA_PASSWORD" "$(openssl rand -hex 16)"
                      ensure_env "GRAFANA_USER" "admin"
                      ensure_env "TRADING_MODE" "simulation"
                      ensure_env "REAL_ORDERS_ENABLED" "false"
                      ensure_env "ENABLE_EXECUTION" "true"
                      ensure_env "REGISTRY" "docker.io"
                      ensure_env "IMAGE_NAME" "nuniesmith/fks"
                      ensure_env "ENVIRONMENT" "${{ needs.setup.outputs.deploy_env }}"

                      set -a && source .env && set +a

                      # Make run.sh executable
                      chmod +x ./run.sh 2>/dev/null || true

                      # Use run.sh prod start for deployment (syntax: ./run.sh prod <command>)
                      echo "üöÄ Starting services with run.sh prod start..."
                      if [ -x "./run.sh" ]; then
                        # Stop existing containers first
                        ./run.sh prod down 2>/dev/null || true

                        # Pull production images
                        echo "üì• Pulling production images..."
                        docker compose --env-file .env -f infrastructure/compose/docker-compose.yml -f infrastructure/compose/docker-compose.prod.yml pull --ignore-pull-failures 2>&1 || true

                        # Start with run.sh (handles volumes, env, dependencies)
                        ./run.sh prod start 2>&1
                      else
                        # Fallback to direct docker compose if run.sh not available
                        echo "‚ö†Ô∏è run.sh not found, using direct docker compose..."
                        COMPOSE_CMD="docker compose --env-file .env -f infrastructure/compose/docker-compose.yml -f infrastructure/compose/docker-compose.prod.yml"

                        # Stop existing
                        echo "üõë Stopping containers..."
                        $COMPOSE_CMD down --remove-orphans 2>/dev/null || true

                        # Pull all images (including infrastructure)
                        echo "üì• Pulling images..."
                        $COMPOSE_CMD pull --ignore-pull-failures 2>&1 || true

                        # Start services
                        echo "üöÄ Starting containers..."
                        $COMPOSE_CMD up -d 2>&1
                      fi

                      # Wait for services to start
                      echo "‚è≥ Waiting for services to initialize..."
                      sleep 30

                      # Check running containers
                      RUNNING=$(docker ps --filter "name=fks" --format '{{.Names}}' | wc -l)
                      echo "‚úÖ Running: $RUNNING containers"

                      # Show container status
                      echo ""
                      echo "üìä Container Status:"
                      docker ps -a --filter "name=fks" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" | head -20

                      # Check for critical services
                      CRITICAL_SERVICES="fks_postgres fks_redis fks_questdb fks_prometheus"
                      MISSING=""
                      for svc in $CRITICAL_SERVICES; do
                        if ! docker ps --format '{{.Names}}' | grep -q "^${svc}$"; then
                          MISSING="$MISSING $svc"
                        fi
                      done

                      if [ -n "$MISSING" ]; then
                        echo ""
                        echo "‚ö†Ô∏è Warning: Some critical services may not be running:$MISSING"
                        echo "Check logs with: docker logs <container_name>"
                      fi

                      if [ "$RUNNING" -lt 6 ]; then
                        echo ""
                        echo "‚ö†Ô∏è Warning: Only $RUNNING containers running (expected 10+)"
                        echo "Checking failed containers..."
                        docker ps -a --filter "name=fks" --filter "status=exited" --format "table {{.Names}}\t{{.Status}}" 2>/dev/null || true
                      fi

                  post-deploy-command: |
                      echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
                      echo "üßπ POST-DEPLOY CLEANUP"
                      echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"

                      # Cleanup old images (keep 24h)
                      docker image prune -f --filter "until=24h" 2>/dev/null || true

                      echo ""
                      echo "üåê Access URLs:"
                      echo "   Grafana:    http://$(hostname -I | awk '{print $1}'):3000"
                      echo "   Prometheus: http://$(hostname -I | awk '{print $1}'):9090"
                      echo "   QuestDB:    http://$(hostname -I | awk '{print $1}'):9000"
                      echo ""
                      echo "‚úÖ Deployment complete!"

    # =========================================================================
    # STAGE 5: HEALTH CHECKS
    # =========================================================================

    health-check:
        name: üè• Health Check
        runs-on: ubuntu-latest
        timeout-minutes: 10
        needs: [setup, infrastructure-setup, deploy]
        if: |
            needs.deploy.result == 'success'
        steps:
            - name: üì• Checkout code
              uses: actions/checkout@v4

            - name: ‚öôÔ∏è Configure health-check target
              id: health-config
              run: |
                  # Use secrets directly for reliability
                  TARGET_HOST="${{ secrets.PROD_TAILSCALE_IP }}"
                  TARGET_DOMAIN="${{ env.DOMAIN }}"
                  TARGET_HOSTNAME="${{ secrets.PROD_HOSTNAME }}"

                  # Final validation
                  if [ -z "$TARGET_HOST" ]; then
                    echo "‚ùå ERROR: PROD_TAILSCALE_IP secret is not configured!"
                    exit 1
                  fi

                  echo "host=$TARGET_HOST" >> $GITHUB_OUTPUT
                  echo "domain=$TARGET_DOMAIN" >> $GITHUB_OUTPUT
                  echo "hostname=$TARGET_HOSTNAME" >> $GITHUB_OUTPUT

                  echo "‚úÖ Health-check target configured:"
                  echo "   Host: $TARGET_HOST"
                  echo "   Hostname: ${TARGET_HOSTNAME:-not set}"
                  echo "   Domain: $TARGET_DOMAIN"

            - name: üîå Connect to Tailscale
              uses: nuniesmith/actions/.github/actions/tailscale-connect@main
              with:
                  oauth-client-id: ${{ secrets.TAILSCALE_OAUTH_CLIENT_ID }}
                  oauth-secret: ${{ secrets.TAILSCALE_OAUTH_SECRET }}
                  target-ip: ${{ steps.health-config.outputs.host }}

            - name: üè• Run Health Checks
              uses: nuniesmith/actions/.github/actions/health-check@main
              with:
                  endpoints: |
                      [
                        {"url": "https://${{ steps.health-config.outputs.domain }}/health", "expected_status": 200},
                        {"url": "http://${{ steps.health-config.outputs.host }}:3000/api/health", "expected_status": 200},
                        {"url": "http://${{ steps.health-config.outputs.host }}:9090/-/healthy", "expected_status": 200}
                      ]
                  containers: "fks_postgres fks_redis fks_questdb fks_prometheus fks_grafana"
                  ssh-host: ${{ steps.health-config.outputs.host }}
                  ssh-port: ${{ secrets.PROD_SSH_PORT || '22' }}
                  ssh-user: ${{ secrets.PROD_SSH_USER || 'actions' }}
                  ssh-key: ${{ secrets.PROD_SSH_KEY }}
                  initial-delay: "30"
                  retry-count: "3"
                  retry-delay: "10"
                  fail-on-unhealthy: "false"

            - name: üì£ Notify deployment
              if: always()
              uses: nuniesmith/actions/.github/actions/discord-notify@main
              continue-on-error: true
              with:
                  webhook-url: ${{ secrets.DISCORD_WEBHOOK_ACTIONS }}
                  title: "${{ needs.deploy.result == 'success' && 'üöÄ FKS Deployed' || '‚ùå FKS Deploy Failed' }}"
                  description: "Deployed to ${{ needs.setup.outputs.deploy_env }}"
                  status: ${{ needs.deploy.result == 'success' && 'success' || 'failure' }}
                  include-repo-info: "true"
                  fields: |
                      [
                        {"name": "Environment", "value": "${{ needs.setup.outputs.deploy_env }}", "inline": true},
                        {"name": "Domain", "value": "${{ steps.health-config.outputs.domain || env.DOMAIN }}", "inline": true},
                        {"name": "SSL", "value": "${{ needs.ssl-certificates.outputs.cert_type || 'skipped' }}", "inline": true}
                      ]

    # =========================================================================
    # STAGE 6: POST-CI ANALYSIS
    # =========================================================================

    llm-audit:
        name: üß† LLM Audit
        runs-on: ubuntu-latest
        timeout-minutes: 45
        needs: [deploy]
        if: |
            always() &&
            needs.deploy.result == 'success' &&
            github.event_name != 'workflow_dispatch'
        steps:
            - name: üì• Checkout code
              uses: actions/checkout@v4
              with:
                  fetch-depth: 50

            - name: üìä Collect changed files
              id: changes
              run: |
                  if [ "${{ github.event_name }}" = "push" ] && [ -n "${{ github.event.before }}" ]; then
                    CHANGED=$(git diff --name-only ${{ github.event.before }}..${{ github.sha }} 2>/dev/null | wc -l || echo "0")
                  else
                    CHANGED=$(git diff --name-only HEAD~1 2>/dev/null | wc -l || echo "0")
                  fi
                  echo "count=$CHANGED" >> $GITHUB_OUTPUT

            - name: ü§ñ Run LLM Audit
              if: steps.changes.outputs.count != '0'
              uses: nuniesmith/actions/.github/actions/llm-audit@main
              with:
                  provider: "xai"
                  audit-mode: "regular"
                  source-path: "src"
                  file-patterns: "*.rs,*.kt"
                  exclude-patterns: "target/*,build/*,.git/*"
                  output-dir: "./audit-results"
                  max-files: "30"
                  xai-api-key: ${{ secrets.XAI_API_KEY }}
                  upload-artifacts: "true"
                  commit-results: "false"

            - name: üí¨ PR Comment with Results
              if: github.event_name == 'pull_request'
              uses: actions/github-script@v7
              continue-on-error: true
              with:
                  script: |
                      const fs = require('fs');
                      let body = '## üß† LLM Code Audit\n\n';
                      try {
                        if (fs.existsSync('./audit-results/audit-report.json')) {
                          const data = JSON.parse(fs.readFileSync('./audit-results/audit-report.json', 'utf8'));
                          body += `**Files Analyzed:** ${data.files_analyzed || 0}\n`;
                        } else {
                          body += 'No audit results available.\n';
                        }
                      } catch (e) {
                        body += `Error: ${e.message}\n`;
                      }
                      await github.rest.issues.createComment({
                        issue_number: context.issue.number,
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        body: body
                      });

    # =========================================================================
    # PIPELINE SUMMARY
    # =========================================================================

    pipeline-summary:
        name: üìä Pipeline Summary
        runs-on: ubuntu-latest
        timeout-minutes: 5
        needs:
            - setup
            - docker-build
            - infrastructure-setup
            - ssl-certificates
            - deploy
            - health-check
            - llm-audit
        if: always()
        steps:
            - name: üìä Generate summary
              run: |
                  ENV="${{ needs.setup.outputs.deploy_env || 'N/A' }}"
                  DOMAIN="${{ needs.infrastructure-setup.outputs.target_domain || 'N/A' }}"

                  cat >> $GITHUB_STEP_SUMMARY << EOF
                  # üöÄ FKS CI/CD Pipeline Summary

                  ## Environment
                  | Property | Value |
                  |----------|-------|
                  | Target | \`$ENV\` |
                  | Domain | \`$DOMAIN\` |
                  | Branch | \`${{ github.ref_name }}\` |
                  | Commit | \`${{ github.sha }}\` |

                  ## Build & Deploy Stage
                  | Job | Status |
                  |-----|--------|
                  | üê≥ Docker Build | ${{ needs.docker-build.result || 'skipped' }} |
                  | üîê Infrastructure | ${{ needs.infrastructure-setup.result || 'skipped' }} |
                  | üîí SSL Certificates | ${{ needs.ssl-certificates.result || 'skipped' }} |
                  | üöÄ Deploy | ${{ needs.deploy.result || 'skipped' }} |
                  | üè• Health Check | ${{ needs.health-check.result || 'skipped' }} |

                  ## SSL Details
                  | Property | Value |
                  |----------|-------|
                  | Certificate Type | ${{ needs.ssl-certificates.outputs.cert_type || 'N/A' }} |
                  | Certificate Ready | ${{ needs.ssl-certificates.outputs.cert_ready || 'N/A' }} |
                  | Deployed | ${{ needs.ssl-certificates.outputs.deployed || 'N/A' }} |

                  ## Post-CI
                  | Job | Status |
                  |-----|--------|
                  | üß† LLM Audit | ${{ needs.llm-audit.result || 'skipped' }} |

                  ---
                  **Actor:** \`${{ github.actor }}\` | **Workflow:** \`${{ github.run_number }}\`
                  EOF

            - name: ‚ùå Fail on critical errors
              if: |
                  needs.docker-build.result == 'failure' ||
                  needs.deploy.result == 'failure'
              run: |
                  echo "‚ùå Pipeline failed due to critical job failure"
                  exit 1
