name: üöÄ Unified Service Management

on:
  workflow_call:
    inputs:
      service_name:
        description: 'Name of the service to manage (e.g., fks, nginx, ats)'
        required: true
        type: string
      
      action_type:
        description: 'Action to perform'
        required: false
        type: string
        default: 'deploy'
        # Options: deploy, destroy, health-check, restart
      
      deployment_mode:
        description: 'Deployment mode'
        required: false
        type: string
        default: 'full-deploy'
        # Options: full-deploy, update-only, restart-only, code-only
      
      # Feature Toggles
      skip_tests:
        description: 'Skip running code tests'
        required: false
        type: boolean
        default: false
      
      skip_docker_build:
        description: 'Skip building Docker images'
        required: false
        type: boolean
        default: false
      
      build_docker_on_changes:
        description: 'Only build Docker if code/Dockerfile changed'
        required: false
        type: boolean
        default: true
      
      overwrite_server:
        description: 'Destroy and recreate Linode server'
        required: false
        type: boolean
        default: false
      
      # Server Configuration
      server_type:
        description: 'Linode server type'
        required: false
        type: string
        default: 'g6-standard-2'
      
      target_region:
        description: 'Linode region'
        required: false
        type: string
        default: 'ca-central'
      
      domain_suffix:
        description: 'Domain suffix (e.g., 7gram.xyz)'
        required: false
        type: string
        default: '7gram.xyz'
      
      # Feature Toggles
      enable_backups:
        description: 'Enable Linode backups'
        required: false
        type: boolean
        default: false
      
      # Destroy Options (for destroy action)
      destroy_scope:
        description: 'What to destroy (for destroy action)'
        required: false
        type: string
        default: 'service-only'
      
      confirm_destruction:
        description: 'Type "DESTROY" to confirm destruction'
        required: false
        type: string

    secrets:
      # Core Infrastructure
      LINODE_CLI_TOKEN:
        required: true
      SERVICE_ROOT_PASSWORD:
        required: true
      
      # User Management
      JORDAN_PASSWORD:
        required: true
      ACTIONS_USER_PASSWORD:
        required: true
      
      # VPN & Networking
      TS_OAUTH_CLIENT_ID:
        description: 'Tailscale OAuth client ID'
        required: true
      TS_OAUTH_SECRET:
        description: 'Tailscale OAuth client secret'
        required: true
      TAILSCALE_TAILNET:
        description: 'Tailscale tailnet name (optional)'
        required: false
      
      # DNS Management (Optional)
      CLOUDFLARE_EMAIL:
        required: false
      CLOUDFLARE_API_TOKEN:
        required: false
      ADMIN_EMAIL:
        description: 'Admin email for Let''s Encrypt SSL certificates'
        required: false
      
      # Container Registry (Optional)
      DOCKER_USERNAME:
        required: false
      DOCKER_TOKEN:
        required: false

    outputs:
      # Infrastructure outputs
      server_ip:
        description: 'Public IP address of the deployed server'
        value: ${{ jobs.setup-infrastructure.outputs.server_ip }}
      server_id:
        description: 'Linode server ID'
        value: ${{ jobs.setup-infrastructure.outputs.server_id }}
      tailscale_ip:
        description: 'Tailscale IP address of the server'
        value: ${{ jobs.setup-infrastructure.outputs.tailscale_ip }}

  workflow_dispatch:
    inputs:
      service_name:
        description: 'Name of the service to manage'
        required: true
        type: choice
        options:
          - 'fks'
          - 'nginx'
          - 'ats'
          - 'custom'
      
      action_type:
        description: 'Action to perform'
        required: true
        type: choice
        options:
          - 'deploy'
          - 'destroy'
          - 'health-check'
          - 'restart'
        default: 'deploy'
      
      deployment_mode:
        description: 'Deployment mode (for deploy action)'
        required: false
        type: choice
        options:
          - 'full-deploy'
          - 'update-only'
          - 'restart-only'
          - 'code-only'
        default: 'full-deploy'
      
      # Feature Options
      skip_tests:
        description: 'Skip running code tests'
        required: false
        type: boolean
        default: false
      
      skip_docker_build:
        description: 'Skip building Docker images'
        required: false
        type: boolean
        default: false
      
      overwrite_server:
        description: 'Destroy and recreate Linode server'
        required: false
        type: boolean
        default: false
      
      # Server Configuration
      server_type:
        description: 'Linode server type'
        required: false
        type: choice
        options:
          - 'g6-nanode-1'          # 1GB RAM
          - 'g6-standard-1'        # 2GB RAM
          - 'g6-standard-2'        # 4GB RAM
          - 'g6-standard-4'        # 8GB RAM
          - 'g6-standard-8'        # 16GB RAM
        default: 'g6-standard-2'

env:
  SERVICE_NAME: ${{ inputs.service_name }}
  ACTION_TYPE: ${{ inputs.action_type }}
  DEPLOYMENT_MODE: ${{ inputs.deployment_mode }}
  SERVER_TYPE: ${{ inputs.server_type }}
  TARGET_REGION: ${{ inputs.target_region || 'ca-central' }}
  DOMAIN_SUFFIX: ${{ inputs.domain_suffix || '7gram.xyz' }}
  FULL_DOMAIN: ${{ inputs.service_name }}.${{ inputs.domain_suffix || '7gram.xyz' }}

jobs:
  # ============================================================================
  # Pre-flight Checks & Validation
  # ============================================================================
  preflight-checks:
    name: üõ´ Pre-flight Checks
    runs-on: ubuntu-latest
    outputs:
      action_validated: ${{ steps.validate-action.outputs.validated }}
      should_destroy: ${{ steps.validate-action.outputs.should_destroy }}
      should_deploy: ${{ steps.validate-action.outputs.should_deploy }}
      should_health_check: ${{ steps.validate-action.outputs.should_health_check }}
      should_overwrite_server: ${{ steps.validate-action.outputs.should_overwrite_server }}
      destroy_confirmed: ${{ steps.validate-destroy.outputs.confirmed }}
      code_changed: ${{ steps.check-changes.outputs.code_changed }}
      docker_build_needed: ${{ steps.check-changes.outputs.docker_build_needed }}
    
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: üì• Checkout Actions Repository
        uses: actions/checkout@v4
        with:
          repository: nuniesmith/actions
          path: actions

      - name: üéØ Validate Action Type
        id: validate-action
        env:
          ACTION_TYPE: ${{ env.ACTION_TYPE }}
          OVERWRITE_SERVER: ${{ inputs.overwrite_server }}
        run: |
          chmod +x actions/scripts/preflight/validate-action.sh
          actions/scripts/preflight/validate-action.sh "$ACTION_TYPE" "$OVERWRITE_SERVER"

      - name: ‚ö†Ô∏è Validate Destruction Request
        id: validate-destroy
        if: steps.validate-action.outputs.should_destroy == 'true' || steps.validate-action.outputs.should_overwrite_server == 'true'
        run: |
          # For server overwrite during deployment, skip confirmation requirement
          if [[ "${{ steps.validate-action.outputs.should_overwrite_server }}" == "true" && "${{ env.ACTION_TYPE }}" == "deploy" ]]; then
            echo "‚úÖ Server overwrite confirmed (deploy mode)"
            echo "confirmed=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # For explicit destroy actions, require confirmation
          if [[ "${{ inputs.confirm_destruction }}" != "DESTROY" ]]; then
            echo "‚ùå Destruction not confirmed. You must type 'DESTROY' exactly."
            echo "confirmed=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          echo "‚úÖ Destruction confirmed for ${{ env.SERVICE_NAME }}"
          echo "confirmed=true" >> $GITHUB_OUTPUT

      - name: üîç Check for Code Changes
        id: check-changes
        if: steps.validate-action.outputs.should_deploy == 'true'
        env:
          BUILD_DOCKER_ON_CHANGES: ${{ inputs.build_docker_on_changes }}
        run: |
          chmod +x actions/scripts/preflight/detect-changes.sh
          actions/scripts/preflight/detect-changes.sh "$BUILD_DOCKER_ON_CHANGES"

      - name: üîê Validate Secrets
        env:
          LINODE_CLI_TOKEN: ${{ secrets.LINODE_CLI_TOKEN }}
          SERVICE_ROOT_PASSWORD: ${{ secrets.SERVICE_ROOT_PASSWORD }}
          JORDAN_PASSWORD: ${{ secrets.JORDAN_PASSWORD }}
          ACTIONS_USER_PASSWORD: ${{ secrets.ACTIONS_USER_PASSWORD }}
          TS_OAUTH_CLIENT_ID: ${{ secrets.TS_OAUTH_CLIENT_ID }}
          TS_OAUTH_SECRET: ${{ secrets.TS_OAUTH_SECRET }}
          CLOUDFLARE_EMAIL: ${{ secrets.CLOUDFLARE_EMAIL }}
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          ADMIN_EMAIL: ${{ secrets.ADMIN_EMAIL }}
        run: |
          chmod +x actions/scripts/preflight/validate-secrets.sh
          actions/scripts/preflight/validate-secrets.sh "${{ env.SERVICE_NAME }}"

  # ============================================================================
  # Resource Cleanup (Optional, runs before deployment)
  # ============================================================================
  cleanup-old-resources:
    name: üßπ Cleanup Old Resources
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: preflight-checks
    if: |
      needs.preflight-checks.outputs.should_deploy == 'true' && 
      (github.event_name == 'push' || inputs.overwrite_server == true)
    
    steps:
      - name: üì• Checkout Actions Repository
        uses: actions/checkout@v4
        with:
          repository: nuniesmith/actions
          path: actions

      - name: üîó Set up Tailscale
        uses: tailscale/github-action@v3
        with:
          oauth-client-id: ${{ secrets.TS_OAUTH_CLIENT_ID }}
          oauth-secret: ${{ secrets.TS_OAUTH_SECRET }}
          tags: tag:ci

      - name: üßπ Cleanup Tailscale and Linode Resources
        env:
          LINODE_CLI_TOKEN: ${{ secrets.LINODE_CLI_TOKEN }}
          TS_OAUTH_CLIENT_ID: ${{ secrets.TS_OAUTH_CLIENT_ID }}
          TS_OAUTH_SECRET: ${{ secrets.TS_OAUTH_SECRET }}
          TAILSCALE_TAILNET: ${{ secrets.TAILSCALE_TAILNET }}
        run: |
          chmod +x actions/scripts/cleanup/cleanup-resources.sh
          actions/scripts/cleanup/cleanup-resources.sh "${{ env.SERVICE_NAME }}"
          
          # Also cleanup old GitHub runners and service devices from Tailscale
          echo "üßπ Cleaning up old Tailscale devices..."
          
          # Determine tailnet to use
          TAILNET_NAME="${TAILSCALE_TAILNET:-${{ github.repository_owner }}}"
          echo "üìã Using Tailnet: $TAILNET_NAME"
          
          # Get devices and clean up old ones
          if [ -n "$TS_OAUTH_SECRET" ]; then
            echo "üîç Fetching Tailscale devices..."
            DEVICES_RESPONSE=$(curl -s "https://api.tailscale.com/api/v2/tailnet/${TAILNET_NAME}/devices" \
              -H "Authorization: Bearer $TS_OAUTH_SECRET" 2>/dev/null || echo "ERROR")
            
            if [ "$DEVICES_RESPONSE" != "ERROR" ]; then
              echo "üìã Tailscale devices response received"
              echo "$DEVICES_RESPONSE" | jq -r '.devices[]? | select(.hostname | test("github-|runner-|actions-|'${{ env.SERVICE_NAME }}'-old")) | .nodeId' 2>/dev/null | \
              while read -r device_id; do
                if [ -n "$device_id" ] && [ "$device_id" != "null" ]; then
                  echo "üóëÔ∏è Removing old device: $device_id"
                  curl -s -X DELETE "https://api.tailscale.com/api/v2/device/$device_id" \
                    -H "Authorization: Bearer $TS_OAUTH_SECRET" 2>/dev/null || true
                  sleep 1  # Rate limiting
                fi
              done
            else
              echo "‚ö†Ô∏è Could not fetch Tailscale devices (API call failed)"
            fi
          else
            echo "‚ö†Ô∏è No Tailscale OAuth secret available for device cleanup"
          fi

  # ============================================================================
  # Code Testing (Optional)
  # ============================================================================
  run-tests:
    name: üß™ Run Tests
    runs-on: ubuntu-latest
    needs: [preflight-checks, cleanup-old-resources]
    if: |
      always() &&
      needs.preflight-checks.outputs.should_deploy == 'true' && 
      inputs.skip_tests == false &&
      (needs.cleanup-old-resources.result == 'success' || needs.cleanup-old-resources.result == 'skipped')
    
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: üì• Checkout Actions Repository
        uses: actions/checkout@v4
        with:
          repository: nuniesmith/actions
          path: actions

      - name: üß™ Auto-detect and Run Tests
        run: |
          chmod +x actions/scripts/testing/run-tests.sh
          actions/scripts/testing/run-tests.sh

  # ============================================================================
  # Docker Build (Conditional)
  # ============================================================================
  build-docker-api:
    name: üê≥ Build API Docker Images
    runs-on: ubuntu-latest
    needs: [preflight-checks, cleanup-old-resources, run-tests]
    if: |
      always() && 
      needs.preflight-checks.outputs.should_deploy == 'true' && 
      inputs.skip_docker_build == false && 
      needs.preflight-checks.outputs.docker_build_needed == 'true' &&
      (needs.cleanup-old-resources.result == 'success' || needs.cleanup-old-resources.result == 'skipped') &&
      (needs.run-tests.result == 'success' || needs.run-tests.result == 'skipped')
    
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: üì• Checkout Actions Repository
        uses: actions/checkout@v4
        with:
          repository: nuniesmith/actions
          path: actions

      - name: üîë Login to Docker Hub
        env:
          DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
          DOCKER_TOKEN: ${{ secrets.DOCKER_TOKEN }}
        if: env.DOCKER_USERNAME != '' && env.DOCKER_TOKEN != ''
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_TOKEN }}

      - name: üê≥ Build and Push API Docker Images
        env:
          DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
        run: |
          chmod +x actions/scripts/docker/build-api-docker.sh
          actions/scripts/docker/build-api-docker.sh "${{ env.SERVICE_NAME }}"

  build-docker-web:
    name: üåê Build Web Docker Images  
    runs-on: ubuntu-latest
    needs: [preflight-checks, cleanup-old-resources, run-tests]
    if: |
      always() && 
      needs.preflight-checks.outputs.should_deploy == 'true' && 
      inputs.skip_docker_build == false && 
      needs.preflight-checks.outputs.docker_build_needed == 'true' &&
      (needs.cleanup-old-resources.result == 'success' || needs.cleanup-old-resources.result == 'skipped') &&
      (needs.run-tests.result == 'success' || needs.run-tests.result == 'skipped')
    
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: üì• Checkout Actions Repository
        uses: actions/checkout@v4
        with:
          repository: nuniesmith/actions
          path: actions

      - name: üîë Login to Docker Hub
        env:
          DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
          DOCKER_TOKEN: ${{ secrets.DOCKER_TOKEN }}
        if: env.DOCKER_USERNAME != '' && env.DOCKER_TOKEN != ''
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_TOKEN }}

      - name: üåê Build and Push Web Docker Images
        env:
          DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
        run: |
          chmod +x actions/scripts/docker/build-web-docker.sh
          actions/scripts/docker/build-web-docker.sh "${{ env.SERVICE_NAME }}"

  build-docker-auth:
    name: üîê Build Auth Docker Images
    runs-on: ubuntu-latest
    needs: [preflight-checks, cleanup-old-resources, run-tests]
    if: |
      always() && 
      needs.preflight-checks.outputs.should_deploy == 'true' && 
      inputs.skip_docker_build == false && 
      needs.preflight-checks.outputs.docker_build_needed == 'true' &&
      (needs.cleanup-old-resources.result == 'success' || needs.cleanup-old-resources.result == 'skipped') &&
      (needs.run-tests.result == 'success' || needs.run-tests.result == 'skipped')
    
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: üì• Checkout Actions Repository
        uses: actions/checkout@v4
        with:
          repository: nuniesmith/actions
          path: actions

      - name: üîë Login to Docker Hub
        env:
          DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
          DOCKER_TOKEN: ${{ secrets.DOCKER_TOKEN }}
        if: env.DOCKER_USERNAME != '' && env.DOCKER_TOKEN != ''
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_TOKEN }}

      - name: üîê Build and Push Auth Docker Images
        env:
          DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
        run: |
          chmod +x actions/scripts/docker/build-auth-docker.sh
          actions/scripts/docker/build-auth-docker.sh "${{ env.SERVICE_NAME }}"

  # ============================================================================
  # Server Infrastructure Setup
  # ============================================================================
  setup-infrastructure:
    name: üèóÔ∏è Setup Infrastructure
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: [preflight-checks, cleanup-old-resources, build-docker-api, build-docker-web, build-docker-auth]
    if: |
      always() && 
      needs.preflight-checks.outputs.should_deploy == 'true' &&
      (needs.cleanup-old-resources.result == 'success' || needs.cleanup-old-resources.result == 'skipped') &&
      (needs.build-docker-api.result == 'success' || needs.build-docker-api.result == 'skipped') &&
      (needs.build-docker-web.result == 'success' || needs.build-docker-web.result == 'skipped') &&
      (needs.build-docker-auth.result == 'success' || needs.build-docker-auth.result == 'skipped')
    outputs:
      server_ip: ${{ steps.create-server.outputs.server_ip }}
      server_id: ${{ steps.create-server.outputs.server_id }}
      tailscale_ip: ${{ steps.stage2-setup.outputs.tailscale_ip }}
      ssh_private_key: ${{ steps.create-server.outputs.ssh_private_key }}
    
    steps:
      - name: üì• Checkout Actions Repository
        uses: actions/checkout@v4
        with:
          repository: nuniesmith/actions
          path: actions

      - name: üöÄ Create or Find Server
        id: create-server
        env:
          LINODE_CLI_TOKEN: ${{ secrets.LINODE_CLI_TOKEN }}
          SERVICE_ROOT_PASSWORD: ${{ secrets.SERVICE_ROOT_PASSWORD }}
        run: |
          # Debug environment setup
          echo "üîç Debug: Checking environment variables..."
          echo "SERVICE_NAME: ${{ env.SERVICE_NAME }}"
          echo "SERVER_TYPE: ${{ env.SERVER_TYPE }}"
          echo "TARGET_REGION: ${{ env.TARGET_REGION }}"
          echo "OVERWRITE_SERVER: ${{ inputs.overwrite_server }}"
          echo "LINODE_CLI_TOKEN set: $([ -n "$LINODE_CLI_TOKEN" ] && echo 'YES' || echo 'NO')"
          echo "SERVICE_ROOT_PASSWORD set: $([ -n "$SERVICE_ROOT_PASSWORD" ] && echo 'YES' || echo 'NO')"
          
          # Ensure script is executable and run with better error handling
          chmod +x actions/scripts/linode/create-server.sh
          
          # Pre-install and test Linode CLI
          echo "ÔøΩ Installing and testing Linode CLI..."
          pip install linode-cli
          
          # Test CLI functionality
          export LINODE_CLI_TOKEN="$LINODE_CLI_TOKEN"
          linode-cli --version
          
          echo "üîç Testing API connectivity..."
          if ! linode-cli linodes list --text --no-headers >/dev/null 2>&1; then
            echo "‚ùå Linode CLI authentication failed - check LINODE_CLI_TOKEN"
            echo "Attempting to show any error details:"
            linode-cli linodes list --text --no-headers 2>&1 || true
            exit 1
          else
            echo "‚úÖ Linode CLI authentication successful"
          fi
          
          # Validate server type and region availability
          echo "üîç Validating server type and region..."
          echo "Checking if server type '${{ env.SERVER_TYPE }}' is available in region '${{ env.TARGET_REGION }}'..."
          
          # List available types and regions for debugging
          echo "Available server types (first 10):"
          linode-cli linodes types --text --no-headers | head -10 || true
          
          echo "Available regions:"
          linode-cli regions list --text --no-headers || true
          
          # Check specific type availability
          if linode-cli linodes types --text --no-headers | grep -q "${{ env.SERVER_TYPE }}"; then
            echo "‚úÖ Server type '${{ env.SERVER_TYPE }}' is available"
          else
            echo "‚ö†Ô∏è Server type '${{ env.SERVER_TYPE }}' may not be available"
          fi
          
          # Validate password complexity (Linode requires complex passwords)
          echo "üîç Validating password complexity..."
          if [[ ${#SERVICE_ROOT_PASSWORD} -lt 6 ]]; then
            echo "‚ùå Password too short (minimum 6 characters required)"
            exit 1
          elif [[ ! "$SERVICE_ROOT_PASSWORD" =~ [A-Z] ]] || [[ ! "$SERVICE_ROOT_PASSWORD" =~ [a-z] ]] || [[ ! "$SERVICE_ROOT_PASSWORD" =~ [0-9] ]]; then
            echo "‚ö†Ô∏è Password may not meet complexity requirements (needs uppercase, lowercase, and numbers)"
          else
            echo "‚úÖ Password appears to meet complexity requirements"
          fi
          
          # Pre-create SSH directory to avoid permission issues
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Export environment variables that the script needs
          export SERVICE_ROOT_PASSWORD="$SERVICE_ROOT_PASSWORD"
          
          echo "üöÄ Starting server creation process..."
          
          # Add debugging for script execution
          echo "üîç Script execution details:"
          echo "  Service Name: '${{ env.SERVICE_NAME }}'"
          echo "  Server Type: '${{ env.SERVER_TYPE }}'"
          echo "  Target Region: '${{ env.TARGET_REGION }}'"
          echo "  Overwrite Server: '${{ inputs.overwrite_server }}'"
          
          # Check if script exists and is executable
          if [ -f "actions/scripts/linode/create-server.sh" ]; then
            echo "‚úÖ Script found: actions/scripts/linode/create-server.sh"
            ls -la actions/scripts/linode/create-server.sh
            
            # Show first few lines of script for debugging
            echo "üîç Script content preview (first 10 lines):"
            head -10 actions/scripts/linode/create-server.sh
          else
            echo "‚ùå Script not found: actions/scripts/linode/create-server.sh"
            echo "Available files in actions/scripts/linode/:"
            ls -la actions/scripts/linode/ || echo "Directory not found"
            echo "Available files in actions/scripts/:"
            ls -la actions/scripts/ || echo "Directory not found"
            exit 1
          fi
          
          # Execute with explicit error handling and detailed logging
          echo "üöÄ Executing server creation process..."
          set -e  # Exit on any error
          
          # Determine server label
          SERVER_LABEL="${{ env.SERVICE_NAME }}"
          echo "üè∑Ô∏è Using server label: $SERVER_LABEL"
          
          # Check if we need to overwrite/destroy existing servers
          if [[ "${{ inputs.overwrite_server }}" == "true" ]]; then
            echo "üîç Checking for existing servers to overwrite..."
            EXISTING_SERVERS=$(linode-cli linodes list --text --no-headers | grep "${{ env.SERVICE_NAME }}" || true)
            
            if [[ -n "$EXISTING_SERVERS" ]]; then
              echo "üóëÔ∏è Found existing servers to remove:"
              echo "$EXISTING_SERVERS"
              
              # Remove each existing server
              echo "$EXISTING_SERVERS" | while IFS= read -r server_line; do
                if [[ -n "$server_line" ]]; then
                  SERVER_ID=$(echo "$server_line" | cut -f1)
                  SERVER_LABEL_OLD=$(echo "$server_line" | cut -f2)
                  echo "üóëÔ∏è Removing existing server: $SERVER_ID ($SERVER_LABEL_OLD)"
                  linode-cli linodes delete "$SERVER_ID" || echo "‚ö†Ô∏è Failed to remove server $SERVER_ID"
                fi
              done
              
              echo "‚è≥ Waiting for server deletion to complete..."
              sleep 30
            else
              echo "‚úÖ No existing servers found with name pattern '${{ env.SERVICE_NAME }}'"
            fi
          fi
          
          # Check if server already exists (unless we just destroyed it or overwrite is enabled)
          if [[ "${{ inputs.overwrite_server }}" != "true" ]]; then
            EXISTING_SERVER=$(linode-cli linodes list --text --no-headers | grep "${{ env.SERVICE_NAME }}" | head -1)
            
            if [[ -n "$EXISTING_SERVER" ]]; then
              echo "üîç Found existing server - using it"
              SERVER_ID=$(echo "$EXISTING_SERVER" | cut -f1)
              
              # Try different columns for IP address (Linode CLI output format can vary)
              for col in 5 6 7; do
                IP=$(echo "$EXISTING_SERVER" | cut -f$col)
                if [[ "$IP" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                  SERVER_IP="$IP"
                  break
                fi
              done
              
              if [[ -z "$SERVER_IP" ]]; then
                echo "‚ùå Could not extract IP address from existing server info"
                exit 1
              fi
              
              echo "‚úÖ Using existing server: $SERVER_IP (ID: $SERVER_ID)"
              echo "server_ip=$SERVER_IP" >> $GITHUB_OUTPUT
              echo "server_id=$SERVER_ID" >> $GITHUB_OUTPUT
              
              # Create SSH key for consistency
              ssh-keygen -t rsa -b 4096 -f ~/.ssh/linode_deployment_key -N "" -C "github-actions-${{ env.SERVICE_NAME }}" 2>/dev/null || true
              SSH_PRIVATE_KEY=$(base64 -w 0 ~/.ssh/linode_deployment_key 2>/dev/null || echo "")
              echo "ssh_private_key=$SSH_PRIVATE_KEY" >> $GITHUB_OUTPUT
              
              echo "‚úÖ Server ready for deployment"
              exit 0
            fi
          fi
          
          # Create new server
          echo "üÜï Creating new server: $SERVER_LABEL"
          
          # Generate SSH key for this deployment
          echo "üîë Generating SSH key for server access..."
          ssh-keygen -t rsa -b 4096 -f ~/.ssh/linode_deployment_key -N "" -C "github-actions-${{ env.SERVICE_NAME }}"
          
          # Get the public key content for server authorization
          SSH_PUBLIC_KEY=$(cat ~/.ssh/linode_deployment_key.pub)
          echo "üîë Generated SSH key pair"
          
          # Store the private key (base64 encoded for safe storage)
          SSH_PRIVATE_KEY=$(base64 -w 0 ~/.ssh/linode_deployment_key)
          echo "ssh_private_key=$SSH_PRIVATE_KEY" >> $GITHUB_OUTPUT
          
          echo "üöÄ Creating server with Linode CLI..."
          echo "Parameters:"
          echo "  Type: ${{ env.SERVER_TYPE }}"
          echo "  Region: ${{ env.TARGET_REGION }}"
          echo "  Label: $SERVER_LABEL"
          
          # Create the server
          RESULT=$(linode-cli linodes create \
            --type "${{ env.SERVER_TYPE }}" \
            --region "${{ env.TARGET_REGION }}" \
            --image "linode/arch" \
            --label "$SERVER_LABEL" \
            --root_pass "$SERVICE_ROOT_PASSWORD" \
            --authorized_keys "$SSH_PUBLIC_KEY" \
            --backups_enabled=false \
            --text --no-headers)
          
          echo "üîç Server creation result:"
          echo "$RESULT"
          
          if [[ -z "$RESULT" ]] || [[ "$RESULT" == *"error"* ]] || [[ "$RESULT" == *"Error"* ]]; then
            echo "‚ùå Server creation failed!"
            echo "Result: $RESULT"
            exit 1
          fi
          
          SERVER_ID=$(echo "$RESULT" | cut -f1)
          
          if [[ -z "$SERVER_ID" ]] || [[ ! "$SERVER_ID" =~ ^[0-9]+$ ]]; then
            echo "‚ùå Invalid server ID extracted: '$SERVER_ID'"
            echo "Full result: $RESULT"
            exit 1
          fi
          
          echo "üÜî Server created with ID: $SERVER_ID"
          
          # Wait for server to be running
          echo "‚è≥ Waiting for server to be ready..."
          ATTEMPT=0
          while true; do
            # Get server info and check status
            SERVER_INFO=$(linode-cli linodes view "$SERVER_ID" --text --no-headers)
            
            # Debug: show the full output on first few attempts
            if [[ $ATTEMPT -lt 3 ]]; then
              echo "üîç Server info: $SERVER_INFO"
            fi
            
            # Status is typically in column 6, but let's be flexible
            STATUS=$(echo "$SERVER_INFO" | cut -f6)
            
            echo "Attempt $((++ATTEMPT)): Status='$STATUS'"
            
            # Check if server is running
            if [[ "$STATUS" == "running" ]]; then
              echo "‚úÖ Server is running!"
              break
            fi
            
            # Don't wait forever for server status
            if [[ $ATTEMPT -gt 20 ]]; then
              echo "‚ö†Ô∏è Server status check timeout - proceeding anyway"
              break
            fi
            
            sleep 10
          done
          
          # Get server IP
          SERVER_INFO=$(linode-cli linodes view "$SERVER_ID" --text --no-headers)
          echo "üîç Final server info: $SERVER_INFO"
          
          # Try different columns for IP address
          for col in 5 6 7; do
            IP=$(echo "$SERVER_INFO" | cut -f$col)
            if [[ "$IP" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              SERVER_IP="$IP"
              break
            fi
          done
          
          if [[ -z "$SERVER_IP" ]]; then
            echo "‚ùå Could not extract IP address from server info"
            echo "Server info was: $SERVER_INFO"
            exit 1
          fi
          
          echo "‚úÖ Server ready: $SERVER_IP (ID: $SERVER_ID)"
          
          echo "server_ip=$SERVER_IP" >> $GITHUB_OUTPUT
          echo "server_id=$SERVER_ID" >> $GITHUB_OUTPUT
          
          echo "‚úÖ Server creation completed successfully"

      - name: ‚è≥ Wait for SSH Access
        run: |
          chmod +x actions/scripts/linode/wait-for-ssh.sh
          actions/scripts/linode/wait-for-ssh.sh "${{ steps.create-server.outputs.server_ip }}"

      - name: üèóÔ∏è Stage 1 - Pre-Reboot Setup
        id: stage1-setup
        env:
          TS_OAUTH_CLIENT_ID: ${{ secrets.TS_OAUTH_CLIENT_ID }}
          TS_OAUTH_SECRET: ${{ secrets.TS_OAUTH_SECRET }}
          TAILSCALE_TAILNET: ${{ secrets.TAILSCALE_TAILNET }}
          CLOUDFLARE_EMAIL: ${{ secrets.CLOUDFLARE_EMAIL }}
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          ADMIN_EMAIL: ${{ secrets.ADMIN_EMAIL }}
          SERVICE_ROOT_PASSWORD: ${{ secrets.SERVICE_ROOT_PASSWORD }}
          ACTIONS_USER_PASSWORD: ${{ secrets.ACTIONS_USER_PASSWORD }}
          JORDAN_PASSWORD: ${{ secrets.JORDAN_PASSWORD }}
        run: |
          echo "üèóÔ∏è Stage 1: Pre-reboot foundation setup..."
          
          # Download existing stage1 script (keep using the existing one)
          curl -o stage1-setup.sh https://raw.githubusercontent.com/nuniesmith/actions/main/scripts/stage1-complete-setup.sh
          chmod +x stage1-setup.sh
          
          # Download and configure stage2 script
          curl -o stage2-post-reboot.sh https://raw.githubusercontent.com/nuniesmith/actions/main/scripts/stage2-post-reboot.sh
          chmod +x stage2-post-reboot.sh
          
          # Replace placeholders in setup scripts
          echo "üîÑ Replacing placeholders in setup scripts..."
          
          # Escape special characters for sed
          SAFE_ACTIONS_PASSWORD=$(printf '%s\n' "${ACTIONS_USER_PASSWORD}" | sed 's/[[\.*^$()+?{|]/\\&/g')
          SAFE_JORDAN_PASSWORD=$(printf '%s\n' "${JORDAN_PASSWORD}" | sed 's/[[\.*^$()+?{|]/\\&/g')
          SAFE_SERVICE_NAME=$(printf '%s\n' "${{ env.SERVICE_NAME }}" | sed 's/[[\.*^$()+?{|]/\\&/g')
          
          # Stage1 script replacements
          sed -i "s/SERVICE_NAME_PLACEHOLDER/${SAFE_SERVICE_NAME}/g" stage1-setup.sh
          sed -i "s/ACTIONS_USER_PASSWORD_PLACEHOLDER/${SAFE_ACTIONS_PASSWORD}/g" stage1-setup.sh
          sed -i "s/JORDAN_PASSWORD_PLACEHOLDER/${SAFE_JORDAN_PASSWORD}/g" stage1-setup.sh
          
          # Stage2 script replacements with enhanced error checking and debugging
          echo "üîç Preparing stage2 script with enhanced credential handling..."
          
          # First, validate that all required credentials are available
          echo "üîç Validating OAuth credentials availability:"
          echo "TS_OAUTH_CLIENT_ID set: $([ -n "$TS_OAUTH_CLIENT_ID" ] && echo 'YES' || echo 'NO')"
          echo "TS_OAUTH_SECRET set: $([ -n "$TS_OAUTH_SECRET" ] && echo 'YES' || echo 'NO')"
          echo "TAILSCALE_TAILNET set: $([ -n "$TAILSCALE_TAILNET" ] && echo 'YES' || echo 'NO')"
          echo "SERVICE_NAME: '${{ env.SERVICE_NAME }}'"
          
          if [[ -z "$TS_OAUTH_CLIENT_ID" ]]; then
            echo "‚ùå TS_OAUTH_CLIENT_ID is empty or not set!"
            exit 1
          fi
          
          if [[ -z "$TS_OAUTH_SECRET" ]]; then
            echo "‚ùå TS_OAUTH_SECRET is empty or not set!"
            exit 1
          fi
          
          # Create a safe escaping function that handles all special characters
          escape_for_sed() {
            printf '%s\n' "$1" | sed 's/[[\.*^$()+?{|]/\\&/g'
          }
          
          # Escape all variables with better error handling
          SAFE_CLOUDFLARE_EMAIL=$(escape_for_sed "${CLOUDFLARE_EMAIL:-}")
          SAFE_CLOUDFLARE_TOKEN=$(escape_for_sed "${CLOUDFLARE_API_TOKEN:-}")
          SAFE_ADMIN_EMAIL=$(escape_for_sed "${ADMIN_EMAIL:-}")
          SAFE_TS_CLIENT_ID=$(escape_for_sed "${TS_OAUTH_CLIENT_ID}")
          SAFE_TS_SECRET=$(escape_for_sed "${TS_OAUTH_SECRET}")
          SAFE_TAILNET=$(escape_for_sed "${TAILSCALE_TAILNET:-}")
          
          echo "üîÑ Performing placeholder replacements in stage2 script..."
          
          # Perform replacements with error checking
          sed -i "s/SERVICE_NAME_PLACEHOLDER/${SAFE_SERVICE_NAME}/g" stage2-post-reboot.sh
          sed -i "s/CLOUDFLARE_EMAIL_PLACEHOLDER/${SAFE_CLOUDFLARE_EMAIL}/g" stage2-post-reboot.sh
          sed -i "s/CLOUDFLARE_API_TOKEN_PLACEHOLDER/${SAFE_CLOUDFLARE_TOKEN}/g" stage2-post-reboot.sh
          sed -i "s/ADMIN_EMAIL_PLACEHOLDER/${SAFE_ADMIN_EMAIL}/g" stage2-post-reboot.sh
          sed -i "s/TS_OAUTH_CLIENT_ID_PLACEHOLDER/${SAFE_TS_CLIENT_ID}/g" stage2-post-reboot.sh
          sed -i "s/TS_OAUTH_SECRET_PLACEHOLDER/${SAFE_TS_SECRET}/g" stage2-post-reboot.sh
          sed -i "s/TAILSCALE_TAILNET_PLACEHOLDER/${SAFE_TAILNET}/g" stage2-post-reboot.sh
          sed -i "s/DOMAIN_NAME_PLACEHOLDER/${{ env.FULL_DOMAIN }}/g" stage2-post-reboot.sh
          
          # Create environment file as backup method for credentials
          echo "üîß Creating environment file as backup credential source..."
          echo "#!/bin/bash" > stage2-env.sh
          echo "# Tailscale OAuth credentials for stage2 script" >> stage2-env.sh
          echo "export TS_OAUTH_CLIENT_ID_ENV=\"${TS_OAUTH_CLIENT_ID}\"" >> stage2-env.sh
          echo "export TS_OAUTH_SECRET_ENV=\"${TS_OAUTH_SECRET}\"" >> stage2-env.sh
          echo "export TAILSCALE_TAILNET_ENV=\"${TAILSCALE_TAILNET:-}\"" >> stage2-env.sh
          echo "export SERVICE_NAME_ENV=\"${{ env.SERVICE_NAME }}\"" >> stage2-env.sh
          echo "export CLOUDFLARE_EMAIL_ENV=\"${CLOUDFLARE_EMAIL:-}\"" >> stage2-env.sh
          echo "export CLOUDFLARE_API_TOKEN_ENV=\"${CLOUDFLARE_API_TOKEN:-}\"" >> stage2-env.sh
          echo "export ADMIN_EMAIL_ENV=\"${ADMIN_EMAIL:-}\"" >> stage2-env.sh
          echo "export DOMAIN_NAME_ENV=\"${{ env.FULL_DOMAIN }}\"" >> stage2-env.sh
          chmod +x stage2-env.sh
          
          # Also create a direct credential replacement script for troubleshooting
          echo "#!/bin/bash" > fix-stage2-credentials.sh
          echo "# Emergency credential fix script" >> fix-stage2-credentials.sh
          echo "echo \"üîß Emergency credential fix for stage2 script...\"" >> fix-stage2-credentials.sh
          echo "" >> fix-stage2-credentials.sh
          echo "# Source environment variables" >> fix-stage2-credentials.sh
          echo "if [ -f /usr/local/bin/stage2-env.sh ]; then" >> fix-stage2-credentials.sh
          echo "  source /usr/local/bin/stage2-env.sh" >> fix-stage2-credentials.sh
          echo "  echo \"‚úÖ Loaded environment variables from file\"" >> fix-stage2-credentials.sh
          echo "else" >> fix-stage2-credentials.sh
          echo "  echo \"‚ùå Environment file not found\"" >> fix-stage2-credentials.sh
          echo "  exit 1" >> fix-stage2-credentials.sh
          echo "fi" >> fix-stage2-credentials.sh
          echo "" >> fix-stage2-credentials.sh
          echo "# Patch the stage2 script with correct credentials" >> fix-stage2-credentials.sh
          echo "if [ -f /usr/local/bin/stage2-post-reboot.sh ]; then" >> fix-stage2-credentials.sh
          echo "  echo \"üîÑ Applying emergency credential patches...\"" >> fix-stage2-credentials.sh
          echo "  # Replace any remaining placeholders with environment variables" >> fix-stage2-credentials.sh
          echo "  sed -i \"s/TS_OAUTH_CLIENT_ID_PLACEHOLDER/\\\${TS_OAUTH_CLIENT_ID_ENV}/g\" /usr/local/bin/stage2-post-reboot.sh" >> fix-stage2-credentials.sh
          echo "  sed -i \"s/TS_OAUTH_SECRET_PLACEHOLDER/\\\${TS_OAUTH_SECRET_ENV}/g\" /usr/local/bin/stage2-post-reboot.sh" >> fix-stage2-credentials.sh
          echo "  sed -i \"s/TAILSCALE_TAILNET_PLACEHOLDER/\\\${TAILSCALE_TAILNET_ENV}/g\" /usr/local/bin/stage2-post-reboot.sh" >> fix-stage2-credentials.sh
          echo "  sed -i \"s/SERVICE_NAME_PLACEHOLDER/\\\${SERVICE_NAME_ENV}/g\" /usr/local/bin/stage2-post-reboot.sh" >> fix-stage2-credentials.sh
          echo "  sed -i \"s/DOMAIN_NAME_PLACEHOLDER/\\\${DOMAIN_NAME_ENV}/g\" /usr/local/bin/stage2-post-reboot.sh" >> fix-stage2-credentials.sh
          echo "  echo \"‚úÖ Emergency patches applied\"" >> fix-stage2-credentials.sh
          echo "  echo \"üîç Verification of fixes:\"" >> fix-stage2-credentials.sh
          echo "  grep -n \"TS_OAUTH_CLIENT_ID=\" /usr/local/bin/stage2-post-reboot.sh | head -1" >> fix-stage2-credentials.sh
          echo "  grep -n \"TS_OAUTH_SECRET=\" /usr/local/bin/stage2-post-reboot.sh | head -1" >> fix-stage2-credentials.sh
          echo "else" >> fix-stage2-credentials.sh
          echo "  echo \"‚ùå Stage2 script not found\"" >> fix-stage2-credentials.sh
          echo "  exit 1" >> fix-stage2-credentials.sh
          echo "fi" >> fix-stage2-credentials.sh
          chmod +x fix-stage2-credentials.sh
          
          # Verify replacements worked with enhanced debugging
          echo "üîç Verifying placeholder replacements in stage2 script..."
          if grep -q "PLACEHOLDER" stage2-post-reboot.sh; then
            echo "‚ö†Ô∏è Warning: Some placeholders were not replaced:"
            grep "PLACEHOLDER" stage2-post-reboot.sh || true
            echo ""
            echo "üîç Environment variable check:"
            echo "TS_OAUTH_CLIENT_ID length: ${#TS_OAUTH_CLIENT_ID}"
            echo "TS_OAUTH_SECRET length: ${#TS_OAUTH_SECRET}"
            echo "TAILSCALE_TAILNET: '${TAILSCALE_TAILNET}'"
            echo "SERVICE_NAME: '${{ env.SERVICE_NAME }}'"
          else
            echo "‚úÖ All placeholders replaced successfully"
            echo "üîç Verification - checking key lines in stage2 script:"
            grep -n "TS_OAUTH_CLIENT_ID=" stage2-post-reboot.sh | head -1 || echo "Client ID line not found"
            grep -n "TS_OAUTH_SECRET=" stage2-post-reboot.sh | head -1 || echo "Secret line not found"
            grep -n "SERVICE_NAME=" stage2-post-reboot.sh | head -1 || echo "Service name line not found"
          fi
          
          # Upload and execute stage 1 setup
          echo "üì§ Uploading setup scripts and environment files..."
          scp -i ~/.ssh/linode_deployment_key -o StrictHostKeyChecking=no stage1-setup.sh root@${{ steps.create-server.outputs.server_ip }}:/tmp/
          scp -i ~/.ssh/linode_deployment_key -o StrictHostKeyChecking=no stage2-post-reboot.sh root@${{ steps.create-server.outputs.server_ip }}:/usr/local/bin/
          scp -i ~/.ssh/linode_deployment_key -o StrictHostKeyChecking=no stage2-env.sh root@${{ steps.create-server.outputs.server_ip }}:/usr/local/bin/
          scp -i ~/.ssh/linode_deployment_key -o StrictHostKeyChecking=no fix-stage2-credentials.sh root@${{ steps.create-server.outputs.server_ip }}:/usr/local/bin/
          
          ssh -i ~/.ssh/linode_deployment_key -o StrictHostKeyChecking=no root@${{ steps.create-server.outputs.server_ip }} "
            chmod +x /tmp/stage1-setup.sh
            chmod +x /usr/local/bin/stage2-post-reboot.sh
            chmod +x /usr/local/bin/stage2-env.sh
            chmod +x /usr/local/bin/fix-stage2-credentials.sh
            /tmp/stage1-setup.sh
          "

      - name: üîÑ Reboot Server
        run: |
          echo "üîÑ Rebooting server for kernel updates..."
          ssh -i ~/.ssh/linode_deployment_key -o StrictHostKeyChecking=no root@${{ steps.create-server.outputs.server_ip }} "reboot" || true
          sleep 60  # Wait for reboot

      - name: üèóÔ∏è Stage 2 - Post-Reboot Setup
        id: stage2-setup
        run: |
          echo "üèóÔ∏è Stage 2: Post-reboot setup and verification..."
          
          # Wait for SSH to be available after reboot (simplified)
          echo "‚è≥ Waiting for server to come back online..."
          sleep 30  # Give server time to start rebooting
          
          # Simple SSH availability check with timeout
          MAX_SSH_ATTEMPTS=20
          SSH_ATTEMPT=1
          
          while [ $SSH_ATTEMPT -le $MAX_SSH_ATTEMPTS ]; do
            echo "SSH attempt $SSH_ATTEMPT/$MAX_SSH_ATTEMPTS..."
            
            if ssh -i ~/.ssh/linode_deployment_key -o StrictHostKeyChecking=no -o ConnectTimeout=10 root@${{ steps.create-server.outputs.server_ip }} "echo 'SSH ready'" >/dev/null 2>&1; then
              echo "‚úÖ SSH connection established"
              break
            fi
            
            if [ $SSH_ATTEMPT -eq $MAX_SSH_ATTEMPTS ]; then
              echo "‚ùå SSH connection failed after $MAX_SSH_ATTEMPTS attempts"
              exit 1
            fi
            
            sleep 15
            SSH_ATTEMPT=$((SSH_ATTEMPT + 1))
          done
          
          # Run stage2 script with enhanced error handling and monitoring
          echo "üîß Running stage2 setup with enhanced monitoring..."
          ssh -i ~/.ssh/linode_deployment_key -o StrictHostKeyChecking=no root@${{ steps.create-server.outputs.server_ip }} '
            if [ -f /usr/local/bin/stage2-post-reboot.sh ]; then
              echo "üìã Running stage2 script..."
              chmod +x /usr/local/bin/stage2-post-reboot.sh
              
              # Show first few lines to verify placeholders were replaced
              echo "üîç Verifying script content (first 15 lines):"
              head -15 /usr/local/bin/stage2-post-reboot.sh
              
              # Check for unreplaced placeholders
              if grep -q "PLACEHOLDER" /usr/local/bin/stage2-post-reboot.sh; then
                echo "‚ö†Ô∏è Warning: Found unreplaced placeholders:"
                grep "PLACEHOLDER" /usr/local/bin/stage2-post-reboot.sh || true
                echo ""
                echo "üîß Attempting emergency credential fix..."
                if [ -f /usr/local/bin/fix-stage2-credentials.sh ]; then
                  source /usr/local/bin/stage2-env.sh
                  /usr/local/bin/fix-stage2-credentials.sh
                  echo "‚úÖ Emergency fix completed, retrying script verification..."
                  echo "üîç Script content after fix (lines with OAuth):"
                  grep -n "TS_OAUTH_CLIENT_ID=" /usr/local/bin/stage2-post-reboot.sh | head -1 || echo "Client ID line not found"
                  grep -n "TS_OAUTH_SECRET=" /usr/local/bin/stage2-post-reboot.sh | head -1 || echo "Secret line not found"
                else
                  echo "‚ùå Emergency fix script not found!"
                fi
              else
                echo "‚úÖ All placeholders appear to be replaced"
              fi
              
              # Run the script with output redirection for monitoring
              echo "üöÄ Starting stage2 script execution..."
              
              # Create a log file for the stage2 execution
              /usr/local/bin/stage2-post-reboot.sh > /tmp/stage2-execution.log 2>&1 &
              STAGE2_PID=$!
              
              echo "üìã Stage2 script running with PID: $STAGE2_PID"
              
              # Monitor the script execution with timeout
              MONITOR_COUNT=0
              MAX_MONITOR_TIME=600  # 10 minutes max
              
              while kill -0 $STAGE2_PID 2>/dev/null; do
                sleep 15
                MONITOR_COUNT=$((MONITOR_COUNT + 15))
                
                echo "üìä Stage2 script still running... (${MONITOR_COUNT}s elapsed)"
                
                # Show recent progress from log
                if [ -f /tmp/stage2-execution.log ]; then
                  echo "üîç Recent progress (last 5 lines):"
                  tail -5 /tmp/stage2-execution.log 2>/dev/null || echo "No log content yet"
                fi
                
                # Safety timeout
                if [ $MONITOR_COUNT -ge $MAX_MONITOR_TIME ]; then
                  echo "‚ö†Ô∏è Stage2 script taking too long, killing process..."
                  kill $STAGE2_PID 2>/dev/null || true
                  sleep 5
                  kill -9 $STAGE2_PID 2>/dev/null || true
                  break
                fi
              done
              
              # Wait for process to fully complete
              wait $STAGE2_PID 2>/dev/null || STAGE2_EXIT_CODE=$?
              STAGE2_EXIT_CODE=${STAGE2_EXIT_CODE:-0}
              
              echo "‚úÖ Stage2 script completed with exit code: $STAGE2_EXIT_CODE"
              
              # Show full execution log for debugging
              if [ -f /tmp/stage2-execution.log ]; then
                echo "üìã Full stage2 execution log:"
                echo "================================="
                cat /tmp/stage2-execution.log
                echo "================================="
              fi
              
              # Check if Tailscale is connected after stage2
              echo "üîç Quick Tailscale status check after stage2:"
              tailscale status 2>&1 || echo "Tailscale status not available yet"
              
              if [ $STAGE2_EXIT_CODE -ne 0 ]; then
                echo "‚ùå Stage2 script failed, but continuing deployment..."
                echo "üîç Checking for specific error patterns in log..."
                if [ -f /tmp/stage2-execution.log ]; then
                  grep -i "error\|failed\|timeout" /tmp/stage2-execution.log | tail -10 || echo "No specific errors found"
                fi
              else
                echo "‚úÖ Stage2 script completed successfully"
              fi
            else
              echo "‚ö†Ô∏è Stage2 script not found at /usr/local/bin/stage2-post-reboot.sh"
              echo "üìã Contents of /usr/local/bin/:"
              ls -la /usr/local/bin/ || echo "Cannot list directory"
            fi
          '
          
          # Extended wait for Tailscale to initialize properly
          echo "‚è≥ Waiting for Tailscale to initialize and authenticate..."
          echo "üîç This may take several minutes for OAuth authentication to complete..."
          sleep 90  # Increased from 30 to 90 seconds to allow more time for auth
          
          # Enhanced Tailscale connection verification with retries
          echo "üîç Verifying Tailscale connection with enhanced retry logic..."
          
          # First check if Tailscale daemon is running
          echo "üìã Checking Tailscale daemon status..."
          ssh -i ~/.ssh/linode_deployment_key -o StrictHostKeyChecking=no root@${{ steps.create-server.outputs.server_ip }} \
            "systemctl status tailscaled --no-pager -l" || true
          
          # Extended verification with more attempts and better error handling
          TAILSCALE_ATTEMPTS=8  # Increased to 8 attempts (about 6-8 minutes total)
          TAILSCALE_ATTEMPT=1
          TAILSCALE_CONNECTED=false
          
          while [ $TAILSCALE_ATTEMPT -le $TAILSCALE_ATTEMPTS ] && [ "$TAILSCALE_CONNECTED" != "true" ]; do
            echo "üîó Tailscale attempt $TAILSCALE_ATTEMPT/$TAILSCALE_ATTEMPTS: Checking connection..."
            
            # Check if we're logged in first
            TAILSCALE_STATUS=$(ssh -i ~/.ssh/linode_deployment_key -o StrictHostKeyChecking=no root@${{ steps.create-server.outputs.server_ip }} \
              "tailscale status 2>/dev/null || echo 'STATUS_FAILED'")
            
            echo "üìã Tailscale status output:"
            echo "$TAILSCALE_STATUS"
            
            # Check if status shows we're logged in
            if echo "$TAILSCALE_STATUS" | grep -q "Logged in"; then
              echo "‚úÖ Tailscale shows logged in status"
              
              # Now try to get IP address
              TAILSCALE_IP=$(ssh -i ~/.ssh/linode_deployment_key -o StrictHostKeyChecking=no root@${{ steps.create-server.outputs.server_ip }} \
                "tailscale ip -4 2>/dev/null | head -1 | tr -d '\n\r' || echo 'no-ip'")
              
              echo "üîó Tailscale IP result: '$TAILSCALE_IP'"
              
              # Validate IP format
              if [[ "$TAILSCALE_IP" =~ ^100\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
                echo "‚úÖ Tailscale connected successfully with IP: $TAILSCALE_IP"
                echo "tailscale_ip=$TAILSCALE_IP" >> $GITHUB_OUTPUT
                
                # Get hostname for verification
                TAILSCALE_HOSTNAME=$(ssh -i ~/.ssh/linode_deployment_key -o StrictHostKeyChecking=no root@${{ steps.create-server.outputs.server_ip }} \
                  "hostname 2>/dev/null || echo 'unknown'")
                echo "üè∑Ô∏è Server hostname: $TAILSCALE_HOSTNAME"
                
                TAILSCALE_CONNECTED=true
                break
              else
                echo "‚è≥ Valid IP not yet available (got: '$TAILSCALE_IP'), waiting for IP assignment..."
              fi
              
            elif echo "$TAILSCALE_STATUS" | grep -q "Logged out"; then
              echo "‚ö†Ô∏è Tailscale shows 'Logged out' - authentication may have failed"
              
              # Try to re-run the connection process
              if [ $TAILSCALE_ATTEMPT -le 3 ]; then
                echo "üîÑ Attempting to restart Tailscale authentication..."
                ssh -i ~/.ssh/linode_deployment_key -o StrictHostKeyChecking=no root@${{ steps.create-server.outputs.server_ip }} \
                  "systemctl restart tailscaled && sleep 10 && /usr/local/bin/stage2-post-reboot.sh > /tmp/stage2-retry.log 2>&1 &" || true
                echo "‚è≥ Waiting for authentication retry to complete..."
                sleep 60
              fi
              
            else
              echo "‚è≥ Tailscale status unclear, checking logs..."
            fi
            
            # Show detailed logs for debugging
            echo "üìã Recent tailscaled logs (last 10 lines):"
            ssh -i ~/.ssh/linode_deployment_key -o StrictHostKeyChecking=no root@${{ steps.create-server.outputs.server_ip }} \
              "journalctl -u tailscaled --no-pager -n 10 --since '5 minutes ago' 2>/dev/null || echo 'Could not get logs'" || true
              
            # Show retry log if it exists
            if [ $TAILSCALE_ATTEMPT -gt 3 ]; then
              echo "üìã Stage2 retry log (if exists):"
              ssh -i ~/.ssh/linode_deployment_key -o StrictHostKeyChecking=no root@${{ steps.create-server.outputs.server_ip }} \
                "tail -20 /tmp/stage2-retry.log 2>/dev/null || echo 'No retry log found'" || true
            fi
            
            if [ $TAILSCALE_ATTEMPT -lt $TAILSCALE_ATTEMPTS ]; then
              # Progressive wait times - shorter initially, longer later
              if [ $TAILSCALE_ATTEMPT -le 2 ]; then
                WAIT_TIME=30
              elif [ $TAILSCALE_ATTEMPT -le 4 ]; then
                WAIT_TIME=45  
              else
                WAIT_TIME=60
              fi
              echo "‚è≥ Waiting $WAIT_TIME seconds before next attempt..."
              sleep $WAIT_TIME
            fi
            TAILSCALE_ATTEMPT=$((TAILSCALE_ATTEMPT + 1))
          done
          
          # Final status check and diagnostics
          if [ "$TAILSCALE_CONNECTED" != "true" ]; then
            echo "‚ö†Ô∏è Tailscale connection not fully established after $TAILSCALE_ATTEMPTS attempts"
            echo "üìã Comprehensive Tailscale diagnostics:"
            
            ssh -i ~/.ssh/linode_deployment_key -o StrictHostKeyChecking=no root@${{ steps.create-server.outputs.server_ip }} '
              echo "=== System Information ==="
              uname -a
              echo ""
              echo "=== Network Interfaces ==="
              ip addr show | grep -E "(inet|tailscale)" || true
              echo ""
              echo "=== Tailscale Service Status ==="
              systemctl status tailscaled --no-pager -l || true
              echo ""
              echo "=== Tailscale Status ==="
              tailscale status 2>&1 || echo "Status command failed"
              echo ""
              echo "=== Tailscale Version ==="
              tailscale version 2>&1 || echo "Version command failed"  
              echo ""
              echo "=== Tailscale Debug Info ==="
              tailscale debug --help 2>&1 | head -5 || true
              tailscale netcheck 2>&1 | head -10 || echo "Netcheck failed"
              echo ""
              echo "=== Recent Tailscaled Logs (last 25 lines) ==="
              journalctl -u tailscaled --no-pager -n 25 --since "10 minutes ago" 2>&1 || echo "Log retrieval failed"
              echo ""
              echo "=== Environment Variables Check ==="
              env | grep -E "(TS_|TAILSCALE)" || echo "No Tailscale env vars found"
              echo ""
              echo "=== DNS Resolution Test ==="
              nslookup api.tailscale.com 2>&1 | head -10 || echo "DNS test failed"
              echo ""
              echo "=== Stage2 Script Status ==="
              if [ -f /tmp/stage2-retry.log ]; then
                echo "--- Stage2 Retry Log (last 20 lines) ---"
                tail -20 /tmp/stage2-retry.log
              else
                echo "No retry log found"
              fi
              echo ""
              echo "=== Auth Key Validation ==="
              # Check if auth was attempted
              if journalctl -u tailscaled --since "10 minutes ago" | grep -q "auth"; then
                echo "Auth attempts found in logs"
                journalctl -u tailscaled --since "10 minutes ago" | grep "auth" | tail -5
              else
                echo "No auth attempts found in recent logs"
              fi
              echo ""
              echo "=== Network Connectivity Test ==="
              ping -c 3 8.8.8.8 2>&1 || echo "Basic connectivity test failed"
            '
            
            # Try one final manual connection attempt with more verbose output
            echo "üîÑ Final manual connection attempt..."
            ssh -i ~/.ssh/linode_deployment_key -o StrictHostKeyChecking=no root@${{ steps.create-server.outputs.server_ip }} '
              echo "üîß Manual Tailscale connection attempt..."
              
              # First, try the emergency credential fix
              if [ -f /usr/local/bin/fix-stage2-credentials.sh ]; then
                echo "üö® Running emergency credential fix first..."
                source /usr/local/bin/stage2-env.sh
                /usr/local/bin/fix-stage2-credentials.sh
              fi
              
              # Try to run the stage2 script one more time with debug output
              if [ -f /usr/local/bin/stage2-post-reboot.sh ]; then
                echo "üîç Re-running stage2 script with debug output..."
                
                # Source environment variables for the script
                source /usr/local/bin/stage2-env.sh 2>/dev/null || echo "Warning: Could not source environment file"
                
                bash -x /usr/local/bin/stage2-post-reboot.sh > /tmp/final-stage2-debug.log 2>&1 &
                STAGE2_PID=$!
                
                # Wait up to 3 minutes for completion
                for i in {1..18}; do
                  if ! kill -0 $STAGE2_PID 2>/dev/null; then
                    echo "Stage2 script completed"
                    break
                  fi
                  echo "Stage2 script still running... ($i/18)"
                  sleep 10
                done
                
                # Show results
                echo "üîç Final stage2 debug log (last 30 lines):"
                tail -30 /tmp/final-stage2-debug.log 2>/dev/null || echo "No debug log available"
                
                # Check final status
                echo "üîç Final Tailscale status after retry:"
                tailscale status 2>&1 || echo "Status still failed"
                
                # Try to get IP one more time
                FINAL_IP=$(tailscale ip -4 2>/dev/null | head -1 | tr -d "\n\r" || echo "")
                if [[ "$FINAL_IP" =~ ^100\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
                  echo "‚úÖ SUCCESS! Final IP retrieved: $FINAL_IP"
                  echo "$FINAL_IP" > /tmp/tailscale_final_ip
                else
                  echo "‚ùå Still no valid Tailscale IP: $FINAL_IP"
                  
                  # Show detailed troubleshooting info
                  echo "üîç Final troubleshooting information:"
                  echo "=== Environment Variables ==="
                  env | grep -E "(TS_|TAILSCALE)" || echo "No Tailscale env vars found"
                  echo "=== Stage2 Script OAuth Lines ==="
                  grep -n "TS_OAUTH" /usr/local/bin/stage2-post-reboot.sh | head -5 || echo "No OAuth lines found"
                  echo "=== Final Debug Log Excerpt (OAuth related) ==="
                  grep -i "oauth\|auth\|client" /tmp/final-stage2-debug.log | tail -10 || echo "No OAuth debug info found"
                fi
              fi
            '
            
            # Check if the final attempt succeeded
            FINAL_TAILSCALE_IP=$(ssh -i ~/.ssh/linode_deployment_key -o StrictHostKeyChecking=no root@${{ steps.create-server.outputs.server_ip }} \
              "cat /tmp/tailscale_final_ip 2>/dev/null || echo ''")
              
            if [[ "$FINAL_TAILSCALE_IP" =~ ^100\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
              echo "üéâ Final attempt successful! Tailscale IP: $FINAL_TAILSCALE_IP"
              echo "tailscale_ip=$FINAL_TAILSCALE_IP" >> $GITHUB_OUTPUT
            else
              # Continue without Tailscale IP (don't fail the deployment)
              echo "tailscale_ip=" >> $GITHUB_OUTPUT
              echo "‚ö†Ô∏è Continuing deployment without Tailscale IP..."
              echo "üí° Recommendation: Check Tailscale OAuth credentials and network connectivity"
            fi
          else
            echo "‚úÖ Tailscale verification completed successfully"
          fi

  # ============================================================================
  # Deploy Service Application  
  # ============================================================================
  deploy-service:
    name: üöÄ Deploy Service
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: [preflight-checks, setup-infrastructure]
    if: |
      always() && 
      needs.preflight-checks.outputs.should_deploy == 'true' &&
      needs.setup-infrastructure.result == 'success'
    
    steps:
      - name: üì• Checkout Actions Repository
        uses: actions/checkout@v4
        with:
          repository: nuniesmith/actions
          path: actions

      - name: üöÄ Deploy Service to Server
        run: |
          # Decode SSH private key for deployment
          mkdir -p ~/.ssh
          echo "${{ needs.setup-infrastructure.outputs.ssh_private_key }}" | base64 -d > ~/.ssh/deployment_key
          chmod 600 ~/.ssh/deployment_key
          
          chmod +x actions/scripts/deployment/deploy-service.sh
          actions/scripts/deployment/deploy-service.sh "${{ env.SERVICE_NAME }}" "${{ needs.setup-infrastructure.outputs.server_ip }}"

  # ============================================================================
  # Health Checks
  # ============================================================================
  health-check:
    name: üè• Health Check
    runs-on: ubuntu-latest
    needs: [preflight-checks, setup-infrastructure, deploy-service]
    if: |
      always() && 
      (needs.preflight-checks.outputs.should_health_check == 'true' || 
       (needs.preflight-checks.outputs.should_deploy == 'true' && needs.deploy-service.result == 'success'))
    
    steps:
      - name: üì• Checkout Actions Repository
        uses: actions/checkout@v4
        with:
          repository: nuniesmith/actions
          path: actions

      - name: üè• Perform Health Checks
        run: |
          # Decode SSH private key for health checks
          mkdir -p ~/.ssh
          echo "${{ needs.setup-infrastructure.outputs.ssh_private_key }}" | base64 -d > ~/.ssh/deployment_key
          chmod 600 ~/.ssh/deployment_key
          
          chmod +x actions/scripts/health/health-check.sh
          actions/scripts/health/health-check.sh "${{ env.SERVICE_NAME }}" "${{ needs.setup-infrastructure.outputs.server_ip }}" "${{ needs.setup-infrastructure.outputs.tailscale_ip }}"

  # ============================================================================
  # Summary Report
  # ============================================================================
  deployment-summary:
    name: üìã Deployment Summary
    runs-on: ubuntu-latest
    needs: [preflight-checks, setup-infrastructure, deploy-service, health-check]
    if: always()
    
    steps:
      - name: üìã Generate Deployment Report
        run: |
          echo "üìã Deployment Summary for ${{ env.SERVICE_NAME }}"
          echo "=================================================="
          echo "üéØ Action: ${{ env.ACTION_TYPE }}"
          echo "üñ•Ô∏è  Server Type: ${{ env.SERVER_TYPE }}"
          echo "üåç Region: ${{ env.TARGET_REGION }}"
          echo "üîó Domain: ${{ env.FULL_DOMAIN }}"
          echo ""
          
          # Job Status Summary
          echo "üìä Job Results:"
          echo "‚úÖ Preflight Checks: ${{ needs.preflight-checks.result }}"
          echo "üèóÔ∏è  Infrastructure: ${{ needs.setup-infrastructure.result }}"
          echo "üöÄ Service Deploy: ${{ needs.deploy-service.result }}"
          echo "üè• Health Check: ${{ needs.health-check.result }}"
          echo ""
          
          # Server Information
          if [[ "${{ needs.setup-infrastructure.result }}" == "success" ]]; then
            echo "üñ•Ô∏è  Server Details:"
            echo "   üìç Public IP: ${{ needs.setup-infrastructure.outputs.server_ip }}"
            echo "   üîó Tailscale IP: ${{ needs.setup-infrastructure.outputs.tailscale_ip }}"
            echo "   üÜî Server ID: ${{ needs.setup-infrastructure.outputs.server_id }}"
            echo ""
          fi
          
          # Overall Status
          if [[ "${{ needs.setup-infrastructure.result }}" == "success" && 
                ("${{ needs.deploy-service.result }}" == "success" || "${{ needs.deploy-service.result }}" == "skipped") ]]; then
            echo "üéâ Overall Status: SUCCESS"
            echo "‚úÖ ${{ env.SERVICE_NAME }} deployment completed successfully!"
          else
            echo "‚ùå Overall Status: FAILED"
            echo "üí• Deployment encountered errors - check job logs for details"
          fi
