name: üöÄ Streamlined Service Deployment

# Simplified workflow that leverages scripts for all heavy lifting
# Follows stage0 (GitHub runner) -> stage1 (Arch setup) -> stage2 (systemd ready) pattern

on:
  workflow_call:
    inputs:
      service_name:
        description: 'Service to deploy (fks, nginx, ats, etc.)'
        required: true
        type: string
      action_type:
        description: 'Action: deploy, destroy, health-check, restart'
        required: false
        type: string
        default: 'deploy'
      server_type:
        description: 'Linode server type'
        required: false
        type: string
        default: 'g6-nanode-1'
      target_region:
        description: 'Linode region'
        required: false
        type: string
        default: 'us-central'
      domain_suffix:
        description: 'Domain suffix'
        required: false
        type: string
        default: '7gram.xyz'
      overwrite_server:
        description: 'Destroy and recreate server'
        required: false
        type: boolean
        default: false
    
    secrets:
      LINODE_CLI_TOKEN:
        required: true
      SERVICE_ROOT_PASSWORD:
        required: true
      ACTIONS_USER_PASSWORD:
        required: true
      JORDAN_PASSWORD:
        required: true
      TS_OAUTH_CLIENT_ID:
        required: true
      TS_OAUTH_SECRET:
        required: true
      TAILSCALE_TAILNET:
        required: true
      CLOUDFLARE_API_TOKEN:
        required: true
      CLOUDFLARE_ZONE_ID:
        required: true
      ADMIN_EMAIL:
        required: true
    
    outputs:
      server_id:
        value: ${{ jobs.infrastructure.outputs.server_id }}
      server_ip:
        value: ${{ jobs.infrastructure.outputs.server_ip }}
      tailscale_ip:
        value: ${{ jobs.infrastructure.outputs.tailscale_ip }}
      deployment_status:
        value: ${{ jobs.service-deploy.outputs.status }}
      restart_status:
        value: ${{ jobs.service-restart.outputs.status }}
      destruction_status:
        value: ${{ jobs.service-destroy.outputs.status }}

env:
  SERVICE_NAME: ${{ inputs.service_name }}
  ACTION_TYPE: ${{ inputs.action_type }}
  FULL_DOMAIN: ${{ inputs.service_name }}.${{ inputs.domain_suffix }}

jobs:
  # ============================================================================
  # Stage 0: Preflight Checks & Validation  
  # ============================================================================
  stage0-preflight:
    name: ÔøΩ Stage 0 - Preflight Checks
    runs-on: ubuntu-latest
    outputs:
      should_deploy: ${{ steps.stage0.outputs.should_deploy }}
      should_destroy: ${{ steps.stage0.outputs.should_destroy }}
      should_health_check: ${{ steps.stage0.outputs.should_health_check }}
      should_overwrite_server: ${{ steps.stage0.outputs.should_overwrite_server }}
      destroy_confirmed: ${{ steps.stage0.outputs.destroy_confirmed }}
      docker_build_needed: ${{ steps.stage0.outputs.docker_build_needed }}
      secrets_validated: ${{ steps.stage0.outputs.secrets_validated }}
      stage0_complete: ${{ steps.stage0.outputs.stage0_complete }}
    
    steps:
      - name: ÔøΩ Checkout Actions Repository
        uses: actions/checkout@v4
        with:
          repository: nuniesmith/actions
          token: ${{ github.token }}

      - name: ÔøΩ Run Stage 0 - Preflight Checks
        id: stage0
        env:
          LINODE_CLI_TOKEN: ${{ secrets.LINODE_CLI_TOKEN }}
          SERVICE_ROOT_PASSWORD: ${{ secrets.SERVICE_ROOT_PASSWORD }}
          ACTIONS_USER_PASSWORD: ${{ secrets.ACTIONS_USER_PASSWORD }}
          JORDAN_PASSWORD: ${{ secrets.JORDAN_PASSWORD }}
          TS_OAUTH_CLIENT_ID: ${{ secrets.TS_OAUTH_CLIENT_ID }}
          TS_OAUTH_SECRET: ${{ secrets.TS_OAUTH_SECRET }}
          TAILSCALE_TAILNET: ${{ secrets.TAILSCALE_TAILNET }}
          CLOUDFLARE_EMAIL: ${{ secrets.CLOUDFLARE_EMAIL }}
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
          ADMIN_EMAIL: ${{ secrets.ADMIN_EMAIL }}
        run: |
          chmod +x ./scripts/stage0-preflight.sh
          ./scripts/stage0-preflight.sh \
            "${{ env.SERVICE_NAME }}" \
            "${{ env.ACTION_TYPE }}" \
            "${{ inputs.overwrite_server }}" \
            "true"
          
          # Copy outputs from stage0 script
          if [[ -f /tmp/stage0-outputs/github_output ]]; then
            cat /tmp/stage0-outputs/github_output >> $GITHUB_OUTPUT
          fi

  # ============================================================================
  # STAGE 1: Infrastructure (Arch Linux Server Creation)
  # ============================================================================
  infrastructure:
    name: üèóÔ∏è Stage 1 - Infrastructure
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: [stage0-preflight]
    if: needs.stage0-preflight.outputs.should_deploy == 'true'
    
    outputs:
      server_id: ${{ steps.linode.outputs.server_id }}
      server_ip: ${{ steps.linode.outputs.server_ip }}
      tailscale_ip: ${{ steps.stage2.outputs.tailscale_ip }}
      ssh_key: ${{ steps.linode.outputs.ssh_private_key }}
    
    steps:
      - name: üìÅ Checkout Actions
        uses: actions/checkout@v4
        with:
          repository: nuniesmith/actions
          token: ${{ github.token }}
      
      - name: üèóÔ∏è Create Server and Run Stage 1 Setup
        id: linode
        env:
          LINODE_CLI_TOKEN: ${{ secrets.LINODE_CLI_TOKEN }}
          SERVICE_ROOT_PASSWORD: ${{ secrets.SERVICE_ROOT_PASSWORD }}
          ACTIONS_USER_PASSWORD: ${{ secrets.ACTIONS_USER_PASSWORD }}
          JORDAN_PASSWORD: ${{ secrets.JORDAN_PASSWORD }}
        run: |
          # Install Linode CLI
          pip install linode-cli
          export LINODE_CLI_TOKEN="${{ secrets.LINODE_CLI_TOKEN }}"
          
          echo "üèóÔ∏è Creating Linode server for ${{ env.SERVICE_NAME }}..."
          
          # Generate SSH key for this deployment
          ssh-keygen -t rsa -b 4096 -f ~/.ssh/deployment_key -N "" -C "github-actions-${{ env.SERVICE_NAME }}"
          SSH_PUBLIC_KEY=$(cat ~/.ssh/deployment_key.pub)
          SSH_PRIVATE_KEY=$(base64 -w 0 ~/.ssh/deployment_key)
          
          # Create new server
          SERVER_LABEL="${{ env.SERVICE_NAME }}"
          echo "üÜï Creating new server: $SERVER_LABEL"
          
          RESULT=$(linode-cli linodes create \
            --type "${{ inputs.server_type }}" \
            --region "${{ inputs.target_region }}" \
            --image "linode/arch" \
            --label "$SERVER_LABEL" \
            --root_pass "${{ secrets.SERVICE_ROOT_PASSWORD }}" \
            --authorized_keys "$SSH_PUBLIC_KEY" \
            --backups_enabled=false \
            --text --no-headers)
          
          if [[ -z "$RESULT" ]] || [[ "$RESULT" == *"error"* ]]; then
            echo "‚ùå Server creation failed!"
            exit 1
          fi
          
          SERVER_ID=$(echo "$RESULT" | cut -f1)
          
          # Wait for server to be running and get IP
          echo "‚è≥ Waiting for server to be ready..."
          for i in {1..15}; do
            SERVER_INFO=$(linode-cli linodes view "$SERVER_ID" --text --no-headers)
            STATUS=$(echo "$SERVER_INFO" | cut -f6)
            if [[ "$STATUS" == "running" ]]; then
              break
            fi
            sleep 10
          done
          
          # Extract server IP
          SERVER_IP=$(echo "$SERVER_INFO" | cut -f7)
          
          echo "‚úÖ Server ready: $SERVER_IP (ID: $SERVER_ID)"
          echo "server_ip=$SERVER_IP" >> $GITHUB_OUTPUT
          echo "server_id=$SERVER_ID" >> $GITHUB_OUTPUT
          echo "ssh_private_key=$SSH_PRIVATE_KEY" >> $GITHUB_OUTPUT
      
      - name: ‚è≥ Wait for SSH Access
        run: |
          echo "‚è≥ Waiting for SSH access to ${{ steps.linode.outputs.server_ip }}..."
          
          # Test SSH connectivity
          for i in {1..15}; do
            if timeout 10 ssh -i ~/.ssh/deployment_key -v -o StrictHostKeyChecking=no -o ConnectTimeout=5 \
               root@${{ steps.linode.outputs.server_ip }} "echo 'SSH ready'"; then
              echo "‚úÖ SSH connection successful"
              break
            fi
            echo "Attempt $i/15: Waiting for SSH..."
            sleep 15
          done

      - name: üîß Run Stage 1 Setup Script
        env:
          SERVER_IP: ${{ steps.linode.outputs.server_ip }}
          ACTIONS_USER_PASSWORD: ${{ secrets.ACTIONS_USER_PASSWORD }}
          JORDAN_PASSWORD: ${{ secrets.JORDAN_PASSWORD }}
        run: |
          echo "üîß Running Stage 1 setup on server..."
          
          # Prepare stage1 script with replaced placeholders
          cp ./scripts/stage1-complete-setup.sh /tmp/stage1-setup.sh
          sed -i "s/SERVICE_NAME_PLACEHOLDER/${{ env.SERVICE_NAME }}/g" /tmp/stage1-setup.sh
          sed -i "s/ACTIONS_USER_PASSWORD_PLACEHOLDER/${{ secrets.ACTIONS_USER_PASSWORD }}/g" /tmp/stage1-setup.sh
          sed -i "s/JORDAN_PASSWORD_PLACEHOLDER/${{ secrets.JORDAN_PASSWORD }}/g" /tmp/stage1-setup.sh
          
          # Transfer and execute stage1 script
          scp -i ~/.ssh/deployment_key -o StrictHostKeyChecking=no \
            /tmp/stage1-setup.sh root@$SERVER_IP:/tmp/
          
          ssh -i ~/.ssh/deployment_key -o StrictHostKeyChecking=no root@$SERVER_IP \
            "chmod +x /tmp/stage1-setup.sh && /tmp/stage1-setup.sh"
          
          echo "‚úÖ Stage 1 setup completed"

      - name: üîÑ Reboot Server for Kernel Updates
        env:
          SERVER_IP: ${{ steps.linode.outputs.server_ip }}
        run: |
          echo "üîÑ Rebooting server for kernel updates and service initialization..."
          ssh -i ~/.ssh/deployment_key -o StrictHostKeyChecking=no root@$SERVER_IP "reboot" || true
          
          echo "‚è≥ Waiting for server to come back online..."
          sleep 45
          
          # Wait for SSH to be available again
          for i in {1..20}; do
            if ssh -i ~/.ssh/deployment_key -o StrictHostKeyChecking=no -o ConnectTimeout=10 \
               root@$SERVER_IP "echo 'SSH ready after reboot'"; then
              echo "‚úÖ Server is back online after reboot"
              break
            fi
            echo "Attempt $i/20: Waiting for server to come back online..."
            sleep 15
          done

      - name: üèóÔ∏è Run Stage 2 Post-Reboot Setup
        id: stage2
        env:
          SERVER_IP: ${{ steps.linode.outputs.server_ip }}
          TS_OAUTH_CLIENT_ID: ${{ secrets.TS_OAUTH_CLIENT_ID }}
          TS_OAUTH_SECRET: ${{ secrets.TS_OAUTH_SECRET }}
          TAILSCALE_TAILNET: ${{ secrets.TAILSCALE_TAILNET }}
          CLOUDFLARE_EMAIL: ${{ secrets.CLOUDFLARE_EMAIL }}
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
          ADMIN_EMAIL: ${{ secrets.ADMIN_EMAIL }}
        run: |
          echo "üèóÔ∏è Running Stage 2 post-reboot setup..."
          
          # Prepare stage2 script with environment variables
          cp ./scripts/stage2-post-reboot.sh /tmp/stage2-setup.sh
          
          # Replace placeholders with environment variables
          envsubst '${TS_OAUTH_CLIENT_ID} ${TS_OAUTH_SECRET} ${TAILSCALE_TAILNET} ${CLOUDFLARE_EMAIL} ${CLOUDFLARE_API_TOKEN} ${ADMIN_EMAIL}' < /tmp/stage2-setup.sh > /tmp/stage2-final.sh
          
          # Replace service-specific variables
          sed -i "s|SERVICE_NAME_PLACEHOLDER|${{ env.SERVICE_NAME }}|g" /tmp/stage2-final.sh
          sed -i "s|DOMAIN_NAME_PLACEHOLDER|${{ env.FULL_DOMAIN }}|g" /tmp/stage2-final.sh
          
          # Transfer and execute stage2 script
          scp -i ~/.ssh/deployment_key -o StrictHostKeyChecking=no \
            /tmp/stage2-final.sh root@$SERVER_IP:/tmp/stage2-post-reboot.sh
          
          ssh -i ~/.ssh/deployment_key -o StrictHostKeyChecking=no root@$SERVER_IP \
            "chmod +x /tmp/stage2-post-reboot.sh && /tmp/stage2-post-reboot.sh"
          
          # Get Tailscale IP
          TAILSCALE_IP=$(ssh -i ~/.ssh/deployment_key -o StrictHostKeyChecking=no root@$SERVER_IP \
            "tailscale ip -4 2>/dev/null || echo 'pending'")
          
          echo "tailscale_ip=$TAILSCALE_IP" >> $GITHUB_OUTPUT
          echo "‚úÖ Stage 2 setup completed"

  # ============================================================================
  # DNS Updates
  # ============================================================================
  dns-update:
    name: üåê DNS Updates
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [infrastructure]
    if: |
      needs.infrastructure.result == 'success' &&
      needs.infrastructure.outputs.tailscale_ip != '' &&
      inputs.action_type == 'deploy'
    
    steps:
      - name: üìÅ Checkout Actions
        uses: actions/checkout@v4
        with:
          repository: nuniesmith/actions
          token: ${{ github.token }}
      
      - name: üåê Update DNS Records
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
          TAILSCALE_IP: ${{ needs.infrastructure.outputs.tailscale_ip }}
        run: |
          chmod +x ./scripts/dns/cloudflare-updater.sh
          ./scripts/dns/cloudflare-updater.sh update-service \
            --service "${{ env.SERVICE_NAME }}" \
            --ip "$TAILSCALE_IP" \
            --domain "${{ inputs.domain_suffix }}" \
            --token "$CLOUDFLARE_API_TOKEN" \
            --zone-id "$CLOUDFLARE_ZONE_ID"

  # ============================================================================
  # Service Deployment
  # ============================================================================
  service-deploy:
    name: üöÄ Service Deploy
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: [infrastructure, dns-update]
    if: |
      always() &&
      needs.infrastructure.result == 'success' &&
      inputs.action_type == 'deploy'
    
    outputs:
      status: ${{ steps.deploy.outputs.status }}
    
    steps:
      - name: üìÅ Checkout Actions
        uses: actions/checkout@v4
        with:
          repository: nuniesmith/actions
          token: ${{ github.token }}
      
      - name: üöÄ Deploy Service
        id: deploy
        env:
          SERVER_IP: ${{ needs.infrastructure.outputs.server_ip }}
        run: |
          # Setup SSH key
          mkdir -p ~/.ssh
          echo "${{ needs.infrastructure.outputs.ssh_key }}" | base64 -d > ~/.ssh/deployment_key
          chmod 600 ~/.ssh/deployment_key
          
          echo "üöÄ Deploying ${{ env.SERVICE_NAME }} service..."
          
          # Clone service repository to server
          ssh -i ~/.ssh/deployment_key -o StrictHostKeyChecking=no root@$SERVER_IP "
            cd /home/${{ env.SERVICE_NAME }}_user
            
            # Remove existing repo for fresh clone
            if [[ -d '${{ env.SERVICE_NAME }}' ]]; then
              rm -rf ${{ env.SERVICE_NAME }}
            fi
            
            # Clone the service repository
            git clone https://github.com/nuniesmith/${{ env.SERVICE_NAME }}.git
            cd ${{ env.SERVICE_NAME }}
            
            # Set ownership to service user
            chown -R ${{ env.SERVICE_NAME }}_user:${{ env.SERVICE_NAME }}_user /home/${{ env.SERVICE_NAME }}_user/${{ env.SERVICE_NAME }}
            
            # Deploy using start.sh if available
            if [[ -f 'start.sh' ]]; then
              chmod +x start.sh
              su - ${{ env.SERVICE_NAME }}_user -c 'cd /home/${{ env.SERVICE_NAME }}_user/${{ env.SERVICE_NAME }} && ./start.sh'
            elif [[ -f 'docker-compose.yml' ]]; then
              docker-compose down 2>/dev/null || true
              docker-compose up -d
            else
              echo '‚ùå No deployment method found (start.sh or docker-compose.yml missing)'
              exit 1
            fi
          "
          
          echo "status=success" >> $GITHUB_OUTPUT

  # ============================================================================
  # Service Restart
  # ============================================================================  
  service-restart:
    name: üîÑ Service Restart
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [stage0-preflight, infrastructure]
    if: |
      inputs.action_type == 'restart' &&
      needs.infrastructure.result == 'success'
    
    outputs:
      status: ${{ steps.restart.outputs.status }}
    
    steps:
      - name: üìÅ Checkout Actions
        uses: actions/checkout@v4
        with:
          repository: nuniesmith/actions
          token: ${{ github.token }}
      
      - name: üîÑ Restart Service
        id: restart
        env:
          SERVER_IP: ${{ needs.infrastructure.outputs.server_ip }}
          SSH_PRIVATE_KEY: ${{ needs.infrastructure.outputs.ssh_key }}
        run: |
          # Setup SSH key
          mkdir -p ~/.ssh
          echo "$SSH_PRIVATE_KEY" | base64 -d > ~/.ssh/deployment_key
          chmod 600 ~/.ssh/deployment_key
          
          echo "üîÑ Restarting ${{ env.SERVICE_NAME }} service..."
          
          # Restart service on server
          ssh -i ~/.ssh/deployment_key -o StrictHostKeyChecking=no root@$SERVER_IP "
            cd /home/${{ env.SERVICE_NAME }}_user/${{ env.SERVICE_NAME }}
            
            # Try to restart using docker-compose
            if [[ -f 'docker-compose.yml' ]]; then
              docker-compose restart
            # Try to restart using systemd service
            elif systemctl list-units --type=service | grep -q '${{ env.SERVICE_NAME }}'; then
              systemctl restart ${{ env.SERVICE_NAME }}
            # Try to restart using start.sh
            elif [[ -f 'start.sh' ]]; then
              # Stop any running processes
              pkill -f '${{ env.SERVICE_NAME }}' || true
              sleep 5
              # Start again
              su - ${{ env.SERVICE_NAME }}_user -c 'cd /home/${{ env.SERVICE_NAME }}_user/${{ env.SERVICE_NAME }} && ./start.sh'
            else
              echo '‚ùå No restart method found'
              exit 1
            fi
            
            echo '‚úÖ Service restart completed'
          "
          
          echo "status=success" >> $GITHUB_OUTPUT

  # ============================================================================
  # Service Destruction
  # ============================================================================  
  service-destroy:
    name: üí• Service Destroy
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [stage0-preflight]
    if: |
      needs.stage0-preflight.outputs.should_destroy == 'true' &&
      inputs.action_type == 'destroy'
    
    outputs:
      status: ${{ steps.destroy.outputs.status }}
    
    steps:
      - name: üìÅ Checkout Actions
        uses: actions/checkout@v4
        with:
          repository: nuniesmith/actions
          token: ${{ github.token }}
      
      - name: üí• Destroy Service Infrastructure
        id: destroy
        env:
          LINODE_CLI_TOKEN: ${{ secrets.LINODE_CLI_TOKEN }}
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
        run: |
          # Install Linode CLI
          pip install linode-cli
          export LINODE_CLI_TOKEN="${{ secrets.LINODE_CLI_TOKEN }}"
          
          echo "üí• Destroying service infrastructure for ${{ env.SERVICE_NAME }}..."
          
          # Find and destroy server
          SERVER_LABEL="${{ env.SERVICE_NAME }}"
          SERVER_INFO=$(linode-cli linodes list --text --no-headers | grep "$SERVER_LABEL" || true)
          
          if [[ -n "$SERVER_INFO" ]]; then
            SERVER_ID=$(echo "$SERVER_INFO" | cut -f1)
            echo "üóëÔ∏è Destroying server ID: $SERVER_ID"
            linode-cli linodes delete "$SERVER_ID" || echo "‚ö†Ô∏è Server may already be deleted"
            echo "‚úÖ Server destruction initiated"
          else
            echo "‚ÑπÔ∏è No server found with label: $SERVER_LABEL"
          fi
          
          # Clean up DNS records (set to localhost to disable)
          echo "üåê Cleaning up DNS records..."
          chmod +x ./scripts/dns/cloudflare-updater.sh
          ./scripts/dns/cloudflare-updater.sh update-service \
            --service "${{ env.SERVICE_NAME }}" \
            --ip "127.0.0.1" \
            --domain "${{ inputs.domain_suffix }}" \
            --token "$CLOUDFLARE_API_TOKEN" \
            --zone-id "$CLOUDFLARE_ZONE_ID" || echo "‚ö†Ô∏è DNS cleanup may have failed"
          
          echo "status=success" >> $GITHUB_OUTPUT

  # ============================================================================
  # Health Checks
  # ============================================================================
  health-check:
    name: üè• Health Check
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [infrastructure]
    if: |
      always() &&
      needs.infrastructure.result == 'success' &&
      inputs.action_type == 'health-check'
    
    steps:
      - name: üìÅ Checkout Actions
        uses: actions/checkout@v4
        with:
          repository: nuniesmith/actions
          token: ${{ github.token }}
      
      - name: üè• Run Health Checks
        env:
          SERVER_IP: ${{ needs.infrastructure.outputs.server_ip }}
          TAILSCALE_IP: ${{ needs.infrastructure.outputs.tailscale_ip }}
          SSH_PRIVATE_KEY: ${{ needs.infrastructure.outputs.ssh_key }}
        run: |
          if [[ -n "$SERVER_IP" ]]; then
            chmod +x ./scripts/health/service-health-check.sh
            ./scripts/health/service-health-check.sh \
              "${{ env.SERVICE_NAME }}" \
              "$SERVER_IP" \
              "$TAILSCALE_IP"
          fi

  # Post-deployment health check for successful deployments
  post-deploy-health:
    name: üè• Post-Deploy Health Check
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [infrastructure, service-deploy]
    if: |
      always() &&
      inputs.action_type == 'deploy' &&
      needs.service-deploy.result == 'success'
    
    steps:
      - name: üìÅ Checkout Actions
        uses: actions/checkout@v4
        with:
          repository: nuniesmith/actions
          token: ${{ github.token }}
      
      - name: üè• Run Post-Deploy Health Checks
        env:
          SERVER_IP: ${{ needs.infrastructure.outputs.server_ip }}
          TAILSCALE_IP: ${{ needs.infrastructure.outputs.tailscale_ip }}
          SSH_PRIVATE_KEY: ${{ needs.infrastructure.outputs.ssh_key }}
        run: |
          if [[ -n "$SERVER_IP" ]]; then
            chmod +x ./scripts/health/service-health-check.sh
            ./scripts/health/service-health-check.sh \
              "${{ env.SERVICE_NAME }}" \
              "$SERVER_IP" \
              "$TAILSCALE_IP"
          fi

  # ============================================================================
  # Summary
  # ============================================================================
  summary:
    name: üìã Summary
    runs-on: ubuntu-latest
    needs: [stage0-preflight, infrastructure, service-deploy, service-restart, service-destroy, health-check, post-deploy-health]
    if: always()
    
    steps:
      - name: üìã Deployment Summary
        run: |
          echo "üìã Deployment Summary for ${{ env.SERVICE_NAME }}"
          echo "=================================================="
          echo "üéØ Action: ${{ env.ACTION_TYPE }}"
          echo "üñ•Ô∏è Server Type: ${{ inputs.server_type }}"
          echo "üåç Region: ${{ inputs.target_region }}"
          echo "üîó Domain: ${{ env.FULL_DOMAIN }}"
          echo ""
          echo "üìä Job Results:"
          echo "‚úÖ Preflight: ${{ needs.stage0-preflight.result }}"
          echo "üèóÔ∏è Infrastructure: ${{ needs.infrastructure.result }}"
          echo "üöÄ Service Deploy: ${{ needs.service-deploy.result }}"
          echo "ÔøΩ Service Restart: ${{ needs.service-restart.result }}"
          echo "ÔøΩüí• Service Destroy: ${{ needs.service-destroy.result }}"
          echo "üè• Health Check: ${{ needs.health-check.result }}"
          echo "üè• Post-Deploy Health: ${{ needs.post-deploy-health.result }}"
          
          if [[ "${{ needs.infrastructure.outputs.server_ip }}" ]]; then
            echo ""
            echo "üñ•Ô∏è Server Details:"
            echo "   üìç Public IP: ${{ needs.infrastructure.outputs.server_ip }}"
            echo "   üîó Tailscale IP: ${{ needs.infrastructure.outputs.tailscale_ip }}"
            echo "   üÜî Server ID: ${{ needs.infrastructure.outputs.server_id }}"
          fi
          
          if [[ "${{ needs.service-deploy.result }}" == "success" ]]; then
            echo ""
            echo "üéâ Overall Status: SUCCESS"
            echo "‚úÖ ${{ env.SERVICE_NAME }} deployment completed!"
          elif [[ "${{ needs.service-restart.result }}" == "success" ]]; then
            echo ""
            echo "üéâ Overall Status: SUCCESS"
            echo "üîÑ ${{ env.SERVICE_NAME }} restart completed!"
          elif [[ "${{ needs.service-destroy.result }}" == "success" ]]; then
            echo ""
            echo "üéâ Overall Status: SUCCESS"
            echo "üí• ${{ env.SERVICE_NAME }} destruction completed!"
          else
            echo ""
            echo "‚ùå Overall Status: FAILED"
            echo "üí• Check job logs for details"
          fi

