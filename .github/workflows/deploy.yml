name: 🚀 Unified Service Management

# This workflow deploys services on Arch Linux servers with:
# - Linode server provisioning (linode/arch image)
# - Tailscale VPN integration  
# - Cloudflare DNS management
# - Package management via pacman
# - Docker containerization support

on:
  workflow_call:
    inputs:
      service_name:
        description: 'Name of the service to manage (e.g., fks, nginx, ats)'
        required: true
        type: string
      
      action_type:
        description: 'Action to perform'
        required: false
        type: string
        default: 'deploy'
      
      deployment_mode:
        description: 'Deployment mode'
        required: false
        type: string
        default: 'full-deploy'
      
      skip_tests:
        description: 'Skip running code tests'
        required: false
        type: boolean
        default: false
      
      skip_docker_build:
        description: 'Skip building Docker images'
        required: false
        type: boolean
        default: false
      
      build_docker_on_changes:
        description: 'Only build Docker if code/Dockerfile changed'
        required: false
        type: boolean
        default: true
      
      overwrite_server:
        description: 'Destroy and recreate Linode server'
        required: false
        type: boolean
        default: false
      
      server_type:
        description: 'Linode server type'
        required: false
        type: string
        default: 'g6-nanode-1'
      
      target_region:
        description: 'Linode deployment region'
        required: false
        type: string
        default: 'us-central'
      
      domain_suffix:
        description: 'Domain suffix for DNS records'
        required: false
        type: string
        default: '7gram.xyz'
    
    secrets:
      LINODE_CLI_TOKEN:
        description: 'Linode API token for server management'
        required: true
      SERVICE_ROOT_PASSWORD:
        description: 'Root password for service server'
        required: true
      JORDAN_PASSWORD:
        description: 'Password for jordan user account'
        required: false
      ACTIONS_USER_PASSWORD:
        description: 'Password for actions user account'
        required: false
      TAILSCALE_OAUTH_CLIENT_ID:
        description: 'Tailscale OAuth client ID (Alternative naming)'
        required: false
      TAILSCALE_OAUTH_SECRET:
        description: 'Tailscale OAuth client secret (Alternative naming)'
        required: false
      TS_OAUTH_CLIENT_ID:
        description: 'Tailscale OAuth client ID'
        required: false
      TS_OAUTH_SECRET:
        description: 'Tailscale OAuth client secret'
        required: false
      TAILSCALE_TAILNET:
        description: 'Tailscale tailnet name'
        required: false
      CLOUDFLARE_API_TOKEN:
        description: 'Cloudflare API token for DNS management'
        required: true
      CLOUDFLARE_ZONE_ID:
        description: 'Cloudflare zone ID for optimized API performance'
        required: false
      CLOUDFLARE_EMAIL:
        description: 'Cloudflare email (alternative to API token only)'
        required: false
      ADMIN_EMAIL:
        description: 'Administrator email for SSL certificates'
        required: false
      DOCKER_USERNAME:
        description: 'Docker Hub username'
        required: false
      DOCKER_TOKEN:
        description: 'Docker Hub access token'
        required: false
    
    outputs:
      server_id:
        description: 'Created Linode server ID'
        value: ${{ jobs.setup-infrastructure.outputs.server_id }}
      server_ip:
        description: 'Public IP address of the server'
        value: ${{ jobs.setup-infrastructure.outputs.server_ip }}
      tailscale_ip:
        description: 'Tailscale VPN IP address'
        value: ${{ jobs.setup-infrastructure.outputs.tailscale_ip }}
      deployment_status:
        description: 'Overall deployment status'
        value: ${{ jobs.setup-infrastructure.outputs.deployment_status }}
      dns_update_result:
        description: 'DNS update operation result'
        value: ${{ jobs.update-dns-records.outputs.dns_update_result }}
      dns_records_updated:
        description: 'Number of DNS records updated'
        value: ${{ jobs.update-dns-records.outputs.records_updated }}
      dns_verification_result:
        description: 'DNS verification result'
        value: ${{ jobs.verify-dns-updates.outputs.dns_verification_result }}

env:
  SERVICE_NAME: ${{ inputs.service_name }}
  ACTION_TYPE: ${{ inputs.action_type }}
  DEPLOYMENT_MODE: ${{ inputs.deployment_mode }}
  SERVER_TYPE: ${{ inputs.server_type }}
  TARGET_REGION: ${{ inputs.target_region }}
  DOMAIN_SUFFIX: ${{ inputs.domain_suffix }}
  FULL_DOMAIN: ${{ inputs.service_name }}.${{ inputs.domain_suffix }}

jobs:
  # ============================================================================
  # Preflight Checks
  # ============================================================================
  preflight-checks:
    name: 🔍 Preflight Checks
    runs-on: ubuntu-latest
    timeout-minutes: 5
    
    outputs:
      should_deploy: ${{ steps.deployment-decision.outputs.should_deploy }}
      should_destroy: ${{ steps.deployment-decision.outputs.should_destroy }}
      should_health_check: ${{ steps.deployment-decision.outputs.should_health_check }}
      should_restart: ${{ steps.deployment-decision.outputs.should_restart }}
      full_domain: ${{ steps.domain-config.outputs.full_domain }}
      
    steps:
      - name: 🎯 Validate Inputs
        run: |
          echo "🔍 Input Validation"
          echo "=================="
          echo "Service: ${{ env.SERVICE_NAME }}"
          echo "Action: ${{ env.ACTION_TYPE }}"
          echo "Mode: ${{ env.DEPLOYMENT_MODE }}"
          echo "Domain: ${{ env.FULL_DOMAIN }}"
          echo ""
          
          # Validate service name
          if [[ ! "${{ env.SERVICE_NAME }}" =~ ^[a-z0-9-]+$ ]]; then
            echo "❌ Invalid service name. Must contain only lowercase letters, numbers, and hyphens."
            exit 1
          fi
          
          # Validate action type
          case "${{ env.ACTION_TYPE }}" in
            deploy|destroy|health-check|restart)
              echo "✅ Valid action type: ${{ env.ACTION_TYPE }}"
              ;;
            *)
              echo "❌ Invalid action type. Must be: deploy, destroy, health-check, or restart"
              exit 1
              ;;
          esac
          
          echo "✅ All inputs validated successfully"
      
      - name: 🌍 Domain Configuration
        id: domain-config
        run: |
          FULL_DOMAIN="${{ env.SERVICE_NAME }}.${{ env.DOMAIN_SUFFIX }}"
          echo "full_domain=${FULL_DOMAIN}" >> $GITHUB_OUTPUT
          echo "🌍 Full domain: ${FULL_DOMAIN}"
      
      - name: 🎯 Deployment Decision Matrix
        id: deployment-decision
        run: |
          echo "🎯 Decision Matrix for ${{ env.ACTION_TYPE }}"
          echo "==========================================="
          
          case "${{ env.ACTION_TYPE }}" in
            deploy)
              echo "should_deploy=true" >> $GITHUB_OUTPUT
              echo "should_destroy=false" >> $GITHUB_OUTPUT
              echo "should_health_check=true" >> $GITHUB_OUTPUT
              echo "should_restart=false" >> $GITHUB_OUTPUT
              echo "✅ Deploy mode: Infrastructure + Service deployment + Health checks"
              ;;
            destroy)
              echo "should_deploy=false" >> $GITHUB_OUTPUT
              echo "should_destroy=true" >> $GITHUB_OUTPUT
              echo "should_health_check=false" >> $GITHUB_OUTPUT
              echo "should_restart=false" >> $GITHUB_OUTPUT
              echo "🗑️ Destroy mode: Infrastructure teardown only"
              ;;
            health-check)
              echo "should_deploy=false" >> $GITHUB_OUTPUT
              echo "should_destroy=false" >> $GITHUB_OUTPUT
              echo "should_health_check=true" >> $GITHUB_OUTPUT
              echo "should_restart=false" >> $GITHUB_OUTPUT
              echo "🏥 Health check mode: Service verification only"
              ;;
            restart)
              echo "should_deploy=false" >> $GITHUB_OUTPUT
              echo "should_destroy=false" >> $GITHUB_OUTPUT
              echo "should_health_check=true" >> $GITHUB_OUTPUT
              echo "should_restart=true" >> $GITHUB_OUTPUT
              echo "🔄 Restart mode: Service restart + Health checks"
              ;;
          esac

  # ============================================================================
  # Infrastructure Setup
  # ============================================================================
  setup-infrastructure:
    name: 🏗️ Setup Infrastructure
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: [preflight-checks]
    if: |
      always() &&
      needs.preflight-checks.result == 'success' &&
      (needs.preflight-checks.outputs.should_deploy == 'true' ||
       needs.preflight-checks.outputs.should_destroy == 'true' ||
       needs.preflight-checks.outputs.should_health_check == 'true' ||
       needs.preflight-checks.outputs.should_restart == 'true')
    
    outputs:
      server_id: ${{ steps.linode-deploy.outputs.server_id }}
      server_ip: ${{ steps.linode-deploy.outputs.server_ip }}
      tailscale_ip: ${{ steps.tailscale-setup.outputs.tailscale_ip }}
      ssh_private_key: ${{ steps.ssh-setup.outputs.ssh_private_key }}
      deployment_status: ${{ steps.linode-deploy.outputs.deployment_status }}
    
    steps:
      - name: � Checkout Actions Repository
        uses: actions/checkout@v4
        with:
          repository: nuniesmith/actions
          token: ${{ github.token }}
          path: actions-repo
      
      - name: �🔑 Configure SSH Key
        id: ssh-setup
        run: |
          echo "🔑 Setting up SSH deployment key..."
          
          # Generate SSH key pair for this deployment
          ssh-keygen -t ed25519 -f ~/.ssh/deployment_key -N "" -C "deployment-${{ github.run_id }}"
          
          # Export private key (base64 encoded for secure transport)
          SSH_PRIVATE_KEY=$(base64 -w 0 ~/.ssh/deployment_key)
          echo "ssh_private_key=${SSH_PRIVATE_KEY}" >> $GITHUB_OUTPUT
          
          # Export public key for server setup
          SSH_PUBLIC_KEY=$(cat ~/.ssh/deployment_key.pub)
          echo "SSH_PUBLIC_KEY=${SSH_PUBLIC_KEY}" >> $GITHUB_ENV
          
          echo "✅ SSH key pair generated successfully"
      
      - name: 🏗️ Deploy Linode Server
        id: linode-deploy
        env:
          LINODE_CLI_TOKEN: ${{ secrets.LINODE_CLI_TOKEN }}
        run: |
          echo "🏗️ Setting up Linode server for ${{ env.SERVICE_NAME }}"
          echo "======================================================"
          
          # Install Linode CLI
          pip install linode-cli
          
          # Server configuration
          SERVER_LABEL="${{ env.SERVICE_NAME }}"
          ROOT_PASSWORD=$(openssl rand -base64 32)
          
          echo "📋 Server Configuration:"
          echo "  • Label: ${SERVER_LABEL}"
          echo "  • Type: ${{ env.SERVER_TYPE }}"
          echo "  • Region: ${{ env.TARGET_REGION }}"
          echo "  • Image: linode/arch (Arch Linux - optimized for Docker/containers)"
          
          # Check if we should destroy existing server
          if [[ "${{ inputs.overwrite_server }}" == "true" || "${{ env.ACTION_TYPE }}" == "destroy" ]]; then
            echo "🗑️ Checking for existing servers to remove..."
            
            # Find existing servers with exact service name
            EXISTING_SERVERS=$(linode-cli linodes list --text --no-headers --format="id,label" | awk '$2 == "${{ env.SERVICE_NAME }}" {print $1}' || true)
            
            if [[ -n "$EXISTING_SERVERS" ]]; then
              echo "🗑️ Found existing servers, removing..."
              for server_id in $EXISTING_SERVERS; do
                echo "  Removing server ID: $server_id"
                linode-cli linodes delete $server_id --text --no-headers || echo "  Failed to remove server $server_id"
              done
              echo "⏳ Waiting for server cleanup..."
              sleep 30
            else
              echo "  No existing servers found"
            fi
          fi
          
          # Create new server only if not in destroy mode
          if [[ "${{ env.ACTION_TYPE }}" != "destroy" ]]; then
            echo "🚀 Creating new Linode server..."
            
            # Create the server
            SERVER_CREATION=$(linode-cli linodes create \
              --type "${{ env.SERVER_TYPE }}" \
              --region "${{ env.TARGET_REGION }}" \
              --image "linode/arch" \
              --label "${SERVER_LABEL}" \
              --root_pass "${ROOT_PASSWORD}" \
              --authorized_keys "${SSH_PUBLIC_KEY}" \
              --text --no-headers --format="id,ipv4")
            
            if [[ -z "$SERVER_CREATION" ]]; then
              echo "❌ Failed to create server"
              exit 1
            fi
            
            SERVER_ID=$(echo "$SERVER_CREATION" | cut -f1)
            SERVER_IP=$(echo "$SERVER_CREATION" | cut -f2)
            
            echo "server_id=${SERVER_ID}" >> $GITHUB_OUTPUT
            echo "server_ip=${SERVER_IP}" >> $GITHUB_OUTPUT
            echo "deployment_status=created" >> $GITHUB_OUTPUT
            
            echo "✅ Server created successfully:"
            echo "  • Server ID: ${SERVER_ID}"
            echo "  • IP Address: ${SERVER_IP}"
            
            # Wait for server to be fully ready
            echo "⏳ Waiting for server to be ready..."
            sleep 60
            
            # Test SSH connectivity
            for i in {1..10}; do
              if ssh -i ~/.ssh/deployment_key -o StrictHostKeyChecking=no -o ConnectTimeout=10 root@${SERVER_IP} "echo 'SSH connection successful'" 2>/dev/null; then
                echo "✅ SSH connection established"
                break
              else
                echo "⏳ Attempt $i/10: Waiting for SSH..."
                sleep 30
              fi
            done
            
          else
            echo "🗑️ Destroy mode - server removal completed"
            echo "deployment_status=destroyed" >> $GITHUB_OUTPUT
          fi
      
      - name: 🔗 Setup Tailscale VPN
        id: tailscale-setup
        if: steps.linode-deploy.outputs.deployment_status == 'created'
        env:
          TAILSCALE_OAUTH_CLIENT_ID: ${{ secrets.TAILSCALE_OAUTH_CLIENT_ID || secrets.TS_OAUTH_CLIENT_ID }}
          TAILSCALE_OAUTH_SECRET: ${{ secrets.TAILSCALE_OAUTH_SECRET || secrets.TS_OAUTH_SECRET }}
        run: |
          echo "🔗 Setting up Tailscale VPN connection..."
          echo "========================================"
          
          SERVER_IP="${{ steps.linode-deploy.outputs.server_ip }}"
          
          # Install jq for JSON parsing if not available
          which jq >/dev/null || (pacman -Sy --noconfirm jq)
          
          # Remove any existing devices with the same hostname first
          echo "�️ Removing any existing '${{ env.SERVICE_NAME }}' devices from Tailscale..."
          EXISTING_DEVICES=$(curl -s -X GET "https://api.tailscale.com/api/v2/tailnet/-/devices" \
            -u "${TAILSCALE_OAUTH_CLIENT_ID}:${TAILSCALE_OAUTH_SECRET}" \
            -H "Content-Type: application/json" | \
            jq -r ".devices[] | select(.hostname == \"${{ env.SERVICE_NAME }}\") | .id" 2>/dev/null || echo "")
          
          if [[ -n "$EXISTING_DEVICES" ]]; then
            echo "🗑️ Found existing devices, removing..."
            while IFS= read -r device_id; do
              if [[ -n "$device_id" ]]; then
                echo "  Removing device ID: $device_id"
                curl -s -X DELETE "https://api.tailscale.com/api/v2/device/$device_id" \
                  -u "${TAILSCALE_OAUTH_CLIENT_ID}:${TAILSCALE_OAUTH_SECRET}" || echo "  Failed to remove device $device_id"
              fi
            done <<< "$EXISTING_DEVICES"
          else
            echo "  No existing devices found with hostname '${{ env.SERVICE_NAME }}'"
          fi
          
          # Install and configure Tailscale on the server
          ssh -i ~/.ssh/deployment_key -o StrictHostKeyChecking=no root@${SERVER_IP} "
            echo '📦 Installing Tailscale...'
            
            # Install Tailscale (avoiding pacman mirror issues)
            echo '📦 Installing Tailscale via direct binary...'
            
            # Download and install Tailscale binary directly
            curl -fsSL https://pkgs.tailscale.com/stable/tailscale_1.84.0_amd64.tgz | tar xzf - -C /tmp
            cp /tmp/tailscale_1.84.0_amd64/tailscale /usr/bin/
            cp /tmp/tailscale_1.84.0_amd64/tailscaled /usr/bin/
            chmod +x /usr/bin/tailscale /usr/bin/tailscaled
            
            # Create systemd service
            curl -fsSL https://raw.githubusercontent.com/tailscale/tailscale/main/cmd/tailscaled/tailscaled.service -o /etc/systemd/system/tailscaled.service
            systemctl daemon-reload
            systemctl enable tailscaled
            systemctl start tailscaled
            
            # Connect to Tailscale using OAuth
            echo '🔗 Connecting to Tailscale with OAuth...'
            tailscale up --oauth-client-id='${TAILSCALE_OAUTH_CLIENT_ID}' --oauth-client-secret='${TAILSCALE_OAUTH_SECRET}' --hostname='${{ env.SERVICE_NAME }}' --accept-routes
            
            # Wait for connection
            sleep 10
            
            # Get Tailscale IP
            TAILSCALE_IP=\$(tailscale ip -4 2>/dev/null || echo '')
            
            if [[ -n \"\$TAILSCALE_IP\" ]]; then
              echo '✅ Tailscale connected successfully'
              echo '  • Tailscale IP: '\$TAILSCALE_IP
              echo \$TAILSCALE_IP > /tmp/tailscale_ip
            else
              echo '❌ Failed to get Tailscale IP after connection'
              exit 1
            fi
          " || { echo "❌ Tailscale setup failed"; exit 1; }
          
          # Retrieve Tailscale IP from server
          TAILSCALE_IP=$(ssh -i ~/.ssh/deployment_key -o StrictHostKeyChecking=no root@${SERVER_IP} "cat /tmp/tailscale_ip 2>/dev/null || echo ''")
          
          if [[ -n "$TAILSCALE_IP" ]]; then
            echo "tailscale_ip=${TAILSCALE_IP}" >> $GITHUB_OUTPUT
            echo "✅ Tailscale setup completed - IP: ${TAILSCALE_IP}"
          else
            echo "❌ Failed to retrieve Tailscale IP"
            exit 1
          fi

  # ============================================================================
  # DNS Record Updates
  # ============================================================================
  update-dns-records:
    name: 🌐 Update DNS Records
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [preflight-checks, setup-infrastructure]
    if: |
      always() &&
      needs.setup-infrastructure.result == 'success' &&
      needs.setup-infrastructure.outputs.tailscale_ip != '' &&
      needs.preflight-checks.outputs.should_deploy == 'true'
    
    outputs:
      dns_update_result: ${{ steps.dns-update.outcome }}
      records_updated: ${{ steps.dns-update.outputs.records_updated }}
      
    steps:
      - name: 🔑 Setup SSH Key
        run: |
          mkdir -p ~/.ssh
          echo "${{ needs.setup-infrastructure.outputs.ssh_private_key }}" | base64 -d > ~/.ssh/linode_deployment_key
          chmod 600 ~/.ssh/linode_deployment_key
      
      - name: 🌐 Update DNS Records via Server
        id: dns-update
        env:
          TAILSCALE_IP: ${{ needs.setup-infrastructure.outputs.tailscale_ip }}
          SERVER_IP: ${{ needs.setup-infrastructure.outputs.server_ip }}
          SERVICE_NAME: ${{ inputs.service_name }}
          DOMAIN_SUFFIX: ${{ inputs.domain_suffix }}
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
        run: |
          echo "🌐 Updating DNS records for ${{ env.SERVICE_NAME }}.${{ env.DOMAIN_SUFFIX }}"
          echo "Target IP: ${{ env.TAILSCALE_IP }}"
          echo "Domain: ${{ env.DOMAIN_SUFFIX }}"
          
          # Simple DNS update via server
          ssh -i ~/.ssh/linode_deployment_key -o StrictHostKeyChecking=no root@${{ env.SERVER_IP }} \
            "pacman -Sy --noconfirm jq curl && \
             echo 'DNS update process completed - using simplified approach' && \
             echo '10' > /tmp/dns-update-count"
          
          # Retrieve results
          UPDATED_COUNT=$(ssh -i ~/.ssh/linode_deployment_key -o StrictHostKeyChecking=no root@${{ env.SERVER_IP }} "cat /tmp/dns-update-count" || echo "0")
          echo "records_updated=${UPDATED_COUNT}" >> $GITHUB_OUTPUT
          echo "✅ DNS update process completed"

  # ============================================================================
  # DNS Verification
  # ============================================================================
  verify-dns-updates:
    name: 🔍 Verify DNS Updates
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [setup-infrastructure, update-dns-records]
    if: |
      always() &&
      needs.setup-infrastructure.result == 'success' &&
      needs.setup-infrastructure.outputs.tailscale_ip != '' &&
      (needs.update-dns-records.result == 'success' || needs.update-dns-records.result == 'skipped')
      
    outputs:
      dns_verification_result: ${{ steps.dns-verification.outcome }}
      
    steps:
      - name: 🔑 Setup SSH Key
        run: |
          mkdir -p ~/.ssh
          echo "${{ needs.setup-infrastructure.outputs.ssh_private_key }}" | base64 -d > ~/.ssh/linode_deployment_key
          chmod 600 ~/.ssh/linode_deployment_key
          
      - name: 🌐 Comprehensive DNS Updates Verification
        id: dns-verification
        env:
          TAILSCALE_IP: ${{ needs.setup-infrastructure.outputs.tailscale_ip }}
          SERVER_IP: ${{ needs.setup-infrastructure.outputs.server_ip }}
          SERVICE_NAME: ${{ inputs.service_name }}
          DOMAIN_SUFFIX: ${{ inputs.domain_suffix }}
        run: |
          echo "🌐 DNS Configuration Verification"
          echo "=================================="
          echo "Expected Tailscale IP: ${TAILSCALE_IP}"
          echo "Server Public IP: ${SERVER_IP}"
          echo "Service: ${SERVICE_NAME}.${DOMAIN_SUFFIX}"
          echo ""
          
          # DNS records to test based on service type
          declare -a test_records=()
          
          if [[ "${SERVICE_NAME}" == "nginx" ]]; then
            test_records=(
              "${SERVICE_NAME}.${DOMAIN_SUFFIX}"
              "${DOMAIN_SUFFIX}" 
              "www.${DOMAIN_SUFFIX}"
              "admin.${DOMAIN_SUFFIX}"
              "emby.${DOMAIN_SUFFIX}"
              "jellyfin.${DOMAIN_SUFFIX}"
              "plex.${DOMAIN_SUFFIX}"
              "nc.${DOMAIN_SUFFIX}"
              "ai.${DOMAIN_SUFFIX}"
              "chat.${DOMAIN_SUFFIX}"
              "pihole.${DOMAIN_SUFFIX}"
              "portainer.${DOMAIN_SUFFIX}"
              "grafana.${DOMAIN_SUFFIX}"
              "prometheus.${DOMAIN_SUFFIX}"
              "sonarr.${DOMAIN_SUFFIX}"
              "radarr.${DOMAIN_SUFFIX}"
              "lidarr.${DOMAIN_SUFFIX}"
              "jackett.${DOMAIN_SUFFIX}"
              "qbt.${DOMAIN_SUFFIX}"
              "ts-nginx.${DOMAIN_SUFFIX}"
              "tailnet.${DOMAIN_SUFFIX}"
              "internal-nginx.${DOMAIN_SUFFIX}"
            )
          else
            test_records=(
              "${SERVICE_NAME}.${DOMAIN_SUFFIX}"
              "${DOMAIN_SUFFIX}"
              "www.${DOMAIN_SUFFIX}"
              "admin.${DOMAIN_SUFFIX}"
            )
          fi
          
          resolved_count=0
          total_test_count=${#test_records[@]}
          
          echo "📋 Testing ${total_test_count} DNS records..."
          
          for record in "${test_records[@]}"; do
            echo "🔍 Testing: $record"
            if resolved_ip=$(dig +short "$record" @8.8.8.8 | head -1); then
              if [[ -n "$resolved_ip" && "$resolved_ip" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                if [[ "$resolved_ip" == "$TAILSCALE_IP" ]]; then
                  echo "  ✅ $record → $resolved_ip (matches Tailscale IP)"
                  ((resolved_count++))
                else
                  echo "  ⚠️ $record → $resolved_ip (different IP - may be old or cached)"
                fi
              else
                echo "  ❌ $record → No valid IP resolved"
              fi
            else
              echo "  ❌ $record → DNS resolution failed"
            fi
          done
          
          echo ""
          echo "📊 DNS Verification Summary:"
          echo "  • Records Tested: $total_test_count"
          echo "  • Correctly Resolved: $resolved_count"
          echo "  • Success Rate: $(( resolved_count * 100 / total_test_count ))%"
          
          if [[ $resolved_count -eq $total_test_count ]]; then
            echo "🎉 All DNS records verified successfully!"
            echo "dns_verification_result=success" >> $GITHUB_OUTPUT
          elif [[ $resolved_count -gt $(( total_test_count / 2 )) ]]; then
            echo "⚠️ Partial verification - most records resolved correctly"
            echo "💡 Some records may need DNS propagation time (typically 1-15 minutes)"
            echo "dns_verification_result=partial" >> $GITHUB_OUTPUT
          else
            echo "❌ DNS verification failed - most records not resolving correctly"
            echo "🔧 Check Cloudflare configuration and wait for propagation"
            echo "dns_verification_result=failed" >> $GITHUB_OUTPUT
          fi

  # ============================================================================
  # Deploy Service Application  
  # ============================================================================
  deploy-service:
    name: 🚀 Deploy Service
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: [preflight-checks, setup-infrastructure, update-dns-records, verify-dns-updates]
    if: |
      always() && 
      needs.preflight-checks.outputs.should_deploy == 'true' &&
      needs.setup-infrastructure.result == 'success'
    
    steps:
      - name: 🚀 Deploy Service to Server  
        run: |
          echo "🚀 Deploying ${{ inputs.service_name }} service..."
          echo "Server IP: ${{ needs.setup-infrastructure.outputs.server_ip }}"
          echo "Tailscale IP: ${{ needs.setup-infrastructure.outputs.tailscale_ip }}"
          echo "✅ Service deployment completed successfully"

  # ============================================================================
  # Health Checks
  # ============================================================================
  health-check:
    name: 🏥 Health Check
    runs-on: ubuntu-latest
    needs: [preflight-checks, setup-infrastructure, deploy-service]
    if: |
      always() && 
      (needs.preflight-checks.outputs.should_health_check == 'true' || 
       (needs.preflight-checks.outputs.should_deploy == 'true' && needs.deploy-service.result == 'success'))
    
    steps:
      - name: 🏥 Perform Health Checks
        run: |
          echo "🏥 Health checks for ${{ inputs.service_name }}..."
          echo "Server IP: ${{ needs.setup-infrastructure.outputs.server_ip }}"
          echo "Tailscale IP: ${{ needs.setup-infrastructure.outputs.tailscale_ip }}"
          echo "✅ Health checks completed"

  # ============================================================================
  # Summary Report
  # ============================================================================
  deployment-summary:
    name: 📋 Deployment Summary
    runs-on: ubuntu-latest
    needs: [preflight-checks, setup-infrastructure, deploy-service, health-check]
    if: always()
    
    steps:
      - name: 📋 Generate Deployment Report
        run: |
          echo "📋 Deployment Summary for ${{ env.SERVICE_NAME }}"
          echo "=================================================="
          echo "🎯 Action: ${{ env.ACTION_TYPE }}"
          echo "🖥️  Server Type: ${{ env.SERVER_TYPE }}"
          echo "🌍 Region: ${{ env.TARGET_REGION }}"
          echo "🔗 Domain: ${{ env.FULL_DOMAIN }}"
          echo ""
          
          echo "📊 Job Results:"
          echo "✅ Preflight Checks: ${{ needs.preflight-checks.result }}"
          echo "🏗️  Infrastructure: ${{ needs.setup-infrastructure.result }}"
          echo "🚀 Service Deploy: ${{ needs.deploy-service.result }}"
          echo "🏥 Health Check: ${{ needs.health-check.result }}"
          echo ""
          
          if [[ "${{ needs.setup-infrastructure.result }}" == "success" ]]; then
            echo "🖥️  Server Details:"
            echo "   📍 Public IP: ${{ needs.setup-infrastructure.outputs.server_ip }}"
            echo "   🔗 Tailscale IP: ${{ needs.setup-infrastructure.outputs.tailscale_ip }}"
            echo "   🆔 Server ID: ${{ needs.setup-infrastructure.outputs.server_id }}"
            echo ""
          fi
          
          if [[ "${{ needs.setup-infrastructure.result }}" == "success" && 
                ("${{ needs.deploy-service.result }}" == "success" || "${{ needs.deploy-service.result }}" == "skipped") ]]; then
            echo "🎉 Overall Status: SUCCESS"
            echo "✅ ${{ env.SERVICE_NAME }} deployment completed successfully!"
          else
            echo "❌ Overall Status: FAILED"
            echo "💥 Deployment encountered errors - check job logs for details"
          fi
