name: üöÄ Streamlined Service Deployment

# Simplified workflow that leverages scripts for all heavy lifting
# Follows stage0 (GitHub runner) -> stage1 (Arch setup) -> stage2 (systemd ready) pattern

on:
  workflow_call:
    inputs:
      service_name:
        description: 'Service to deploy (fks, nginx, ats, etc.)'
        required: true
        type: string
      source_repository:
        description: 'Source repository name (defaults to service_name)'
        required: false
        type: string
      action_type:
        description: 'Action: deploy, destroy, health-check, restart'
        required: false
        type: string
        default: 'deploy'
      server_type:
        description: 'Linode server type'
        required: false
        type: string
        default: 'g6-nanode-1'
      target_region:
        description: 'Linode region'
        required: false
        type: string
        default: 'us-central'
      domain_suffix:
        description: 'Domain suffix'
        required: false
        type: string
        default: '7gram.xyz'
      custom_domain:
        description: 'Override full domain (e.g., api.fkstrading.xyz)'
        required: false
        type: string
      overwrite_server:
        description: 'Destroy and recreate server'
        required: false
        type: boolean
        default: false
    
    secrets:
      LINODE_CLI_TOKEN:
        required: true
      SERVICE_ROOT_PASSWORD:
        required: true
      ACTIONS_USER_PASSWORD:
        required: true
      JORDAN_PASSWORD:
        required: true
      TS_OAUTH_CLIENT_ID:
        required: true
      TS_OAUTH_SECRET:
        required: true
      TAILSCALE_TAILNET:
        required: true
      CLOUDFLARE_API_TOKEN:
        required: true
      CLOUDFLARE_ZONE_ID:
        required: true
      ADMIN_EMAIL:
        required: true
      # Enhanced Security and Configuration Secrets
      SERVICE_USER_PASSWORD:
        required: false
      SSL_STAGING:
        required: false
      AUTHENTIK_JWT_SECRET:
        required: false
      JWT_SECRET_KEY:
        required: false
      NGINX_AUTH_USER:
        required: false
      NGINX_AUTH_PASS:
        required: false
      DISCORD_WEBHOOK_URL:
        required: false
      DOCKER_TOKEN:
        required: false
      DOCKER_USERNAME:
        required: false
      FULLY_QUALIFIED_DOMAIN_NAME:
        required: false
      TOP_LEVEL_DOMAIN:
        required: false
      NETDATA_CLAIM_ROOM:
        required: false
      NETDATA_CLAIM_TOKEN:
        required: false
      # SSH Public Keys for authorized access
      DESKTOP_SSH_PUB:
        required: false
      FREDDY_SSH_PUB:
        required: false
      MACBOOK_SSH_PUB:
        required: false
      ORYX_SSH_PUB:
        required: false
      SULLIVAN_SSH_PUB:
        required: false

    outputs:
      server_id:
        value: ${{ jobs.infrastructure.outputs.server_id }}
      server_ip:
        value: ${{ jobs.infrastructure.outputs.server_ip }}
      tailscale_ip:
        value: ${{ jobs.infrastructure.outputs.tailscale_ip }}
      deployment_status:
        value: ${{ jobs.service-deploy.outputs.status }}
      restart_status:
        value: ${{ jobs.service-restart.outputs.status }}
      destruction_status:
        value: ${{ jobs.service-destroy.outputs.status }}

env:
  SERVICE_NAME: ${{ inputs.service_name }}
  SOURCE_REPOSITORY: ${{ inputs.source_repository || inputs.service_name }}
  ACTION_TYPE: ${{ inputs.action_type }}
  FULL_DOMAIN: ${{ inputs.custom_domain || format('{0}.{1}', inputs.service_name, inputs.domain_suffix) }}

jobs:
  # ============================================================================
  # Stage 0: Preflight Checks & Validation  
  # ============================================================================
  stage0-preflight:
    name: ÔøΩ Stage 0 - Preflight Checks
    runs-on: ubuntu-latest
    outputs:
      should_deploy: ${{ steps.stage0.outputs.should_deploy }}
      should_destroy: ${{ steps.stage0.outputs.should_destroy }}
      should_health_check: ${{ steps.stage0.outputs.should_health_check }}
      should_overwrite_server: ${{ steps.stage0.outputs.should_overwrite_server }}
      destroy_confirmed: ${{ steps.stage0.outputs.destroy_confirmed }}
      docker_build_needed: ${{ steps.stage0.outputs.docker_build_needed }}
      secrets_validated: ${{ steps.stage0.outputs.secrets_validated }}
      stage0_complete: ${{ steps.stage0.outputs.stage0_complete }}
    
    steps:
      - name: ÔøΩ Checkout Actions Repository
        uses: actions/checkout@v4
        with:
          repository: nuniesmith/actions
          token: ${{ github.token }}

      - name: ÔøΩ Run Stage 0 - Preflight Checks
        id: stage0
        env:
          LINODE_CLI_TOKEN: ${{ secrets.LINODE_CLI_TOKEN }}
          SERVICE_ROOT_PASSWORD: ${{ secrets.SERVICE_ROOT_PASSWORD }}
          ACTIONS_USER_PASSWORD: ${{ secrets.ACTIONS_USER_PASSWORD }}
          JORDAN_PASSWORD: ${{ secrets.JORDAN_PASSWORD }}
          TS_OAUTH_CLIENT_ID: ${{ secrets.TS_OAUTH_CLIENT_ID }}
          TS_OAUTH_SECRET: ${{ secrets.TS_OAUTH_SECRET }}
          TAILSCALE_TAILNET: ${{ secrets.TAILSCALE_TAILNET }}
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
          ADMIN_EMAIL: ${{ secrets.ADMIN_EMAIL }}
        run: |
          chmod +x ./scripts/stage0-preflight.sh
          ./scripts/stage0-preflight.sh \
            "${{ env.SERVICE_NAME }}" \
            "${{ env.ACTION_TYPE }}" \
            "${{ inputs.overwrite_server }}" \
            "true"
          
          # Copy outputs from stage0 script
          if [[ -f /tmp/stage0-outputs/github_output ]]; then
            cat /tmp/stage0-outputs/github_output >> $GITHUB_OUTPUT
          else
            # Set default outputs for stage0 if script doesn't exist or doesn't create outputs
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "should_destroy=false" >> $GITHUB_OUTPUT
            echo "should_health_check=false" >> $GITHUB_OUTPUT
            echo "should_overwrite_server=${{ inputs.overwrite_server }}" >> $GITHUB_OUTPUT
            echo "destroy_confirmed=false" >> $GITHUB_OUTPUT
            echo "docker_build_needed=false" >> $GITHUB_OUTPUT
            echo "secrets_validated=true" >> $GITHUB_OUTPUT
            echo "stage0_complete=true" >> $GITHUB_OUTPUT
          fi

  # ============================================================================
  # STAGE 1: Infrastructure (Arch Linux Server Creation)
  # ============================================================================
  infrastructure:
    name: üèóÔ∏è Stage 1 - Infrastructure
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: [stage0-preflight]
    if: needs.stage0-preflight.outputs.should_deploy == 'true'
    
    outputs:
      server_id: ${{ steps.linode.outputs.server_id }}
      server_ip: ${{ steps.linode.outputs.server_ip }}
      tailscale_ip: ${{ steps.stage2.outputs.tailscale_ip }}
      ssh_key: ${{ steps.linode.outputs.ssh_private_key }}
      debug_info: "linode_completed:${{ steps.linode.conclusion }},stage2_completed:${{ steps.stage2.conclusion }}"
    
    steps:
      - name: üîç Debug Infrastructure Job Start
        run: |
          echo "üîç DEBUG: Infrastructure job starting..."
          echo "üîç DEBUG: Stage0 outputs:"
          echo "  should_deploy: '${{ needs.stage0-preflight.outputs.should_deploy }}'"
          echo "  should_destroy: '${{ needs.stage0-preflight.outputs.should_destroy }}'"
          echo "  stage0_complete: '${{ needs.stage0-preflight.outputs.stage0_complete }}'"
          echo "üîç DEBUG: Infrastructure job condition check:"
          echo "  needs.stage0-preflight.outputs.should_deploy == 'true': ${{ needs.stage0-preflight.outputs.should_deploy == 'true' }}"
          echo "‚úÖ Infrastructure job is running!"
      
      - name: üìÅ Checkout Actions
        uses: actions/checkout@v4
        with:
          repository: nuniesmith/actions
          token: ${{ github.token }}
      
      - name: üßπ Pre-deployment Cleanup (when overwriting)
        if: inputs.overwrite_server == true
        env:
          TS_OAUTH_CLIENT_ID: ${{ secrets.TS_OAUTH_CLIENT_ID }}
          TS_OAUTH_SECRET: ${{ secrets.TS_OAUTH_SECRET }}
          TAILSCALE_TAILNET: ${{ secrets.TAILSCALE_TAILNET }}
        run: |
          echo "üßπ Cleaning up Tailscale devices for ${{ env.SERVICE_NAME }} before server overwrite..."
          
          # Clean up Tailscale devices for the service (including numbered variants)
          if [[ -n "${TS_OAUTH_CLIENT_ID:-}" && -n "${TS_OAUTH_SECRET:-}" ]]; then
            chmod +x ./scripts/cleanup/cleanup-resources.sh
            export TS_OAUTH_CLIENT_ID TS_OAUTH_SECRET TAILSCALE_TAILNET
            ./scripts/cleanup/cleanup-resources.sh "${{ env.SERVICE_NAME }}" || echo "‚ö†Ô∏è Tailscale cleanup completed with warnings"
            echo "‚úÖ Pre-deployment Tailscale cleanup completed"
          else
            echo "‚ö†Ô∏è Tailscale OAuth credentials not available - skipping Tailscale cleanup"
          fi
      
      - name: üèóÔ∏è Create Server and Run Stage 1 Setup
        id: linode
        env:
          LINODE_CLI_TOKEN: ${{ secrets.LINODE_CLI_TOKEN }}
          SERVICE_ROOT_PASSWORD: ${{ secrets.SERVICE_ROOT_PASSWORD }}
          ACTIONS_USER_PASSWORD: ${{ secrets.ACTIONS_USER_PASSWORD }}
          JORDAN_PASSWORD: ${{ secrets.JORDAN_PASSWORD }}
        run: |
          # Install Linode CLI
          pip install linode-cli
          export LINODE_CLI_TOKEN="${{ secrets.LINODE_CLI_TOKEN }}"
          
          echo "üèóÔ∏è Creating Linode server for ${{ env.SERVICE_NAME }}..."
          
          # Generate SSH key for this deployment
          ssh-keygen -t rsa -b 4096 -f ~/.ssh/deployment_key -N "" -C "github-actions-${{ env.SERVICE_NAME }}"
          SSH_PUBLIC_KEY=$(cat ~/.ssh/deployment_key.pub)
          SSH_PRIVATE_KEY=$(base64 -w 0 ~/.ssh/deployment_key)
          
          # Check for existing server and handle overwrite
          SERVER_LABEL="${{ env.SERVICE_NAME }}"
          EXISTING_SERVER=$(linode-cli linodes list --text --no-headers | grep -E "^[0-9]+\s+$SERVER_LABEL\s+" || true)
          
          if [[ -n "$EXISTING_SERVER" ]]; then
            EXISTING_SERVER_ID=$(echo "$EXISTING_SERVER" | cut -f1)
            echo "üîç Found existing server: $SERVER_LABEL (ID: $EXISTING_SERVER_ID)"
            
            if [[ "${{ inputs.overwrite_server }}" == "true" ]]; then
              echo "üí• Overwrite enabled - destroying existing server..."
              linode-cli linodes delete "$EXISTING_SERVER_ID" --text
              
              # Wait for server to be deleted
              echo "‚è≥ Waiting for server deletion..."
              for i in {1..20}; do
                if ! linode-cli linodes view "$EXISTING_SERVER_ID" --text --no-headers 2>/dev/null; then
                  echo "‚úÖ Server deleted successfully"
                  break
                fi
                sleep 10
              done
            else
              # Create unique label with timestamp
              TIMESTAMP=$(date +%s)
              SERVER_LABEL="${{ env.SERVICE_NAME }}-${TIMESTAMP}"
              echo "‚ö†Ô∏è Server exists but overwrite disabled - using unique label: $SERVER_LABEL"
            fi
          fi
          
          echo "üÜï Creating new server: $SERVER_LABEL"
          
          RESULT=$(linode-cli linodes create \
            --type "${{ inputs.server_type }}" \
            --region "${{ inputs.target_region }}" \
            --image "linode/arch" \
            --label "$SERVER_LABEL" \
            --root_pass "${{ secrets.SERVICE_ROOT_PASSWORD }}" \
            --authorized_keys "$SSH_PUBLIC_KEY" \
            --backups_enabled=false \
            --text --no-headers)
          
          if [[ -z "$RESULT" ]] || [[ "$RESULT" == *"error"* ]]; then
            echo "‚ùå Server creation failed!"
            echo "Error details: $RESULT"
            exit 1
          fi
          
          SERVER_ID=$(echo "$RESULT" | cut -f1)
          
          # Wait for server to be running and get IP
          echo "‚è≥ Waiting for server to be ready..."
          for i in {1..15}; do
            SERVER_INFO=$(linode-cli linodes view "$SERVER_ID" --text --no-headers)
            STATUS=$(echo "$SERVER_INFO" | cut -f6)
            echo "üîç Attempt $i/15: Server status is '$STATUS'"
            if [[ "$STATUS" == "running" ]]; then
              echo "‚úÖ Server is now running!"
              break
            fi
            sleep 10
          done
          
          # Extract server IP
          SERVER_IP=$(echo "$SERVER_INFO" | cut -f7)
          
          # Validate outputs before setting them
          if [[ -z "$SERVER_ID" ]]; then
            echo "‚ùå ERROR: SERVER_ID is empty!"
            echo "üîç SERVER_INFO: $SERVER_INFO"
            echo "üîç RESULT: $RESULT"
            exit 1
          fi
          
          if [[ -z "$SERVER_IP" ]]; then
            echo "‚ùå ERROR: SERVER_IP is empty!"
            echo "üîç SERVER_INFO: $SERVER_INFO"
            echo "üîç RESULT: $RESULT"
            exit 1
          fi
          
          if [[ -z "$SSH_PRIVATE_KEY" ]]; then
            echo "‚ùå ERROR: SSH_PRIVATE_KEY is empty!"
            exit 1
          fi
          
          echo "‚úÖ Server ready: $SERVER_IP (ID: $SERVER_ID)"
          echo "üîç Debug: SERVER_ID='$SERVER_ID', SERVER_IP='$SERVER_IP', SSH_KEY length=$(echo "$SSH_PRIVATE_KEY" | wc -c)"
          echo "server_ip=$SERVER_IP" >> $GITHUB_OUTPUT
          echo "server_id=$SERVER_ID" >> $GITHUB_OUTPUT
          echo "ssh_private_key=$SSH_PRIVATE_KEY" >> $GITHUB_OUTPUT
      
      - name: ‚è≥ Wait for SSH Access
        run: |
          echo "‚è≥ Waiting for SSH access to ${{ steps.linode.outputs.server_ip }}..."
          
          # Test SSH connectivity
          for i in {1..15}; do
            if timeout 10 ssh -i ~/.ssh/deployment_key -v -o StrictHostKeyChecking=no -o ConnectTimeout=5 \
               root@${{ steps.linode.outputs.server_ip }} "echo 'SSH ready'"; then
              echo "‚úÖ SSH connection successful"
              break
            fi
            echo "Attempt $i/15: Waiting for SSH..."
            sleep 15
          done

      - name: üîß Run Stage 1 Setup Script
        env:
          SERVER_IP: ${{ steps.linode.outputs.server_ip }}
          ACTIONS_USER_PASSWORD: ${{ secrets.ACTIONS_USER_PASSWORD }}
          JORDAN_PASSWORD: ${{ secrets.JORDAN_PASSWORD }}
          SERVICE_USER_PASSWORD: ${{ secrets.SERVICE_USER_PASSWORD }}
          SSL_STAGING: ${{ secrets.SSL_STAGING }}
          DESKTOP_SSH_PUB: ${{ secrets.DESKTOP_SSH_PUB }}
          FREDDY_SSH_PUB: ${{ secrets.FREDDY_SSH_PUB }}
          MACBOOK_SSH_PUB: ${{ secrets.MACBOOK_SSH_PUB }}
          ORYX_SSH_PUB: ${{ secrets.ORYX_SSH_PUB }}
          SULLIVAN_SSH_PUB: ${{ secrets.SULLIVAN_SSH_PUB }}
        run: |
          echo "üîß Running Stage 1 setup on server..."
          
          # Prepare stage1 script with replaced placeholders
          cp ./scripts/stage1-complete-setup.sh /tmp/stage1-setup.sh
          sed -i "s/SERVICE_NAME_PLACEHOLDER/${{ env.SERVICE_NAME }}/g" /tmp/stage1-setup.sh
          sed -i "s/ACTIONS_USER_PASSWORD_PLACEHOLDER/${{ secrets.ACTIONS_USER_PASSWORD }}/g" /tmp/stage1-setup.sh
          sed -i "s/JORDAN_PASSWORD_PLACEHOLDER/${{ secrets.JORDAN_PASSWORD }}/g" /tmp/stage1-setup.sh
          sed -i "s/SERVICE_USER_PASSWORD_PLACEHOLDER/${{ secrets.SERVICE_USER_PASSWORD }}/g" /tmp/stage1-setup.sh
          sed -i "s/SSL_STAGING_PLACEHOLDER/${{ secrets.SSL_STAGING }}/g" /tmp/stage1-setup.sh
          
          # Create SSH keys file for additional authorized keys
          echo "üîë Preparing additional SSH public keys..."
          cat > /tmp/additional_ssh_keys.pub << 'EOF'
          ${{ secrets.DESKTOP_SSH_PUB }}
          ${{ secrets.FREDDY_SSH_PUB }}
          ${{ secrets.MACBOOK_SSH_PUB }}
          ${{ secrets.ORYX_SSH_PUB }}
          ${{ secrets.SULLIVAN_SSH_PUB }}
          EOF
          
          # Remove empty lines from SSH keys file
          grep -v '^$' /tmp/additional_ssh_keys.pub > /tmp/ssh_keys_clean.pub || touch /tmp/ssh_keys_clean.pub
          
          # Transfer files to server
          scp -i ~/.ssh/deployment_key -o StrictHostKeyChecking=no \
            /tmp/stage1-setup.sh root@$SERVER_IP:/tmp/
          scp -i ~/.ssh/deployment_key -o StrictHostKeyChecking=no \
            /tmp/ssh_keys_clean.pub root@$SERVER_IP:/tmp/
          
          ssh -i ~/.ssh/deployment_key -o StrictHostKeyChecking=no root@$SERVER_IP \
            "chmod +x /tmp/stage1-setup.sh && /tmp/stage1-setup.sh"
          
          echo "‚úÖ Stage 1 setup completed"

      - name: üîÑ Reboot Server for Kernel Updates
        env:
          SERVER_IP: ${{ steps.linode.outputs.server_ip }}
        run: |
          echo "üîÑ Rebooting server for kernel updates and service initialization..."
          ssh -i ~/.ssh/deployment_key -o StrictHostKeyChecking=no root@$SERVER_IP "reboot" || true
          
          echo "‚è≥ Waiting for server to come back online..."
          sleep 45
          
          # Wait for SSH to be available again
          for i in {1..20}; do
            if ssh -i ~/.ssh/deployment_key -o StrictHostKeyChecking=no -o ConnectTimeout=10 \
               root@$SERVER_IP "echo 'SSH ready after reboot'"; then
              echo "‚úÖ Server is back online after reboot"
              break
            fi
            echo "Attempt $i/20: Waiting for server to come back online..."
            sleep 15
          done

      - name: üèóÔ∏è Run Stage 2 Post-Reboot Setup
        id: stage2
        env:
          SERVER_IP: ${{ steps.linode.outputs.server_ip }}
          SERVICE_NAME: ${{ env.SERVICE_NAME }}
          FULL_DOMAIN: ${{ env.FULL_DOMAIN }}
          TS_OAUTH_CLIENT_ID: ${{ secrets.TS_OAUTH_CLIENT_ID }}
          TS_OAUTH_SECRET: ${{ secrets.TS_OAUTH_SECRET }}
          TAILSCALE_TAILNET: ${{ secrets.TAILSCALE_TAILNET }}
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
          ADMIN_EMAIL: ${{ secrets.ADMIN_EMAIL }}
          NETDATA_CLAIM_ROOM: ${{ secrets.NETDATA_CLAIM_ROOM }}
          NETDATA_CLAIM_TOKEN: ${{ secrets.NETDATA_CLAIM_TOKEN }}
          FULLY_QUALIFIED_DOMAIN_NAME: ${{ secrets.FULLY_QUALIFIED_DOMAIN_NAME }}
          TOP_LEVEL_DOMAIN: ${{ secrets.TOP_LEVEL_DOMAIN }}
        run: |
          echo "üèóÔ∏è Running Stage 2 post-reboot setup..."
          
          # Prepare stage2 script with environment variables
          cp ./scripts/stage2-post-reboot.sh /tmp/stage2-setup.sh
          
          # Replace placeholders with environment variables (including service name and domain)
          envsubst '${SERVICE_NAME} ${FULL_DOMAIN} ${TS_OAUTH_CLIENT_ID} ${TS_OAUTH_SECRET} ${TAILSCALE_TAILNET} ${CLOUDFLARE_API_TOKEN} ${CLOUDFLARE_ZONE_ID} ${ADMIN_EMAIL}' < /tmp/stage2-setup.sh > /tmp/stage2-final.sh
          
          # Fallback: Replace any remaining placeholders with sed (in case envsubst misses them)
          sed -i "s|SERVICE_NAME_PLACEHOLDER|${{ env.SERVICE_NAME }}|g" /tmp/stage2-final.sh
          sed -i "s|DOMAIN_NAME_PLACEHOLDER|${{ env.FULL_DOMAIN }}|g" /tmp/stage2-final.sh
          sed -i "s|TS_OAUTH_CLIENT_ID_PLACEHOLDER|${{ secrets.TS_OAUTH_CLIENT_ID }}|g" /tmp/stage2-final.sh
          sed -i "s|TS_OAUTH_SECRET_PLACEHOLDER|${{ secrets.TS_OAUTH_SECRET }}|g" /tmp/stage2-final.sh
          sed -i "s|TAILSCALE_TAILNET_PLACEHOLDER|${{ secrets.TAILSCALE_TAILNET }}|g" /tmp/stage2-final.sh
          sed -i "s|CLOUDFLARE_API_TOKEN_PLACEHOLDER|${{ secrets.CLOUDFLARE_API_TOKEN }}|g" /tmp/stage2-final.sh
          sed -i "s|CLOUDFLARE_ZONE_ID_PLACEHOLDER|${{ secrets.CLOUDFLARE_ZONE_ID }}|g" /tmp/stage2-final.sh
          sed -i "s|ADMIN_EMAIL_PLACEHOLDER|${{ secrets.ADMIN_EMAIL }}|g" /tmp/stage2-final.sh
          # Remove CLOUDFLARE_EMAIL references - not needed with API token auth
          sed -i "s|CLOUDFLARE_EMAIL_PLACEHOLDER||g" /tmp/stage2-final.sh
          
          # Debug: Show what variables we're passing
          echo "üîç Debug: SERVICE_NAME=${{ env.SERVICE_NAME }}"
          echo "üîç Debug: FULL_DOMAIN=${{ env.FULL_DOMAIN }}"
          
          # Transfer and execute stage2 script
          scp -i ~/.ssh/deployment_key -o StrictHostKeyChecking=no \
            /tmp/stage2-final.sh root@$SERVER_IP:/tmp/stage2-post-reboot.sh
          
          # Create environment file on remote server for the script to source
          ssh -i ~/.ssh/deployment_key -o StrictHostKeyChecking=no root@$SERVER_IP "
            mkdir -p /opt
            echo \"export SERVICE_NAME_ENV='${{ env.SERVICE_NAME }}'\" > /opt/stage2-env.sh
            echo \"export FULL_DOMAIN_ENV='${{ env.FULL_DOMAIN }}'\" >> /opt/stage2-env.sh
            echo \"export TS_OAUTH_CLIENT_ID_ENV='${{ secrets.TS_OAUTH_CLIENT_ID }}'\" >> /opt/stage2-env.sh
            echo \"export TS_OAUTH_SECRET_ENV='${{ secrets.TS_OAUTH_SECRET }}'\" >> /opt/stage2-env.sh
            echo \"export TAILSCALE_TAILNET_ENV='${{ secrets.TAILSCALE_TAILNET }}'\" >> /opt/stage2-env.sh
            echo \"export CLOUDFLARE_API_TOKEN_ENV='${{ secrets.CLOUDFLARE_API_TOKEN }}'\" >> /opt/stage2-env.sh
            echo \"export CLOUDFLARE_ZONE_ID_ENV='${{ secrets.CLOUDFLARE_ZONE_ID }}'\" >> /opt/stage2-env.sh
            echo \"export ADMIN_EMAIL_ENV='${{ secrets.ADMIN_EMAIL }}'\" >> /opt/stage2-env.sh
            chmod +x /opt/stage2-env.sh
          "
          
          # Execute the script with environment loaded
          ssh -i ~/.ssh/deployment_key -o StrictHostKeyChecking=no root@$SERVER_IP \
            "chmod +x /tmp/stage2-post-reboot.sh && source /opt/stage2-env.sh && /tmp/stage2-post-reboot.sh"
          
          # Get Tailscale IP
          TAILSCALE_IP=$(ssh -i ~/.ssh/deployment_key -o StrictHostKeyChecking=no root@$SERVER_IP \
            "tailscale ip -4 2>/dev/null || echo 'pending'")
          
          echo "tailscale_ip=$TAILSCALE_IP" >> $GITHUB_OUTPUT
          echo "‚úÖ Stage 2 setup completed"

      - name: üîç Debug Infrastructure Outputs
        run: |
          echo "üîç DEBUG: Infrastructure job completion check"
          echo "  Linode outputs:"
          echo "    server_id: '${{ steps.linode.outputs.server_id }}'"
          echo "    server_ip: '${{ steps.linode.outputs.server_ip }}'"
          echo "    ssh_private_key length: $(echo '${{ steps.linode.outputs.ssh_private_key }}' | wc -c)"
          echo "  Stage2 outputs:"
          echo "    tailscale_ip: '${{ steps.stage2.outputs.tailscale_ip }}'"
          echo ""
          
          # Validate critical outputs
          if [[ -z "${{ steps.linode.outputs.server_ip }}" ]]; then
            echo "‚ùå ERROR: server_ip is empty!"
            echo "üîç Linode step may have failed or not set outputs properly"
            echo "üîç Check if Linode server creation completed successfully"
            exit 1
          fi
          
          if [[ -z "${{ steps.linode.outputs.server_id }}" ]]; then
            echo "‚ùå ERROR: server_id is empty!"
            echo "üîç Linode step may have failed or not set outputs properly"
            echo "üîç Check if Linode server creation completed successfully"
            exit 1
          fi
          
          echo "‚úÖ Infrastructure outputs validation passed"
          echo "üîç All required infrastructure outputs are present"

  # ============================================================================
  # DNS Updates
  # ============================================================================
  dns-update:
    name: üåê DNS Updates
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [infrastructure]
    if: |
      needs.infrastructure.result == 'success' &&
      inputs.action_type == 'deploy'
    
    steps:
      - name: üìÅ Checkout Actions
        uses: actions/checkout@v4
        with:
          repository: nuniesmith/actions
          token: ${{ github.token }}
      
      - name: üåê Update DNS Records
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
          TAILSCALE_IP: ${{ needs.infrastructure.outputs.tailscale_ip }}
          SERVER_IP: ${{ needs.infrastructure.outputs.server_ip }}
        run: |
          chmod +x ./scripts/dns/cloudflare-updater.sh
          
          echo "üîç Debug: Infrastructure outputs available:"
          echo "  TAILSCALE_IP='$TAILSCALE_IP'"
          echo "  SERVER_IP='$SERVER_IP'"
          
          # Use Tailscale IP if available, otherwise fall back to server IP
          IP_TO_USE="${TAILSCALE_IP:-$SERVER_IP}"
          
          if [[ -z "$IP_TO_USE" ]] || [[ "$IP_TO_USE" == "null" ]] || [[ "$IP_TO_USE" == "''" ]]; then
            echo "‚ùå No valid IP address available for DNS update"
            echo "üîç Available infrastructure outputs:"
            echo "  Server ID: ${{ needs.infrastructure.outputs.server_id }}"
            echo "  Server IP: ${{ needs.infrastructure.outputs.server_ip }}"
            echo "  Tailscale IP: ${{ needs.infrastructure.outputs.tailscale_ip }}"
            echo "‚ö†Ô∏è Skipping DNS update - service will be accessible via server IP only"
            exit 0  # Don't fail the workflow, just skip DNS update
          fi
          
          echo "üåê Updating DNS for ${{ env.SERVICE_NAME }} with IP: $IP_TO_USE"
          ./scripts/dns/cloudflare-updater.sh update-service \
            --service "${{ env.SERVICE_NAME }}" \
            --ip "$IP_TO_USE" \
            --domain "${{ inputs.domain_suffix }}" \
            --token "$CLOUDFLARE_API_TOKEN" \
            --zone-id "$CLOUDFLARE_ZONE_ID"

  # ============================================================================
  # Service Deployment
  # ============================================================================
  service-deploy:
    name: üöÄ Service Deploy
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: [infrastructure, dns-update]
    if: |
      always() &&
      needs.infrastructure.result == 'success' &&
      inputs.action_type == 'deploy'
    
    outputs:
      status: ${{ steps.deploy.outputs.status }}
    
    steps:
      - name: üìÅ Checkout Actions
        uses: actions/checkout@v4
        with:
          repository: nuniesmith/actions
          token: ${{ github.token }}
      
      - name: üîç Debug Infrastructure Outputs
        run: |
          echo "üîç DEBUG: Infrastructure job result: ${{ needs.infrastructure.result }}"
          echo "üîç DEBUG: DNS job result: ${{ needs.dns-update.result }}"
          echo "üîç DEBUG: Infrastructure outputs:"
          echo "  server_ip: '${{ needs.infrastructure.outputs.server_ip }}'"
          echo "  server_id: '${{ needs.infrastructure.outputs.server_id }}'"
          echo "  tailscale_ip: '${{ needs.infrastructure.outputs.tailscale_ip }}'"
          echo "  ssh_key: $(echo '${{ needs.infrastructure.outputs.ssh_key }}' | wc -c) characters"
          echo "üîç DEBUG: SERVER_IP env var: '${{ needs.infrastructure.outputs.server_ip }}'"
          echo "üîç DEBUG: Service details:"
          echo "  SERVICE_NAME: '${{ inputs.service_name }}'"
          echo "  SOURCE_REPOSITORY: '${{ inputs.source_repository }}'"
          echo "  FULL_DOMAIN: '${{ inputs.custom_domain }}'"
          echo ""
          
          # Additional debugging for job status
          echo "üîç DEBUG: Job dependencies status:"
          echo "  infrastructure.result: '${{ needs.infrastructure.result }}'"
          echo "  dns-update.result: '${{ needs.dns-update.result }}'"
          echo "  infrastructure.debug_info: '${{ needs.infrastructure.outputs.debug_info }}'"
          echo ""
          
          # Check if infrastructure job actually completed
          if [[ "${{ needs.infrastructure.result }}" != "success" ]]; then
            echo "‚ùå ERROR: Infrastructure job did not complete successfully!"
            echo "Infrastructure result: ${{ needs.infrastructure.result }}"
            echo "üîç This explains why outputs are empty - the infrastructure job failed"
            exit 1
          fi
          
          # Check if SERVER_IP is empty and exit with error
          if [[ -z "${{ needs.infrastructure.outputs.server_ip }}" ]] || [[ "${{ needs.infrastructure.outputs.server_ip }}" == "null" ]]; then
            echo "‚ùå ERROR: SERVER_IP is empty or null! Cannot deploy without server IP."
            echo "üîç DEBUG: Raw server_ip output: '${{ needs.infrastructure.outputs.server_ip }}'"
            echo "üîç DEBUG: This indicates the infrastructure job completed but didn't set outputs properly"
            echo "üîç DEBUG: Check the infrastructure job logs for failed steps"
            exit 1
          fi
      
      - name: üöÄ Deploy Service
        id: deploy
        env:
          SERVER_IP: ${{ needs.infrastructure.outputs.server_ip }}
          JWT_SECRET_KEY: ${{ secrets.JWT_SECRET_KEY }}
          AUTHENTIK_JWT_SECRET: ${{ secrets.AUTHENTIK_JWT_SECRET }}
          NGINX_AUTH_USER: ${{ secrets.NGINX_AUTH_USER }}
          NGINX_AUTH_PASS: ${{ secrets.NGINX_AUTH_PASS }}
          DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
          DOCKER_TOKEN: ${{ secrets.DOCKER_TOKEN }}
        run: |
          # Debug: Show all infrastructure outputs
          echo "üîç DEBUG: Infrastructure job result: ${{ needs.infrastructure.result }}"
          echo "üîç DEBUG: Infrastructure outputs:"
          echo "  server_ip: '${{ needs.infrastructure.outputs.server_ip }}'"
          echo "  server_id: '${{ needs.infrastructure.outputs.server_id }}'"
          echo "  tailscale_ip: '${{ needs.infrastructure.outputs.tailscale_ip }}'"
          echo "  ssh_key: $(echo '${{ needs.infrastructure.outputs.ssh_key }}' | wc -c) characters"
          echo "üîç DEBUG: SERVER_IP env var: '$SERVER_IP'"
          echo "üîç DEBUG: Service details:"
          echo "  SERVICE_NAME: '${{ env.SERVICE_NAME }}'"
          echo "  SOURCE_REPOSITORY: '${{ env.SOURCE_REPOSITORY }}'"
          echo "  FULL_DOMAIN: '${{ env.FULL_DOMAIN }}'"
          echo ""
          
          # Verify prerequisites
          if [[ "${{ needs.infrastructure.result }}" != "success" ]]; then
            echo "‚ùå ERROR: Infrastructure job did not complete successfully!"
            echo "Infrastructure result: ${{ needs.infrastructure.result }}"
            exit 1
          fi
          
          if [[ -z "$SERVER_IP" ]] || [[ "$SERVER_IP" == "''" ]] || [[ "$SERVER_IP" == "null" ]]; then
            echo "‚ùå ERROR: SERVER_IP is empty! Cannot deploy without server IP."
            echo "üîç DEBUG: Raw server_ip output: '${{ needs.infrastructure.outputs.server_ip }}'"
            exit 1
          fi
          
          if [[ -z "${{ needs.infrastructure.outputs.ssh_key }}" ]]; then
            echo "‚ùå ERROR: SSH key is empty! Cannot deploy without SSH access."
            exit 1
          fi
          
          # Setup SSH key
          mkdir -p ~/.ssh
          echo "${{ needs.infrastructure.outputs.ssh_key }}" | base64 -d > ~/.ssh/deployment_key
          chmod 600 ~/.ssh/deployment_key
          
          echo "üöÄ Deploying ${{ env.SERVICE_NAME }} service to server: $SERVER_IP"
          
          # Create deployment script locally to avoid command line length limits
          cat > /tmp/service-deploy.sh << 'DEPLOY_SCRIPT_EOF'
          #!/bin/bash
          set -e
          
          cd /home/${{ env.SERVICE_NAME }}_user
          
          # Determine the correct directory name (use source repository for multi-service architectures)
          if [[ "${{ env.SOURCE_REPOSITORY }}" != "${{ env.SERVICE_NAME }}" ]]; then
            REPO_DIR="${{ env.SOURCE_REPOSITORY }}"
            echo "üìÅ Multi-service deployment: Using source repository directory '$REPO_DIR'"
          else
            REPO_DIR="${{ env.SERVICE_NAME }}"
            echo "üìÅ Single-service deployment: Using service directory '$REPO_DIR'"
          fi
          
          # Remove existing repository directory if overwrite is enabled
          if [[ "${{ inputs.overwrite_server }}" == "true" ]]; then
            rm -rf "$REPO_DIR"
          fi
          
          # Clone the source repository into the correct directory
          git clone https://github.com/nuniesmith/${{ env.SOURCE_REPOSITORY }}.git "$REPO_DIR"
          cd "$REPO_DIR"
          
          # üîê SSL Certificate Setup - Step 1: Generate self-signed certificates
          echo 'üîê Setting up SSL certificates for immediate HTTPS...'
          mkdir -p /etc/ssl/selfsigned /etc/nginx
          openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
            -keyout /etc/ssl/selfsigned/key.pem \
            -out /etc/ssl/selfsigned/cert.pem \
            -subj '/CN=${{ env.FULL_DOMAIN }}/O=GitHub Actions Deployment/C=US'
          
          # Create initial SSL configuration for NGINX
          cat > /etc/nginx/ssl.conf << 'SSL_EOF'
          # Initial self-signed SSL configuration
          ssl_certificate /etc/ssl/selfsigned/cert.pem;
          ssl_certificate_key /etc/ssl/selfsigned/key.pem;
          ssl_protocols TLSv1.2 TLSv1.3;
          ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384;
          ssl_prefer_server_ciphers off;
          ssl_session_cache shared:SSL:10m;
          ssl_session_timeout 10m;
          SSL_EOF
          
          echo '‚úÖ Self-signed certificates generated for immediate HTTPS startup'
          
          # Create .env file with application secrets
          echo 'üîê Setting up application environment variables...'
          cat > .env << 'ENV_EOF'
          # Application Configuration
          JWT_SECRET_KEY=${{ secrets.JWT_SECRET_KEY }}
          AUTHENTIK_JWT_SECRET=${{ secrets.AUTHENTIK_JWT_SECRET }}
          NGINX_AUTH_USER=${{ secrets.NGINX_AUTH_USER }}
          NGINX_AUTH_PASS=${{ secrets.NGINX_AUTH_PASS }}
          
          # Service Configuration
          SERVICE_NAME=${{ env.SERVICE_NAME }}
          DOMAIN_NAME=${{ env.FULL_DOMAIN }}
          
          # Docker Hub Authentication (if needed)
          DOCKER_USERNAME=${{ secrets.DOCKER_USERNAME }}
          DOCKER_TOKEN=${{ secrets.DOCKER_TOKEN }}
          ENV_EOF
          
          # Set ownership to service user for the repository directory
          chown -R ${{ env.SERVICE_NAME }}_user:${{ env.SERVICE_NAME }}_user /home/${{ env.SERVICE_NAME }}_user/"$REPO_DIR"
          
          # Change to repository directory for deployment file detection and execution
          cd /home/${{ env.SERVICE_NAME }}_user/"$REPO_DIR"
          
          echo "üîç Checking deployment options in directory: $(pwd)"
          echo "üìÅ Available files:"
          ls -la
          
          # Deploy using start.sh if available
          if [[ -f 'start.sh' ]]; then
            echo 'üöÄ Found start.sh - using custom deployment script'
            chmod +x start.sh
            su - ${{ env.SERVICE_NAME }}_user -c "cd /home/${{ env.SERVICE_NAME }}_user/$REPO_DIR && ./start.sh"
          elif [[ -f 'docker-compose.yml' ]]; then
            echo 'üê≥ Found docker-compose.yml - using Docker Compose deployment'
            docker-compose down 2>/dev/null || true
            docker-compose up -d
          # Check for service-specific docker-compose files (e.g., docker-compose.auth.yml for fks-auth)
          elif [[ '${{ env.SERVICE_NAME }}' =~ ^fks- ]]; then
            SERVICE_TYPE="${{ env.SERVICE_NAME }}"
            SERVICE_TYPE="${SERVICE_TYPE#fks-}"  # Extract 'auth', 'api', 'web' from 'fks-auth', etc.
            echo "üîç FKS service detected: ${{ env.SERVICE_NAME }}, looking for docker-compose.$SERVICE_TYPE.yml"
            if [[ -f "docker-compose.$SERVICE_TYPE.yml" ]]; then
              echo "üê≥ Using service-specific compose file: docker-compose.$SERVICE_TYPE.yml"
              docker-compose -f "docker-compose.$SERVICE_TYPE.yml" down 2>/dev/null || true
              docker-compose -f "docker-compose.$SERVICE_TYPE.yml" up -d
            elif [[ -f 'docker-compose.yml' ]]; then
              echo "üê≥ Falling back to default docker-compose.yml"
              docker-compose down 2>/dev/null || true
              docker-compose up -d
            else
              echo "‚ùå No docker-compose file found for service: ${{ env.SERVICE_NAME }}"
              exit 1
            fi
          else
            echo "‚ùå No deployment method found for service: ${{ env.SERVICE_NAME }}"
            echo "üîç Available files in directory:"
            ls -la
            echo "üìÇ Current working directory: $(pwd)"
            exit 1
          fi
          
          # Wait for service to be fully up before proceeding to SSL setup
          echo '‚è≥ Waiting for service to start up...'
          sleep 30
          
          # Install Certbot if not already installed
          if ! command -v certbot &> /dev/null; then
            echo 'üîí Installing Certbot for Let'\''s Encrypt certificates...'
            # Update package database first
            pacman -Sy --noconfirm
            # Install certbot, cloudflare DNS plugin, and cronie for cron jobs (correct Arch Linux package names)
            if ! pacman -S --noconfirm certbot certbot-dns-cloudflare cronie; then
              echo '‚ö†Ô∏è Failed to install certbot via pacman, trying alternative approach...'
              # Fallback: Install via pip if pacman fails
              pacman -S --noconfirm python-pip cronie
              pip install certbot certbot-dns-cloudflare
            fi
            
            # Start and enable cronie service for cron jobs
            systemctl enable --now cronie || echo '‚ö†Ô∏è Failed to start cronie service'
            
            # Verify installation
            if command -v certbot &> /dev/null; then
              echo '‚úÖ Certbot installed successfully'
            else
              echo '‚ö†Ô∏è Certbot installation failed, will continue with self-signed certificates only'
            fi
            
            # Verify crontab is available
            if command -v crontab &> /dev/null; then
              echo '‚úÖ Crontab (cronie) installed successfully'
            else
              echo '‚ö†Ô∏è Crontab installation failed, automatic renewal will not be set up'
            fi
          fi
          
          # Set up Let's Encrypt certificates with Cloudflare DNS challenge
          if [[ -n '${{ env.FULL_DOMAIN }}' ]] && [[ -n '${{ secrets.CLOUDFLARE_API_TOKEN }}' ]] && command -v certbot &> /dev/null; then
            echo 'üîí Setting up Let'\''s Encrypt certificates via Cloudflare DNS...'
            
            # Create Cloudflare credentials file
            mkdir -p /etc/ssl/cloudflare
            cat > /etc/ssl/cloudflare/credentials.ini << EOF
          dns_cloudflare_api_token = ${{ secrets.CLOUDFLARE_API_TOKEN }}
          EOF
            chmod 600 /etc/ssl/cloudflare/credentials.ini
            
            # Request Let's Encrypt certificate with error handling
            if certbot certonly \
              --dns-cloudflare \
              --dns-cloudflare-credentials /etc/ssl/cloudflare/credentials.ini \
              --dns-cloudflare-propagation-seconds 60 \
              --non-interactive \
              --agree-tos \
              --email ${{ secrets.ADMIN_EMAIL }} \
              -d ${{ env.FULL_DOMAIN }} \
              --cert-name ${{ env.FULL_DOMAIN }}; then
              
              echo '‚úÖ Let'\''s Encrypt certificate obtained successfully!'
            else
              echo '‚ö†Ô∏è Let'\''s Encrypt certificate request failed, continuing with self-signed certificates'
            fi
            
            # Copy certificates to service directory for easy access
            if [[ -d "/etc/letsencrypt/live/${{ env.FULL_DOMAIN }}" ]]; then
              echo 'üìã Copying Let'\''s Encrypt certificates to service directory...'
              mkdir -p "/home/${{ env.SERVICE_NAME }}_user/$REPO_DIR/ssl"
              cp /etc/letsencrypt/live/${{ env.FULL_DOMAIN }}/fullchain.pem "/home/${{ env.SERVICE_NAME }}_user/$REPO_DIR/ssl/"
              cp /etc/letsencrypt/live/${{ env.FULL_DOMAIN }}/privkey.pem "/home/${{ env.SERVICE_NAME }}_user/$REPO_DIR/ssl/"
              chown -R ${{ env.SERVICE_NAME }}_user:${{ env.SERVICE_NAME }}_user "/home/${{ env.SERVICE_NAME }}_user/$REPO_DIR/ssl"
              
              # Set up automatic renewal
              echo '‚öôÔ∏è Setting up automatic certificate renewal...'
              if command -v crontab >/dev/null 2>&1; then
                (crontab -l 2>/dev/null; echo '0 12 * * * /usr/bin/certbot renew --quiet --deploy-hook "systemctl reload nginx"') | crontab -
                echo '‚úÖ Certificate renewal cron job set up successfully'
              else
                echo '‚ùå Warning: crontab command not found - manual renewal may be required'
                echo 'Manual renewal command: certbot renew --quiet --deploy-hook "systemctl reload nginx"'
              fi
            else
              echo '‚ö†Ô∏è Let'\''s Encrypt certificate request failed, continuing with self-signed certificates'
            fi
          else
            echo '‚ö†Ô∏è Domain, Cloudflare API token not provided, or Certbot not available - continuing with self-signed certificates'
          fi
          
          # Final SSL verification and NGINX configuration check
          echo 'üîç Verifying SSL certificate configuration...'
          
          # Check for Let's Encrypt certificates first
          if [[ -f "/home/${{ env.SERVICE_NAME }}_user/$REPO_DIR/ssl/fullchain.pem" ]]; then
            echo '‚úÖ SSL certificates found and properly configured'
            echo 'üîç Certificate type: Let'\''s Encrypt (from service directory)'
            
            # Check certificate validity
            openssl x509 -in "/home/${{ env.SERVICE_NAME }}_user/$REPO_DIR/ssl/fullchain.pem" -text -noout | head -20 || echo '‚ö†Ô∏è Certificate validation failed'
          elif [[ -f "/etc/ssl/selfsigned/cert.pem" ]]; then
            echo '‚úÖ Self-signed SSL certificates available'
            echo 'üîç Certificate type: Self-signed (fallback)'
            
            # Copy self-signed certificates to service directory for consistency
            mkdir -p "/home/${{ env.SERVICE_NAME }}_user/$REPO_DIR/ssl"
            cp /etc/ssl/selfsigned/cert.pem "/home/${{ env.SERVICE_NAME }}_user/$REPO_DIR/ssl/fullchain.pem"
            cp /etc/ssl/selfsigned/key.pem "/home/${{ env.SERVICE_NAME }}_user/$REPO_DIR/ssl/privkey.pem"
            chown -R ${{ env.SERVICE_NAME }}_user:${{ env.SERVICE_NAME }}_user "/home/${{ env.SERVICE_NAME }}_user/$REPO_DIR/ssl"
          else
            echo '‚ùå No SSL certificates found - this may cause issues with HTTPS'
          fi
            
            # Verify NGINX can start with SSL configuration
            if command -v nginx &> /dev/null; then
              nginx -t && echo '‚úÖ NGINX configuration is valid' || echo '‚ö†Ô∏è NGINX configuration has issues'
            fi
            
            # Test HTTPS connectivity (if service is listening)
            sleep 10
            curl -k -I https://${{ env.FULL_DOMAIN }} 2>/dev/null | head -5 || echo '‚ö†Ô∏è Service not yet responding on HTTPS (this is normal during startup)'
          else
            echo '‚ùå SSL certificates not found - check certificate generation logs above'
          fi
          
          echo 'üéØ SSL certificate automation complete!'
          DEPLOY_SCRIPT_EOF
          
          chmod +x /tmp/service-deploy.sh
          
          # Transfer and execute deployment script
          echo "üì§ Transferring deployment script to server..."
          scp -i ~/.ssh/deployment_key -o StrictHostKeyChecking=no /tmp/service-deploy.sh root@$SERVER_IP:/tmp/
          
          echo "üöÄ Executing deployment script on server..."
          ssh -i ~/.ssh/deployment_key -o StrictHostKeyChecking=no root@$SERVER_IP "/tmp/service-deploy.sh"
          
          echo "status=success" >> $GITHUB_OUTPUT

  # ============================================================================
  # Service Restart
  # ============================================================================  
  service-restart:
    name: üîÑ Service Restart
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [stage0-preflight, infrastructure]
    if: |
      inputs.action_type == 'restart' &&
      needs.infrastructure.result == 'success'
    
    outputs:
      status: ${{ steps.restart.outputs.status }}
    
    steps:
      - name: üìÅ Checkout Actions
        uses: actions/checkout@v4
        with:
          repository: nuniesmith/actions
          token: ${{ github.token }}
      
      - name: üîÑ Restart Service
        id: restart
        env:
          SERVER_IP: ${{ needs.infrastructure.outputs.server_ip }}
          SSH_PRIVATE_KEY: ${{ needs.infrastructure.outputs.ssh_key }}
        run: |
          # Setup SSH key
          mkdir -p ~/.ssh
          echo "$SSH_PRIVATE_KEY" | base64 -d > ~/.ssh/deployment_key
          chmod 600 ~/.ssh/deployment_key
          
          echo "üîÑ Restarting ${{ env.SERVICE_NAME }} service..."
          
          # Restart service on server
          ssh -i ~/.ssh/deployment_key -o StrictHostKeyChecking=no root@$SERVER_IP "
            # Determine the correct directory name (use source repository for multi-service architectures)
            if [[ '${{ env.SOURCE_REPOSITORY }}' != '${{ env.SERVICE_NAME }}' ]]; then
              REPO_DIR='${{ env.SOURCE_REPOSITORY }}'
              echo 'üìÅ Multi-service restart: Using source repository directory: \$REPO_DIR'
            else
              REPO_DIR='${{ env.SERVICE_NAME }}'
              echo 'üìÅ Single-service restart: Using service directory: \$REPO_DIR'
            fi
            
            cd /home/${{ env.SERVICE_NAME }}_user/\$REPO_DIR
            
            # Try to restart using docker-compose
            if [[ -f 'docker-compose.yml' ]]; then
              docker-compose restart
            # Check for service-specific docker-compose files for FKS services
            elif [[ '${{ env.SERVICE_NAME }}' =~ ^fks- ]]; then
              SERVICE_TYPE='${SERVICE_NAME#fks-}'  # Extract service type
              if [[ -f \"docker-compose.\$SERVICE_TYPE.yml\" ]]; then
                echo \"üîÑ Restarting using: docker-compose.\$SERVICE_TYPE.yml\"
                docker-compose -f \"docker-compose.\$SERVICE_TYPE.yml\" restart
              else
                echo \"‚ùå No compose file found for service: ${{ env.SERVICE_NAME }}\"
                exit 1
              fi
            # Try to restart using systemd service
            elif systemctl list-units --type=service | grep -q '${{ env.SERVICE_NAME }}'; then
              systemctl restart ${{ env.SERVICE_NAME }}
            # Try to restart using start.sh
            elif [[ -f 'start.sh' ]]; then
              # Stop any running processes
              pkill -f '${{ env.SERVICE_NAME }}' || true
              sleep 5
              # Start again
              su - ${{ env.SERVICE_NAME }}_user -c 'cd /home/${{ env.SERVICE_NAME }}_user/${{ env.SERVICE_NAME }} && ./start.sh'
            else
              echo '‚ùå No restart method found'
              exit 1
            fi
            
            echo '‚úÖ Service restart completed'
          "
          
          echo "status=success" >> $GITHUB_OUTPUT

  # ============================================================================
  # Service Destruction
  # ============================================================================  
  service-destroy:
    name: üí• Service Destroy
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [stage0-preflight]
    if: |
      needs.stage0-preflight.outputs.should_destroy == 'true' &&
      inputs.action_type == 'destroy'
    
    outputs:
      status: ${{ steps.destroy.outputs.status }}
    
    steps:
      - name: üìÅ Checkout Actions
        uses: actions/checkout@v4
        with:
          repository: nuniesmith/actions
          token: ${{ github.token }}
      
      - name: üí• Destroy Service Infrastructure
        id: destroy
        env:
          LINODE_CLI_TOKEN: ${{ secrets.LINODE_CLI_TOKEN }}
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
          TS_OAUTH_CLIENT_ID: ${{ secrets.TS_OAUTH_CLIENT_ID }}
          TS_OAUTH_SECRET: ${{ secrets.TS_OAUTH_SECRET }}
          TAILSCALE_TAILNET: ${{ secrets.TAILSCALE_TAILNET }}
        run: |
          # Install Linode CLI
          pip install linode-cli
          export LINODE_CLI_TOKEN="${{ secrets.LINODE_CLI_TOKEN }}"
          
          echo "üí• Destroying service infrastructure for ${{ env.SERVICE_NAME }}..."
          
          # Find and destroy server(s)
          SERVER_LABEL="${{ env.SERVICE_NAME }}"
          
          # Look for exact match first, then pattern match for timestamped versions
          SERVER_INFO=$(linode-cli linodes list --text --no-headers | grep -E "^[0-9]+\s+$SERVER_LABEL(\s|-[0-9]+\s)" || true)
          
          if [[ -n "$SERVER_INFO" ]]; then
            # Handle multiple servers if found
            echo "$SERVER_INFO" | while read -r server_line; do
              if [[ -n "$server_line" ]]; then
                SERVER_ID=$(echo "$server_line" | cut -f1)
                SERVER_NAME=$(echo "$server_line" | cut -f2)
                echo "üóëÔ∏è Destroying server: $SERVER_NAME (ID: $SERVER_ID)"
                linode-cli linodes delete "$SERVER_ID" || echo "‚ö†Ô∏è Server $SERVER_ID may already be deleted"
              fi
            done
            echo "‚úÖ Server destruction initiated"
          else
            echo "‚ÑπÔ∏è No server found with label pattern: $SERVER_LABEL"
          fi
          
          # Clean up Tailscale devices
          echo "üîó Cleaning up Tailscale devices..."
          if [[ -n "${TS_OAUTH_CLIENT_ID:-}" && -n "${TS_OAUTH_SECRET:-}" ]]; then
            chmod +x ./scripts/cleanup/cleanup-resources.sh
            export TS_OAUTH_CLIENT_ID TS_OAUTH_SECRET TAILSCALE_TAILNET
            ./scripts/cleanup/cleanup-resources.sh "${{ env.SERVICE_NAME }}" || echo "‚ö†Ô∏è Tailscale cleanup may have failed"
          else
            echo "‚ö†Ô∏è Tailscale OAuth credentials not available - skipping Tailscale cleanup"
          fi
          
          # Clean up DNS records (set to localhost to disable)
          echo "üåê Cleaning up DNS records..."
          chmod +x ./scripts/dns/cloudflare-updater.sh
          ./scripts/dns/cloudflare-updater.sh update-service \
            --service "${{ env.SERVICE_NAME }}" \
            --ip "127.0.0.1" \
            --domain "${{ inputs.domain_suffix }}" \
            --token "$CLOUDFLARE_API_TOKEN" \
            --zone-id "$CLOUDFLARE_ZONE_ID" || echo "‚ö†Ô∏è DNS cleanup may have failed"
          
          echo "status=success" >> $GITHUB_OUTPUT

  # ============================================================================
  # Health Checks
  # ============================================================================
  health-check:
    name: üè• Health Check
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [infrastructure]
    if: |
      always() &&
      needs.infrastructure.result == 'success' &&
      inputs.action_type == 'health-check'
    
    steps:
      - name: üìÅ Checkout Actions
        uses: actions/checkout@v4
        with:
          repository: nuniesmith/actions
          token: ${{ github.token }}
      
      - name: üè• Run Health Checks
        env:
          SERVER_IP: ${{ needs.infrastructure.outputs.server_ip }}
          TAILSCALE_IP: ${{ needs.infrastructure.outputs.tailscale_ip }}
          SSH_PRIVATE_KEY: ${{ needs.infrastructure.outputs.ssh_key }}
        run: |
          if [[ -n "$SERVER_IP" ]]; then
            chmod +x ./scripts/health/service-health-check.sh
            ./scripts/health/service-health-check.sh \
              "${{ env.SERVICE_NAME }}" \
              "$SERVER_IP" \
              "$TAILSCALE_IP"
          fi

  # Post-deployment health check for successful deployments
  post-deploy-health:
    name: üè• Post-Deploy Health Check
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [infrastructure, service-deploy]
    if: |
      always() &&
      inputs.action_type == 'deploy' &&
      needs.service-deploy.result == 'success'
    
    steps:
      - name: üìÅ Checkout Actions
        uses: actions/checkout@v4
        with:
          repository: nuniesmith/actions
          token: ${{ github.token }}
      
      - name: üè• Run Post-Deploy Health Checks
        env:
          SERVER_IP: ${{ needs.infrastructure.outputs.server_ip }}
          TAILSCALE_IP: ${{ needs.infrastructure.outputs.tailscale_ip }}
          SSH_PRIVATE_KEY: ${{ needs.infrastructure.outputs.ssh_key }}
        run: |
          if [[ -n "$SERVER_IP" ]]; then
            chmod +x ./scripts/health/service-health-check.sh
            ./scripts/health/service-health-check.sh \
              "${{ env.SERVICE_NAME }}" \
              "$SERVER_IP" \
              "$TAILSCALE_IP"
          fi

  # ============================================================================
  # Summary
  # ============================================================================
  summary:
    name: üìã Summary
    runs-on: ubuntu-latest
    needs: [stage0-preflight, infrastructure, service-deploy, service-restart, service-destroy, health-check, post-deploy-health]
    if: always()
    
    steps:
      - name: üìã Deployment Summary
        run: |
          echo "üìã Deployment Summary for ${{ env.SERVICE_NAME }}"
          echo "=================================================="
          echo "üéØ Action: ${{ env.ACTION_TYPE }}"
          echo "üñ•Ô∏è Server Type: ${{ inputs.server_type }}"
          echo "üåç Region: ${{ inputs.target_region }}"
          echo "üîó Domain: ${{ env.FULL_DOMAIN }}"
          echo ""
          echo "üìä Job Results:"
          echo "‚úÖ Preflight: ${{ needs.stage0-preflight.result }}"
          echo "üèóÔ∏è Infrastructure: ${{ needs.infrastructure.result }}"
          echo "üöÄ Service Deploy: ${{ needs.service-deploy.result }}"
          echo "ÔøΩ Service Restart: ${{ needs.service-restart.result }}"
          echo "ÔøΩüí• Service Destroy: ${{ needs.service-destroy.result }}"
          echo "üè• Health Check: ${{ needs.health-check.result }}"
          echo "üè• Post-Deploy Health: ${{ needs.post-deploy-health.result }}"
          
          if [[ "${{ needs.infrastructure.outputs.server_ip }}" ]]; then
            echo ""
            echo "üñ•Ô∏è Server Details:"
            echo "   üìç Public IP: ${{ needs.infrastructure.outputs.server_ip }}"
            echo "   üîó Tailscale IP: ${{ needs.infrastructure.outputs.tailscale_ip }}"
            echo "   üÜî Server ID: ${{ needs.infrastructure.outputs.server_id }}"
          fi
          
          if [[ "${{ needs.service-deploy.result }}" == "success" ]]; then
            echo ""
            echo "üéâ Overall Status: SUCCESS"
            echo "‚úÖ ${{ env.SERVICE_NAME }} deployment completed!"
          elif [[ "${{ needs.service-restart.result }}" == "success" ]]; then
            echo ""
            echo "üéâ Overall Status: SUCCESS"
            echo "üîÑ ${{ env.SERVICE_NAME }} restart completed!"
          elif [[ "${{ needs.service-destroy.result }}" == "success" ]]; then
            echo ""
            echo "üéâ Overall Status: SUCCESS"
            echo "üí• ${{ env.SERVICE_NAME }} destruction completed!"
          else
            echo ""
            echo "‚ùå Overall Status: FAILED"
            echo "üí• Check job logs for details"
          fi
      
      - name: üì¢ Send Discord Notification
        if: always()
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
          DEPLOYMENT_STATUS: ${{ (needs.service-deploy.result == 'success' || needs.service-restart.result == 'success' || needs.service-destroy.result == 'success') && 'SUCCESS' || 'FAILED' }}
          SERVICE_NAME: ${{ env.SERVICE_NAME }}
          ACTION_TYPE: ${{ inputs.action_type || 'deploy' }}
        run: |
          echo "üì¢ Preparing Discord notification..."
          
          # Validate webhook URL before proceeding
          if [[ -z "$DISCORD_WEBHOOK_URL" ]]; then
            echo "‚ö†Ô∏è Discord webhook URL is empty - skipping notification"
            exit 0
          fi
          
          if [[ ! "$DISCORD_WEBHOOK_URL" =~ ^https://discord(app)?\.com/api/webhooks/ ]]; then
            echo "‚ö†Ô∏è Invalid Discord webhook URL format - skipping notification"
            exit 0
          fi
          
          echo "üì¢ Sending Discord notification..."
          
          # Determine color based on status
          if [[ "$DEPLOYMENT_STATUS" == "SUCCESS" ]]; then
            COLOR="3066993"  # Green
            EMOJI="‚úÖ"
          else
            COLOR="15158332"  # Red
            EMOJI="‚ùå"
          fi
          
          # Create Discord webhook payload
          cat > /tmp/discord_payload.json << EOF
          {
            "embeds": [
              {
                "title": "$EMOJI $SERVICE_NAME Deployment $DEPLOYMENT_STATUS",
                "description": "**Action:** $ACTION_TYPE\\n**Service:** $SERVICE_NAME\\n**Status:** $DEPLOYMENT_STATUS",
                "color": $COLOR,
                "fields": [
                  {
                    "name": "Server Details",
                    "value": "**IP:** ${{ needs.infrastructure.outputs.server_ip || 'N/A' }}\\n**Tailscale IP:** ${{ needs.infrastructure.outputs.tailscale_ip || 'N/A' }}\\n**Server ID:** ${{ needs.infrastructure.outputs.server_id || 'N/A' }}",
                    "inline": true
                  },
                  {
                    "name": "Job Results",
                    "value": "**Infrastructure:** ${{ needs.infrastructure.result }}\\n**Service Deploy:** ${{ needs.service-deploy.result }}\\n**DNS:** OK",
                    "inline": true
                  }
                ],
                "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
              }
            ]
          }
          EOF
          
          # Send notification to Discord with proper error handling
          if curl -f -H "Content-Type: application/json" \
               -d @/tmp/discord_payload.json \
               "$DISCORD_WEBHOOK_URL"; then
            echo "‚úÖ Discord notification sent successfully"
          else
            echo "‚ùå Failed to send Discord notification (webhook may be invalid or Discord may be unreachable)"
            exit 0  # Don't fail the workflow for notification failures
          fi

