name: "SSH Deploy"
description: "Deploy to a remote server via SSH with support for DockerHub pull or server-side build strategies"
author: "nuniesmith"

branding:
    icon: "upload-cloud"
    color: "green"

inputs:
    # â”€â”€ SSH Connection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    host:
        description: "Target host (Tailscale IP or hostname)"
        required: true
    port:
        description: "SSH port"
        required: false
        default: "22"
    username:
        description: "SSH username"
        required: true
    ssh-key:
        description: "SSH private key"
        required: false
        default: ""
    password:
        description: "SSH password (fallback if no key)"
        required: false
        default: ""
    timeout:
        description: "SSH connection timeout in seconds"
        required: false
        default: "30"
    use-tailscale-ssh:
        description: "Try Tailscale SSH first before regular SSH"
        required: false
        default: "true"
    ssh-retries:
        description: "Number of SSH connection retry attempts"
        required: false
        default: "3"
    ssh-retry-delay:
        description: "Delay in seconds between SSH retry attempts"
        required: false
        default: "10"

    # â”€â”€ Project â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    project-path:
        description: "Path to project on remote server"
        required: true

    # â”€â”€ Git â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    git-pull:
        description: "Pull latest changes from git"
        required: false
        default: "true"
    git-branch:
        description: "Git branch to checkout/pull"
        required: false
        default: "main"
    git-repo-url:
        description: "Git clone URL for first-time setup"
        required: false
        default: ""

    # â”€â”€ Build Strategy â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    build-strategy:
        description: "How to source Docker images: 'dockerhub' (pull pre-built), 'server-build' (build on server), or 'none' (skip build)"
        required: false
        default: "server-build"

    # â”€â”€ Docker Registry (for dockerhub strategy) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    docker-registry:
        description: "Docker registry URL"
        required: false
        default: "docker.io"
    docker-username:
        description: "Docker registry username (for pull or push)"
        required: false
        default: ""
    docker-password:
        description: "Docker registry password/token (for pull or push)"
        required: false
        default: ""
    docker-image-prefix:
        description: "Docker image prefix for pulling (e.g. 'nuniesmith/fks')"
        required: false
        default: ""
    docker-image-tag:
        description: "Docker image tag to pull (e.g. 'latest' or a sha)"
        required: false
        default: "latest"

    # â”€â”€ Docker Compose â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    compose-files:
        description: "Space-separated list of compose files (e.g. 'docker-compose.yml docker-compose.prod.yml')"
        required: false
        default: "docker-compose.yml"
    compose-project:
        description: "Docker Compose project name (-p flag)"
        required: false
        default: ""
    compose-env-file:
        description: "Path to .env file for docker compose (relative to project-path)"
        required: false
        default: ".env"
    compose-profiles:
        description: "Space-separated list of compose profiles to activate"
        required: false
        default: ""

    # â”€â”€ Services â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    app-services:
        description: "Space-separated list of app services to build/restart (empty = all)"
        required: false
        default: ""
    infra-services:
        description: "Space-separated list of infra services to ensure are running (kept alive during deploys)"
        required: false
        default: ""

    # â”€â”€ Commands â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    pre-deploy-command:
        description: "Command to run before deployment (runs in project-path context)"
        required: false
        default: ""
    deploy-command:
        description: "Custom deploy command (overrides the entire built-in deploy flow)"
        required: false
        default: ""
    post-deploy-command:
        description: "Command to run after deployment"
        required: false
        default: ""

    # â”€â”€ Cleanup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    docker-prune:
        description: "Prune unused Docker resources after deploy"
        required: false
        default: "true"

    # â”€â”€ Env Files (legacy) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    env-files:
        description: "JSON object of env files to create {filename: content}"
        required: false
        default: ""

outputs:
    deployed:
        description: "Whether deployment was successful"
        value: ${{ steps.deploy.outputs.deployed }}
    ssh-method:
        description: "SSH method used (tailscale/key/password)"
        value: ${{ steps.ssh-setup.outputs.method }}
    services-started:
        description: "Services that were started"
        value: ${{ steps.deploy.outputs.services }}
    build-strategy-used:
        description: "Build strategy that was used (dockerhub/server-build/none/custom)"
        value: ${{ steps.deploy.outputs.build_strategy }}

runs:
    using: "composite"
    steps:
        # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        # SSH SETUP
        # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        - name: ðŸ“¦ Install SSH tools
          shell: bash
          run: |
              if ! command -v sshpass &> /dev/null; then
                sudo apt-get update -qq && sudo apt-get install -y -qq sshpass 2>/dev/null
              fi
              if ! command -v nc &> /dev/null; then
                sudo apt-get install -y -qq netcat-openbsd 2>/dev/null || sudo apt-get install -y -qq netcat 2>/dev/null
              fi

        - name: ðŸ” Configure SSH
          id: ssh-setup
          shell: bash
          env:
              SSH_KEY: ${{ inputs.ssh-key }}
              SSH_HOST: ${{ inputs.host }}
              SSH_PORT: ${{ inputs.port }}
              SSH_USER: ${{ inputs.username }}
              SSH_PASSWORD: ${{ inputs.password }}
              USE_TAILSCALE_SSH: ${{ inputs.use-tailscale-ssh }}
              TIMEOUT: ${{ inputs.timeout }}
              RETRIES: ${{ inputs.ssh-retries }}
              RETRY_DELAY: ${{ inputs.ssh-retry-delay }}
          run: |
              set -euo pipefail

              mkdir -p ~/.ssh
              chmod 700 ~/.ssh

              # Configure SSH options
              cat >> ~/.ssh/config << SSHEOF
              Host ${SSH_HOST}
                  StrictHostKeyChecking no
                  UserKnownHostsFile /dev/null
                  ConnectTimeout ${TIMEOUT}
                  ServerAliveInterval 15
                  ServerAliveCountMax 6
                  Port ${SSH_PORT}
                  LogLevel ERROR
              SSHEOF

              # Setup SSH key if provided
              if [ -n "$SSH_KEY" ]; then
                echo "$SSH_KEY" > ~/.ssh/deploy_key
                chmod 600 ~/.ssh/deploy_key
                echo "âœ… SSH private key configured"
              fi

              # â”€â”€ Try SSH methods with retry â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
              try_ssh() {
                local method="$1"
                local attempt=0
                local max_attempts="${RETRIES}"

                while [ $attempt -lt $max_attempts ]; do
                  attempt=$((attempt + 1))
                  echo "  ðŸ”„ Attempt ${attempt}/${max_attempts} via ${method}..."

                  local result=0
                  case "$method" in
                    tailscale)
                      timeout 15 tailscale ssh ${SSH_USER}@${SSH_HOST} "echo '__SSH_OK__'" 2>&1 | grep -q "__SSH_OK__" || result=$?
                      ;;
                    key)
                      timeout 15 ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
                          -o ConnectTimeout=${TIMEOUT} -p ${SSH_PORT} -i ~/.ssh/deploy_key \
                          ${SSH_USER}@${SSH_HOST} "echo '__SSH_OK__'" 2>&1 | grep -q "__SSH_OK__" || result=$?
                      ;;
                    password)
                      sshpass -p "$SSH_PASSWORD" timeout 15 ssh -o StrictHostKeyChecking=no \
                          -o UserKnownHostsFile=/dev/null -o ConnectTimeout=${TIMEOUT} -p ${SSH_PORT} \
                          ${SSH_USER}@${SSH_HOST} "echo '__SSH_OK__'" 2>&1 | grep -q "__SSH_OK__" || result=$?
                      ;;
                  esac

                  if [ $result -eq 0 ]; then
                    return 0
                  fi

                  if [ $attempt -lt $max_attempts ]; then
                    echo "  â³ Retrying in ${RETRY_DELAY}s..."
                    sleep "${RETRY_DELAY}"
                  fi
                done
                return 1
              }

              SSH_METHOD=""

              # Try Tailscale SSH first
              if [ "$USE_TAILSCALE_SSH" = "true" ] && command -v tailscale &> /dev/null; then
                echo "ðŸ” Testing Tailscale SSH..."
                if try_ssh "tailscale"; then
                  SSH_METHOD="tailscale"
                  echo "âœ… Tailscale SSH connected"
                else
                  echo "âš ï¸  Tailscale SSH not available, falling back..."
                fi
              fi

              # Try SSH with key
              if [ -z "$SSH_METHOD" ] && [ -f ~/.ssh/deploy_key ]; then
                echo "ðŸ” Testing SSH with key..."
                if try_ssh "key"; then
                  SSH_METHOD="key"
                  echo "âœ… SSH key authentication connected"
                else
                  echo "âš ï¸  SSH key authentication failed, falling back..."
                fi
              fi

              # Try SSH with password
              if [ -z "$SSH_METHOD" ] && [ -n "${SSH_PASSWORD:-}" ]; then
                echo "ðŸ” Testing SSH with password..."
                if try_ssh "password"; then
                  SSH_METHOD="password"
                  echo "âœ… SSH password authentication connected"
                else
                  echo "âš ï¸  SSH password authentication failed"
                fi
              fi

              if [ -z "$SSH_METHOD" ]; then
                echo "âŒ No working SSH method found after ${RETRIES} attempts per method"
                echo "   Host: ${SSH_HOST}:${SSH_PORT}"
                echo "   User: ${SSH_USER}"
                echo "   Key provided: $([ -f ~/.ssh/deploy_key ] && echo 'yes' || echo 'no')"
                echo "   Password provided: $([ -n '${SSH_PASSWORD:-}' ] && echo 'yes' || echo 'no')"
                exit 1
              fi

              echo "method=${SSH_METHOD}" >> $GITHUB_OUTPUT
              echo "ðŸ“¡ SSH method: ${SSH_METHOD}"

        # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        # DEPLOY
        # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        - name: ðŸš€ Deploy to server
          id: deploy
          shell: bash
          env:
              SSH_HOST: ${{ inputs.host }}
              SSH_PORT: ${{ inputs.port }}
              SSH_USER: ${{ inputs.username }}
              SSH_PASSWORD: ${{ inputs.password }}
              SSH_METHOD: ${{ steps.ssh-setup.outputs.method }}
              PROJECT_PATH: ${{ inputs.project-path }}
              # Git
              GIT_PULL: ${{ inputs.git-pull }}
              GIT_BRANCH: ${{ inputs.git-branch }}
              GIT_REPO_URL: ${{ inputs.git-repo-url }}
              # Build strategy
              BUILD_STRATEGY: ${{ inputs.build-strategy }}
              # Docker registry
              DOCKER_REGISTRY: ${{ inputs.docker-registry }}
              DOCKER_USERNAME: ${{ inputs.docker-username }}
              DOCKER_PASSWORD: ${{ inputs.docker-password }}
              DOCKER_IMAGE_PREFIX: ${{ inputs.docker-image-prefix }}
              DOCKER_IMAGE_TAG: ${{ inputs.docker-image-tag }}
              # Compose
              COMPOSE_FILES: ${{ inputs.compose-files }}
              COMPOSE_PROJECT: ${{ inputs.compose-project }}
              COMPOSE_ENV_FILE: ${{ inputs.compose-env-file }}
              COMPOSE_PROFILES: ${{ inputs.compose-profiles }}
              # Services
              APP_SERVICES: ${{ inputs.app-services }}
              INFRA_SERVICES: ${{ inputs.infra-services }}
              # Commands
              PRE_DEPLOY_COMMAND: ${{ inputs.pre-deploy-command }}
              DEPLOY_COMMAND: ${{ inputs.deploy-command }}
              POST_DEPLOY_COMMAND: ${{ inputs.post-deploy-command }}
              # Cleanup
              DOCKER_PRUNE: ${{ inputs.docker-prune }}
              # Legacy
              ENV_FILES: ${{ inputs.env-files }}
          run: |
              set -euo pipefail

              # â”€â”€ SSH execution helper â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
              # Wraps commands with retry logic and proper error handling.
              # Usage: ssh_exec "command" [retries] [delay]
              ssh_exec() {
                local cmd="$1"
                local max_retries="${2:-2}"
                local retry_delay="${3:-5}"
                local attempt=0
                local exit_code=0

                while [ $attempt -lt $max_retries ]; do
                  attempt=$((attempt + 1))
                  exit_code=0

                  case "$SSH_METHOD" in
                    tailscale)
                      tailscale ssh ${SSH_USER}@${SSH_HOST} "bash -c '${cmd}'" || exit_code=$?
                      ;;
                    key)
                      ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
                          -o ServerAliveInterval=15 -o ServerAliveCountMax=6 \
                          -p ${SSH_PORT} -i ~/.ssh/deploy_key \
                          ${SSH_USER}@${SSH_HOST} "bash -c '${cmd}'" || exit_code=$?
                      ;;
                    password)
                      sshpass -p "$SSH_PASSWORD" ssh -o StrictHostKeyChecking=no \
                          -o UserKnownHostsFile=/dev/null \
                          -o ServerAliveInterval=15 -o ServerAliveCountMax=6 \
                          -p ${SSH_PORT} \
                          ${SSH_USER}@${SSH_HOST} "bash -c '${cmd}'" || exit_code=$?
                      ;;
                  esac

                  if [ $exit_code -eq 0 ]; then
                    return 0
                  fi

                  if [ $attempt -lt $max_retries ]; then
                    echo "  âš ï¸  Command failed (exit ${exit_code}), retrying in ${retry_delay}s... (${attempt}/${max_retries})"
                    sleep "${retry_delay}"
                  fi
                done

                echo "  âŒ Command failed after ${max_retries} attempts (exit ${exit_code})"
                return $exit_code
              }

              # â”€â”€ Build the compose command â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
              build_compose_cmd() {
                local cmd="docker compose"

                # Project name
                if [ -n "${COMPOSE_PROJECT}" ]; then
                  cmd="${cmd} -p ${COMPOSE_PROJECT}"
                fi

                # Env file
                if [ -n "${COMPOSE_ENV_FILE}" ]; then
                  cmd="${cmd} --env-file ${COMPOSE_ENV_FILE}"
                fi

                # Compose files
                for f in ${COMPOSE_FILES}; do
                  cmd="${cmd} -f ${f}"
                done

                # Profiles
                for p in ${COMPOSE_PROFILES}; do
                  cmd="${cmd} --profile ${p}"
                done

                echo "${cmd}"
              }

              COMPOSE_CMD="$(build_compose_cmd)"

              echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              echo "ðŸš€ SSH Deploy"
              echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              echo "ðŸ“ Host:           ${SSH_HOST}:${SSH_PORT}"
              echo "ðŸ‘¤ User:           ${SSH_USER}"
              echo "ðŸ“¡ SSH Method:     ${SSH_METHOD}"
              echo "ðŸ“ Project:        ${PROJECT_PATH}"
              echo "ðŸ”§ Build Strategy: ${BUILD_STRATEGY}"
              echo "ðŸ³ Compose:        ${COMPOSE_CMD}"
              echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

              # â”€â”€ Phase 0: First-time clone â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
              if [ -n "${GIT_REPO_URL}" ]; then
                echo ""
                echo "ðŸ“¦ Checking for existing project..."
                ssh_exec "
                  if [ ! -d '${PROJECT_PATH}/.git' ]; then
                    echo 'ðŸ“¦ First-time setup â€” cloning repository...'
                    rm -rf '${PROJECT_PATH}'
                    git clone '${GIT_REPO_URL}' '${PROJECT_PATH}'
                    echo 'âœ… Repository cloned'
                  else
                    echo 'âœ… Project already exists'
                  fi
                "
              fi

              # â”€â”€ Phase 1: Pre-deploy command â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
              if [ -n "${PRE_DEPLOY_COMMAND}" ]; then
                echo ""
                echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                echo "âš™ï¸  PHASE 1: Pre-Deploy"
                echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                ssh_exec "cd '${PROJECT_PATH}' 2>/dev/null || cd ~ && ${PRE_DEPLOY_COMMAND}"
              fi

              # â”€â”€ Phase 2: Git pull â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
              if [ "${GIT_PULL}" = "true" ]; then
                echo ""
                echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                echo "ðŸ“¥ PHASE 2: Git Pull (${GIT_BRANCH})"
                echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                ssh_exec "
                  cd '${PROJECT_PATH}'
                  echo 'ðŸ“¥ Fetching from origin...'
                  git fetch origin
                  git checkout '${GIT_BRANCH}' 2>/dev/null || true
                  git pull origin '${GIT_BRANCH}'
                  echo \"âœ… Now at: \$(git log --oneline -1)\"
                " 3 10
              fi

              # â”€â”€ Phase 3: Create env files (legacy JSON support) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
              if [ -n "${ENV_FILES}" ] && [ "${ENV_FILES}" != "{}" ]; then
                echo ""
                echo "ðŸ“ Creating environment files..."
                echo "${ENV_FILES}" | jq -r 'to_entries[] | "\(.key):\(.value)"' 2>/dev/null | while IFS=: read -r filename content; do
                  if [ -n "$filename" ] && [ -n "$content" ]; then
                    echo "  ðŸ“„ ${filename}"
                    ssh_exec "echo '${content}' > '${PROJECT_PATH}/${filename}' && chmod 600 '${PROJECT_PATH}/${filename}'"
                  fi
                done || echo "  (No env files to create or JSON parsing skipped)"
              fi

              # â”€â”€ Phase 4: Deploy â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
              echo ""
              echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              echo "ðŸš€ PHASE 4: Deploy (strategy: ${BUILD_STRATEGY})"
              echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

              # If a custom deploy command is provided, it overrides everything
              if [ -n "${DEPLOY_COMMAND}" ]; then
                echo "âš™ï¸  Running custom deploy command..."
                ssh_exec "cd '${PROJECT_PATH}' && ${DEPLOY_COMMAND}"
                echo "build_strategy=custom" >> $GITHUB_OUTPUT
                echo "services=custom" >> $GITHUB_OUTPUT

              elif [ "${BUILD_STRATEGY}" = "dockerhub" ]; then
                # â”€â”€ DockerHub Strategy â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                # Pull pre-built images from registry, then start services.
                echo "ðŸ³ Strategy: Pull from DockerHub"

                # Docker login on remote
                if [ -n "${DOCKER_USERNAME}" ] && [ -n "${DOCKER_PASSWORD}" ]; then
                  echo "ðŸ”‘ Logging into Docker registry (${DOCKER_REGISTRY})..."
                  ssh_exec "echo '${DOCKER_PASSWORD}' | docker login -u '${DOCKER_USERNAME}' --password-stdin '${DOCKER_REGISTRY}'" 2 5
                fi

                # Stop app services (keep infra running)
                if [ -n "${APP_SERVICES}" ]; then
                  echo "ðŸ›‘ Stopping app services: ${APP_SERVICES}"
                  ssh_exec "cd '${PROJECT_PATH}' && ${COMPOSE_CMD} stop ${APP_SERVICES} 2>/dev/null || true && ${COMPOSE_CMD} rm -f ${APP_SERVICES} 2>/dev/null || true"
                fi

                # Pull images
                if [ -n "${APP_SERVICES}" ]; then
                  echo "ðŸ“¥ Pulling images for: ${APP_SERVICES}"
                  ssh_exec "cd '${PROJECT_PATH}' && ${COMPOSE_CMD} pull ${APP_SERVICES}" 3 10
                else
                  echo "ðŸ“¥ Pulling all images..."
                  ssh_exec "cd '${PROJECT_PATH}' && ${COMPOSE_CMD} pull" 3 10
                fi

                # Ensure infra services are running
                if [ -n "${INFRA_SERVICES}" ]; then
                  echo "ðŸ”§ Ensuring infrastructure services are running..."
                  ssh_exec "cd '${PROJECT_PATH}' && ${COMPOSE_CMD} up -d --no-recreate ${INFRA_SERVICES}"
                fi

                # Start all services
                echo "ðŸš€ Starting services..."
                ssh_exec "cd '${PROJECT_PATH}' && ${COMPOSE_CMD} up -d"

                echo "build_strategy=dockerhub" >> $GITHUB_OUTPUT
                echo "services=${APP_SERVICES:-all}" >> $GITHUB_OUTPUT

              elif [ "${BUILD_STRATEGY}" = "server-build" ]; then
                # â”€â”€ Server Build Strategy â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                # Build images directly on the server from source.
                echo "ðŸ”¨ Strategy: Build on server"

                # Docker login (may be needed for base images)
                if [ -n "${DOCKER_USERNAME}" ] && [ -n "${DOCKER_PASSWORD}" ]; then
                  echo "ðŸ”‘ Logging into Docker registry (${DOCKER_REGISTRY})..."
                  ssh_exec "echo '${DOCKER_PASSWORD}' | docker login -u '${DOCKER_USERNAME}' --password-stdin '${DOCKER_REGISTRY}'" 2 5
                fi

                # Stop app services (keep infra running)
                if [ -n "${APP_SERVICES}" ]; then
                  echo "ðŸ›‘ Stopping app services: ${APP_SERVICES}"
                  ssh_exec "cd '${PROJECT_PATH}' && ${COMPOSE_CMD} stop ${APP_SERVICES} 2>/dev/null || true && ${COMPOSE_CMD} rm -f ${APP_SERVICES} 2>/dev/null || true"
                fi

                # Clean orphan containers
                ssh_exec "docker container prune -f --filter 'label=com.docker.compose.project=${COMPOSE_PROJECT}' 2>/dev/null || true"

                # Build images on server
                if [ -n "${APP_SERVICES}" ]; then
                  echo "ðŸ”¨ Building app images: ${APP_SERVICES}"
                  ssh_exec "cd '${PROJECT_PATH}' && ${COMPOSE_CMD} build --parallel ${APP_SERVICES}" 1 0
                else
                  echo "ðŸ”¨ Building all images..."
                  ssh_exec "cd '${PROJECT_PATH}' && ${COMPOSE_CMD} build --parallel" 1 0
                fi
                echo "âœ… Images built"

                # Ensure infra services are running
                if [ -n "${INFRA_SERVICES}" ]; then
                  echo "ðŸ”§ Ensuring infrastructure services are running..."
                  ssh_exec "cd '${PROJECT_PATH}' && ${COMPOSE_CMD} up -d --no-recreate ${INFRA_SERVICES}"
                fi

                # Start all services
                echo "ðŸš€ Starting all services..."
                ssh_exec "cd '${PROJECT_PATH}' && ${COMPOSE_CMD} up -d"

                echo "build_strategy=server-build" >> $GITHUB_OUTPUT
                echo "services=${APP_SERVICES:-all}" >> $GITHUB_OUTPUT

              else
                # â”€â”€ None / Skip â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                echo "â­ï¸  Build strategy: none â€” skipping build phase"
                echo "ðŸš€ Starting services with existing images..."
                ssh_exec "cd '${PROJECT_PATH}' && ${COMPOSE_CMD} up -d"

                echo "build_strategy=none" >> $GITHUB_OUTPUT
                echo "services=all" >> $GITHUB_OUTPUT
              fi

              # â”€â”€ Phase 5: Docker prune â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
              if [ "${DOCKER_PRUNE}" = "true" ]; then
                echo ""
                echo "ðŸ§¹ Pruning unused Docker resources..."
                ssh_exec "docker image prune -f --filter 'until=24h' 2>/dev/null; docker container prune -f 2>/dev/null; docker builder prune -f 2>/dev/null" 1 0 || true
              fi

              # â”€â”€ Phase 6: Show status â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
              echo ""
              echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              echo "ðŸ“Š Container Status"
              echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              ssh_exec "cd '${PROJECT_PATH}' && ${COMPOSE_CMD} ps --format 'table {{.Name}}\t{{.Status}}\t{{.Ports}}' 2>/dev/null || docker ps -a --filter 'name=${COMPOSE_PROJECT}' --format 'table {{.Names}}\t{{.Status}}' 2>/dev/null || echo 'Could not retrieve container status'" 1 0 || true

              # â”€â”€ Phase 7: Post-deploy command â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
              if [ -n "${POST_DEPLOY_COMMAND}" ]; then
                echo ""
                echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                echo "âš™ï¸  PHASE 7: Post-Deploy"
                echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                ssh_exec "cd '${PROJECT_PATH}' && ${POST_DEPLOY_COMMAND}"
              fi

              echo ""
              echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              echo "âœ… Deployment complete!"
              echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              echo "deployed=true" >> $GITHUB_OUTPUT

        # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        # SUMMARY
        # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        - name: ðŸ“Š Deployment Summary
          if: always()
          shell: bash
          env:
              SSH_METHOD: ${{ steps.ssh-setup.outputs.method }}
              SERVICES: ${{ steps.deploy.outputs.services }}
              BUILD_STRATEGY: ${{ steps.deploy.outputs.build_strategy }}
              DEPLOYED: ${{ steps.deploy.outputs.deployed }}
          run: |
              STATUS="${DEPLOYED:-false}"
              if [ "$STATUS" = "true" ]; then
                ICON="âœ…"
                MSG="Deployment successful!"
              else
                ICON="âŒ"
                MSG="Deployment failed"
              fi

              cat >> $GITHUB_STEP_SUMMARY << EOF
              ## ðŸš€ SSH Deploy Summary

              | Property | Value |
              |----------|-------|
              | Host | \`${{ inputs.host }}:${{ inputs.port }}\` |
              | User | \`${{ inputs.username }}\` |
              | SSH Method | \`${SSH_METHOD:-unknown}\` |
              | Project Path | \`${{ inputs.project-path }}\` |
              | Build Strategy | \`${BUILD_STRATEGY:-unknown}\` |
              | Services | \`${SERVICES:-all}\` |
              | Git Pull | \`${{ inputs.git-pull }}\` |
              | Git Branch | \`${{ inputs.git-branch }}\` |

              ${ICON} **${MSG}**
              EOF
