name: "SSL Certbot Cloudflare"
description: "Generate SSL certificates using Certbot with Cloudflare DNS-01 challenge, with optional self-signed fallback and remote server deployment"
author: "nuniesmith"

branding:
    icon: "lock"
    color: "green"

inputs:
    domain:
        description: "Primary domain for the certificate"
        required: true
    additional-domains:
        description: 'Additional domains (comma-separated, e.g., "www.example.com,api.example.com")'
        required: false
        default: ""
    cloudflare-api-token:
        description: "Cloudflare API token with DNS edit permissions"
        required: false
        default: ""
    email:
        description: "Email address for Let's Encrypt notifications"
        required: true
    propagation-seconds:
        description: "Seconds to wait for DNS propagation"
        required: false
        default: "60"
    staging:
        description: "Use Let's Encrypt staging server (for testing)"
        required: false
        default: "false"
    fallback-to-self-signed:
        description: "Generate self-signed certificates if Let's Encrypt fails (rate limits, missing credentials, etc.)"
        required: false
        default: "false"
    self-signed-days:
        description: "Validity period for self-signed certificates in days"
        required: false
        default: "365"
    deploy-to-server:
        description: "Deploy certificates to a remote server"
        required: false
        default: "false"
    ssh-host:
        description: "SSH host for certificate deployment"
        required: false
        default: ""
    ssh-port:
        description: "SSH port for certificate deployment"
        required: false
        default: "22"
    ssh-user:
        description: "SSH user for certificate deployment"
        required: false
        default: "actions"
    ssh-key:
        description: "SSH private key for certificate deployment"
        required: false
        default: ""
    root-ssh-key:
        description: "Root SSH private key for Docker volume operations (use if ssh-user lacks sudo)"
        required: false
        default: ""
    use-sudo:
        description: "Use sudo for Docker commands (if ssh-user has sudo access)"
        required: false
        default: "false"
    deploy-method:
        description: "Deployment method: 'docker-volume' or 'host-path'"
        required: false
        default: "docker-volume"
    host-cert-path:
        description: "Host filesystem path to store certificates (when deploy-method=host-path)"
        required: false
        default: "/etc/letsencrypt"
    docker-volume-name:
        description: "Docker volume name to store certificates on remote server (when deploy-method=docker-volume)"
        required: false
        default: "certbot_certs"
    docker-username:
        description: "Docker Hub username (to avoid rate limits)"
        required: false
        default: ""
    docker-token:
        description: "Docker Hub token (to avoid rate limits)"
        required: false
        default: ""

outputs:
    cert-ready:
        description: "Whether certificates are available (generated or found in volume)"
        value: ${{ steps.certbot.outputs.cert_ready }}
    cert-type:
        description: "Type of certificate (letsencrypt, self-signed, letsencrypt-cached, self-signed-cached)"
        value: ${{ steps.certbot.outputs.cert_type }}
    cert-path:
        description: "Path to the certificate directory"
        value: ${{ steps.certbot.outputs.cert_path }}
    expiry-date:
        description: "Certificate expiry date"
        value: ${{ steps.certbot.outputs.expiry_date }}
    cert-source:
        description: "Where the certificate came from (certbot, volume, self-signed)"
        value: ${{ steps.certbot.outputs.cert_source }}
    deployed:
        description: "Whether certificates were deployed to the server (or already present in volume)"
        value: ${{ steps.certbot.outputs.cert_source == 'volume' && 'true' || steps.deploy.outputs.deployed }}

runs:
    using: "composite"
    steps:
        - name: üîê Generate SSL Certificates
          id: certbot
          shell: bash
          env:
              CF_API_TOKEN: ${{ inputs.cloudflare-api-token }}
              SSL_EMAIL: ${{ inputs.email }}
              DOMAIN: ${{ inputs.domain }}
              ADDITIONAL_DOMAINS: ${{ inputs.additional-domains }}
              PROPAGATION_SECONDS: ${{ inputs.propagation-seconds }}
              USE_STAGING: ${{ inputs.staging }}
              FALLBACK_SELF_SIGNED: ${{ inputs.fallback-to-self-signed }}
              SELF_SIGNED_DAYS: ${{ inputs.self-signed-days }}
              DEPLOY_TO_SERVER: ${{ inputs.deploy-to-server }}
              SSH_HOST: ${{ inputs.ssh-host }}
              SSH_PORT: ${{ inputs.ssh-port }}
              SSH_USER: ${{ inputs.ssh-user }}
              SSH_KEY: ${{ inputs.ssh-key }}
              DOCKER_VOLUME: ${{ inputs.docker-volume-name }}
          run: |
              echo "üîê Generating SSL certificates..."

              # Create temp directory for certs
              mkdir -p /tmp/letsencrypt

              # Build SAN list for self-signed fallback
              SAN_LIST="DNS:$DOMAIN"
              ALL_DOMAINS="$DOMAIN"
              if [ -n "$ADDITIONAL_DOMAINS" ]; then
                IFS=',' read -ra EXTRA_DOMAINS <<< "$ADDITIONAL_DOMAINS"
                for extra in "${EXTRA_DOMAINS[@]}"; do
                  extra=$(echo "$extra" | xargs)
                  if [ -n "$extra" ]; then
                    SAN_LIST="$SAN_LIST,DNS:$extra"
                    ALL_DOMAINS="$ALL_DOMAINS,$extra"
                  fi
                done
              fi

              # Function to generate self-signed certificates
              generate_self_signed() {
                echo "üîí Generating self-signed certificates..."
                echo "üìß Email: $SSL_EMAIL"
                echo "üåê Domains: $ALL_DOMAINS"

                # Create directory structure matching Let's Encrypt
                sudo mkdir -p /tmp/letsencrypt/live/$DOMAIN
                sudo mkdir -p /tmp/letsencrypt/archive/$DOMAIN

                # Generate self-signed certificate using openssl
                docker run --rm \
                  -v /tmp/letsencrypt:/etc/letsencrypt \
                  alpine/openssl:3.3.2 \
                  req -x509 -nodes -days $SELF_SIGNED_DAYS -newkey rsa:2048 \
                  -keyout /etc/letsencrypt/archive/$DOMAIN/privkey1.pem \
                  -out /etc/letsencrypt/archive/$DOMAIN/fullchain1.pem \
                  -subj "/C=US/ST=State/L=City/O=Organization/CN=$DOMAIN" \
                  -addext "subjectAltName=$SAN_LIST"

                # Copy files to live directory (symlinks break during tar/transfer to Docker volumes)
                sudo cp /tmp/letsencrypt/archive/$DOMAIN/fullchain1.pem /tmp/letsencrypt/live/$DOMAIN/fullchain.pem
                sudo cp /tmp/letsencrypt/archive/$DOMAIN/privkey1.pem /tmp/letsencrypt/live/$DOMAIN/privkey.pem
                sudo cp /tmp/letsencrypt/archive/$DOMAIN/fullchain1.pem /tmp/letsencrypt/live/$DOMAIN/cert.pem
                sudo cp /tmp/letsencrypt/archive/$DOMAIN/fullchain1.pem /tmp/letsencrypt/live/$DOMAIN/chain.pem

                # Verify self-signed cert was created
                if sudo test -f "/tmp/letsencrypt/live/$DOMAIN/fullchain.pem"; then
                  echo "‚úÖ Self-signed certificates generated successfully"
                  echo "cert_ready=true" >> $GITHUB_OUTPUT
                  echo "cert_type=self-signed" >> $GITHUB_OUTPUT
                  echo "cert_source=self-signed" >> $GITHUB_OUTPUT
                  echo "cert_path=/tmp/letsencrypt/live/$DOMAIN" >> $GITHUB_OUTPUT

                  # Get expiry date
                  EXPIRY=$(docker run --rm \
                    -v /tmp/letsencrypt:/etc/letsencrypt:ro \
                    alpine/openssl:3.3.2 \
                    x509 -in "/etc/letsencrypt/live/$DOMAIN/fullchain.pem" -noout -enddate 2>/dev/null | cut -d= -f2 || echo "unknown")
                  echo "expiry_date=$EXPIRY" >> $GITHUB_OUTPUT
                  echo "üìÖ Certificate expires: $EXPIRY"
                  return 0
                else
                  echo "‚ùå Failed to generate self-signed certificates"
                  echo "cert_ready=false" >> $GITHUB_OUTPUT
                  return 1
                fi
              }

              # Check if Cloudflare API token is set
              if [ -z "$CF_API_TOKEN" ]; then
                echo "‚ö†Ô∏è Cloudflare API token not provided"
                if [ "$FALLBACK_SELF_SIGNED" = "true" ]; then
                  echo "üìú Falling back to self-signed certificates..."
                  generate_self_signed
                  exit $?
                else
                  echo "‚ùå Error: CLOUDFLARE_API_KEY required (or enable fallback-to-self-signed)"
                  echo "cert_ready=false" >> $GITHUB_OUTPUT
                  exit 1
                fi
              fi

              echo "‚úÖ Cloudflare API token found"
              echo "üìß Using email: $SSL_EMAIL"
              echo "üåê Primary domain: $DOMAIN"

              # Create Cloudflare credentials file
              echo "dns_cloudflare_api_token = $CF_API_TOKEN" > /tmp/cloudflare.ini
              chmod 600 /tmp/cloudflare.ini

              # Verify credentials file was created correctly
              if [ ! -s /tmp/cloudflare.ini ]; then
                echo "‚ùå Error: Failed to create credentials file"
                if [ "$FALLBACK_SELF_SIGNED" = "true" ]; then
                  echo "üìú Falling back to self-signed certificates..."
                  generate_self_signed
                  exit $?
                else
                  echo "cert_ready=false" >> $GITHUB_OUTPUT
                  exit 1
                fi
              fi

              # Build domain arguments
              DOMAIN_ARGS="-d $DOMAIN"
              if [ -n "$ADDITIONAL_DOMAINS" ]; then
                IFS=',' read -ra EXTRA_DOMAINS <<< "$ADDITIONAL_DOMAINS"
                for extra in "${EXTRA_DOMAINS[@]}"; do
                  extra=$(echo "$extra" | xargs)
                  if [ -n "$extra" ]; then
                    DOMAIN_ARGS="$DOMAIN_ARGS -d $extra"
                    echo "üåê Additional domain: $extra"
                  fi
                done
              fi

              # Add staging flag if requested
              STAGING_FLAG=""
              if [ "$USE_STAGING" = "true" ]; then
                STAGING_FLAG="--staging"
                echo "‚ö†Ô∏è Using Let's Encrypt STAGING server (certificates will NOT be trusted)"
              fi

              # Run certbot with DNS-01 challenge (with retry logic)
              set +e
              CERTBOT_EXIT=1
              MAX_CERTBOT_ATTEMPTS=2
              CURRENT_PROPAGATION=$PROPAGATION_SECONDS

              for CERTBOT_ATTEMPT in $(seq 1 $MAX_CERTBOT_ATTEMPTS); do
                echo "üîÑ Certbot attempt ${CERTBOT_ATTEMPT}/${MAX_CERTBOT_ATTEMPTS} (propagation: ${CURRENT_PROPAGATION}s)..."
                docker run --rm \
                  -v /tmp/letsencrypt:/etc/letsencrypt \
                  -v /tmp/cloudflare.ini:/tmp/cloudflare.ini:ro \
                  certbot/dns-cloudflare:v2.11.0 \
                  certonly \
                  --dns-cloudflare \
                  --dns-cloudflare-credentials /tmp/cloudflare.ini \
                  --dns-cloudflare-propagation-seconds $CURRENT_PROPAGATION \
                  --email "$SSL_EMAIL" \
                  --agree-tos \
                  --no-eff-email \
                  --non-interactive \
                  --keep-until-expiring \
                  $STAGING_FLAG \
                  $DOMAIN_ARGS
                CERTBOT_EXIT=$?

                if [ $CERTBOT_EXIT -eq 0 ]; then
                  echo "‚úÖ Certbot succeeded on attempt ${CERTBOT_ATTEMPT}"
                  break
                fi

                if [ $CERTBOT_ATTEMPT -lt $MAX_CERTBOT_ATTEMPTS ]; then
                  # Double propagation time on retry
                  CURRENT_PROPAGATION=$((CURRENT_PROPAGATION * 2))
                  echo "‚ö†Ô∏è Certbot failed (exit $CERTBOT_EXIT), retrying with ${CURRENT_PROPAGATION}s propagation..."
                  sleep 5
                fi
              done
              set -e

              # Cleanup credentials immediately
              rm -f /tmp/cloudflare.ini

              # Debug: show what was created
              echo "üìÅ Checking certificate directory..."
              sudo ls -la /tmp/letsencrypt/ 2>/dev/null || true
              sudo ls -la /tmp/letsencrypt/live/ 2>/dev/null || true
              sudo ls -la /tmp/letsencrypt/live/$DOMAIN/ 2>/dev/null || true

              # Check if certs were created/renewed
              if sudo test -f "/tmp/letsencrypt/live/$DOMAIN/fullchain.pem"; then
                echo "‚úÖ Let's Encrypt certificates obtained successfully"
                echo "cert_ready=true" >> $GITHUB_OUTPUT
                echo "cert_type=letsencrypt" >> $GITHUB_OUTPUT
                echo "cert_source=certbot" >> $GITHUB_OUTPUT
                echo "cert_path=/tmp/letsencrypt/live/$DOMAIN" >> $GITHUB_OUTPUT

                # Get expiry date
                EXPIRY=$(docker run --rm \
                  -v /tmp/letsencrypt:/etc/letsencrypt:ro \
                  alpine/openssl:3.3.2 \
                  x509 -in "/etc/letsencrypt/live/$DOMAIN/fullchain.pem" -noout -enddate 2>/dev/null | cut -d= -f2 || echo "unknown")
                echo "expiry_date=$EXPIRY" >> $GITHUB_OUTPUT
                echo "üìÖ Certificate expires: $EXPIRY"
              else
                echo "‚ö†Ô∏è Let's Encrypt failed after ${MAX_CERTBOT_ATTEMPTS} attempts (exit code: $CERTBOT_EXIT)"
                echo ""
                echo "‚ÑπÔ∏è  The caller (ci-cd.yml) should handle fallback logic via ssl-check"
                echo "   and ssl-fallback steps.  This action no longer duplicates volume checks."

                if [ "$FALLBACK_SELF_SIGNED" = "true" ]; then
                  echo "üìú Falling back to self-signed certificates..."
                  generate_self_signed
                  exit $?
                else
                  echo "‚ùå Certificate generation failed and self-signed fallback is disabled"
                  echo "cert_ready=false" >> $GITHUB_OUTPUT
                  exit 1
                fi
              fi

        - name: üì¶ Package Certificates
          if: steps.certbot.outputs.cert_ready == 'true' && steps.certbot.outputs.cert_source != 'volume'
          shell: bash
          env:
              DOMAIN: ${{ inputs.domain }}
          run: |
              echo "üì¶ Packaging certificates for transfer..."
              echo "üìú Certificate type: ${{ steps.certbot.outputs.cert_type }}"

              # Create tarball of certificates
              cd /tmp/letsencrypt
              sudo tar -czf /tmp/ssl-certs.tar.gz \
                live/$DOMAIN \
                archive/$DOMAIN \
                renewal/$DOMAIN.conf 2>/dev/null || \
              sudo tar -czf /tmp/ssl-certs.tar.gz \
                live/$DOMAIN \
                archive/$DOMAIN

              echo "‚úÖ Certificates packaged"
              ls -la /tmp/ssl-certs.tar.gz

        - name: üöÄ Deploy Certificates to Server
          id: deploy
          if: steps.certbot.outputs.cert_ready == 'true' && inputs.deploy-to-server == 'true' && steps.certbot.outputs.cert_source != 'volume'
          shell: bash
          env:
              SSH_KEY: ${{ inputs.ssh-key }}
              ROOT_SSH_KEY: ${{ inputs.root-ssh-key }}
              USE_SUDO: ${{ inputs.use-sudo }}
              SSH_HOST: ${{ inputs.ssh-host }}
              SSH_PORT: ${{ inputs.ssh-port }}
              SSH_USER: ${{ inputs.ssh-user }}
              DEPLOY_METHOD: ${{ inputs.deploy-method }}
              HOST_CERT_PATH: ${{ inputs.host-cert-path }}
              DOCKER_VOLUME: ${{ inputs.docker-volume-name }}
              DOCKER_USER: ${{ inputs.docker-username }}
              DOCKER_TOKEN: ${{ inputs.docker-token }}
              DOMAIN: ${{ inputs.domain }}
              CERT_TYPE: ${{ steps.certbot.outputs.cert_type }}
          run: |
              echo "üöÄ Deploying certificates to server..."
              echo "üìú Certificate type: $CERT_TYPE"
              echo "üì¶ Deployment method: $DEPLOY_METHOD"

              if [ -z "$SSH_HOST" ] || [ -z "$SSH_KEY" ]; then
                echo "‚ùå SSH host or key not provided for deployment"
                echo "deployed=false" >> $GITHUB_OUTPUT
                exit 1
              fi

              # Determine which SSH key and user to use
              DEPLOY_SSH_KEY="$SSH_KEY"
              DEPLOY_USER="$SSH_USER"
              USE_ROOT_KEY=false

              if [ -n "$ROOT_SSH_KEY" ]; then
                echo "üîë Using root SSH key for deployment operations"
                DEPLOY_USER="root"
                USE_ROOT_KEY=true
              elif [ "$USE_SUDO" = "true" ]; then
                echo "üîë Using sudo for deployment operations"
              fi

              # Setup SSH for initial transfer (use regular user)
              mkdir -p ~/.ssh
              echo "$SSH_KEY" > ~/.ssh/id_rsa
              chmod 600 ~/.ssh/id_rsa
              ssh-keyscan -p $SSH_PORT $SSH_HOST >> ~/.ssh/known_hosts 2>/dev/null || true

              # Copy certificates to server
              scp -P $SSH_PORT /tmp/ssl-certs.tar.gz $SSH_USER@$SSH_HOST:/tmp/ssl-certs.tar.gz

              # Setup deployment SSH key if using root
              if [ "$USE_ROOT_KEY" = "true" ]; then
                printf '%s\n' "$ROOT_SSH_KEY" > ~/.ssh/id_rsa_deploy
                chmod 600 ~/.ssh/id_rsa_deploy
                SSH_KEY_ARG="-i ~/.ssh/id_rsa_deploy"
              else
                SSH_KEY_ARG="-i ~/.ssh/id_rsa"
              fi

              # Determine sudo prefix
              SUDO_CMD=""
              if [ "$USE_SUDO" = "true" ] && [ "$DEPLOY_USER" != "root" ]; then
                SUDO_CMD="sudo"
              fi

              if [ "$DEPLOY_METHOD" = "host-path" ]; then
                echo "üìÇ Deploying to host filesystem: $HOST_CERT_PATH"

                # Deploy to host filesystem
                ssh $SSH_KEY_ARG -p $SSH_PORT $DEPLOY_USER@$SSH_HOST "
                  set -e
                  echo 'üì¶ Extracting certificates to host filesystem...'
                  echo 'üë§ Running as:' \$(whoami)

                  # Determine sudo command based on user
                  if [ \"\$(whoami)\" = \"root\" ]; then
                    SUDO_CMD=\"\"
                  else
                    SUDO_CMD=\"sudo\"
                  fi

                  # Create directory structure
                  \$SUDO_CMD mkdir -p $HOST_CERT_PATH

                  # Extract certificates
                  cd $HOST_CERT_PATH
                  \$SUDO_CMD tar -xzf /tmp/ssl-certs.tar.gz

                  # Set proper permissions
                  \$SUDO_CMD chmod -R 755 $HOST_CERT_PATH
                  \$SUDO_CMD chmod 600 $HOST_CERT_PATH/archive/*/privkey*.pem 2>/dev/null || true

                  # Cleanup
                  rm -f /tmp/ssl-certs.tar.gz

                  # Verify
                  echo '‚úÖ Certificates deployed to host path: $HOST_CERT_PATH'
                  \$SUDO_CMD ls -la $HOST_CERT_PATH/live/
                  echo 'üìÑ Verifying certificate files exist:'
                  \$SUDO_CMD ls -la $HOST_CERT_PATH/live/$DOMAIN/ || echo '‚ö†Ô∏è Could not list domain directory'
                  \$SUDO_CMD cat $HOST_CERT_PATH/live/$DOMAIN/fullchain.pem | head -5 || echo '‚ö†Ô∏è Could not read fullchain.pem'
                "
              else
                echo "üì¶ Deploying to Docker volume: $DOCKER_VOLUME"

                # Build docker login command if credentials provided
                DOCKER_LOGIN_CMD=""
                if [ -n "$DOCKER_USER" ] && [ -n "$DOCKER_TOKEN" ]; then
                  DOCKER_LOGIN_CMD="echo '$DOCKER_TOKEN' | docker login -u '$DOCKER_USER' --password-stdin 2>/dev/null && echo '‚úÖ Logged in to Docker Hub' || echo '‚ö†Ô∏è Docker login failed, continuing...'"
                fi

                # Deploy to Docker volume
                ssh $SSH_KEY_ARG -p $SSH_PORT $DEPLOY_USER@$SSH_HOST "
                  set -e
                  echo 'üì¶ Extracting certificates to Docker volume...'
                  echo 'üë§ Running as:' \$(whoami)

                  # Determine sudo command based on user
                  if [ \"\$(whoami)\" = \"root\" ]; then
                    SUDO_CMD=\"\"
                  else
                    SUDO_CMD=\"sudo\"
                  fi

                  # Docker login if credentials provided
                  $DOCKER_LOGIN_CMD

                  # Create volume if it doesn't exist
                  \$SUDO_CMD docker volume create $DOCKER_VOLUME 2>/dev/null || true

                  # Use busybox for extraction
                  \$SUDO_CMD docker run --rm \
                    -v /tmp/ssl-certs.tar.gz:/tmp/ssl-certs.tar.gz:ro \
                    -v $DOCKER_VOLUME:/etc/letsencrypt \
                    busybox:1.37 \
                    sh -c 'cd /etc/letsencrypt && tar -xzf /tmp/ssl-certs.tar.gz && chmod -R 755 /etc/letsencrypt && chmod 600 /etc/letsencrypt/archive/*/privkey*.pem 2>/dev/null || true'

                  # Cleanup
                  rm -f /tmp/ssl-certs.tar.gz

                  # Verify
                  echo '‚úÖ Certificates deployed to Docker volume: $DOCKER_VOLUME'
                  \$SUDO_CMD docker run --rm -v $DOCKER_VOLUME:/etc/letsencrypt:ro busybox:1.37 ls -la /etc/letsencrypt/live/
                  echo 'üìÑ Verifying certificate files exist:'
                  \$SUDO_CMD docker run --rm -v $DOCKER_VOLUME:/etc/letsencrypt:ro busybox:1.37 ls -la /etc/letsencrypt/live/$DOMAIN/ || echo '‚ö†Ô∏è Could not list domain directory'
                  \$SUDO_CMD docker run --rm -v $DOCKER_VOLUME:/etc/letsencrypt:ro busybox:1.37 cat /etc/letsencrypt/live/$DOMAIN/fullchain.pem | head -5 || echo '‚ö†Ô∏è Could not read fullchain.pem'
                "
              fi

              # Cleanup local SSH keys
              rm -f ~/.ssh/id_rsa ~/.ssh/id_rsa_deploy

              echo "‚úÖ SSL certificates deployed to production"
              echo "deployed=true" >> $GITHUB_OUTPUT

        - name: üìã SSL Summary
          if: always()
          shell: bash
          env:
              CERT_READY: ${{ steps.certbot.outputs.cert_ready }}
              CERT_TYPE: ${{ steps.certbot.outputs.cert_type }}
              DEPLOYED: ${{ steps.deploy.outputs.deployed }}
              DOMAIN: ${{ inputs.domain }}
              EXPIRY: ${{ steps.certbot.outputs.expiry_date }}
              DOCKER_VOLUME: ${{ inputs.docker-volume-name }}
          run: |
              CERT_SOURCE="${{ steps.certbot.outputs.cert_source }}"

              echo "## üîê SSL Certificate Status" >> $GITHUB_STEP_SUMMARY

              if [ "$CERT_READY" == "true" ]; then
                if [ "$CERT_TYPE" == "letsencrypt" ]; then
                  echo "‚úÖ **Let's Encrypt** certificates generated for \`$DOMAIN\`" >> $GITHUB_STEP_SUMMARY
                elif [ "$CERT_TYPE" == "letsencrypt-cached" ]; then
                  echo "‚úÖ **Let's Encrypt** certificates found in Docker volume for \`$DOMAIN\`" >> $GITHUB_STEP_SUMMARY
                  echo "" >> $GITHUB_STEP_SUMMARY
                  echo "> **Note:** Certbot failed (likely rate limited), but valid Let's Encrypt certs already exist in volume \`$DOCKER_VOLUME\`." >> $GITHUB_STEP_SUMMARY
                  echo "> No action needed ‚Äî existing certs are still valid." >> $GITHUB_STEP_SUMMARY
                elif [ "$CERT_TYPE" == "self-signed-cached" ]; then
                  echo "‚ö†Ô∏è **Self-signed** certificates found in Docker volume for \`$DOMAIN\`" >> $GITHUB_STEP_SUMMARY
                  echo "" >> $GITHUB_STEP_SUMMARY
                  echo "> **Note:** Certbot failed and only self-signed certs exist in the volume." >> $GITHUB_STEP_SUMMARY
                  echo "> Browsers will show a security warning. Real certs will be obtained on next successful run." >> $GITHUB_STEP_SUMMARY
                else
                  echo "‚ö†Ô∏è **Self-signed** certificates generated for \`$DOMAIN\`" >> $GITHUB_STEP_SUMMARY
                  echo "" >> $GITHUB_STEP_SUMMARY
                  echo "> **Note:** Using self-signed certs due to Let's Encrypt failure (rate limits, credentials, etc.)" >> $GITHUB_STEP_SUMMARY
                  echo "> Browsers will show a security warning. Real certs will be obtained on next successful run." >> $GITHUB_STEP_SUMMARY
                fi

                echo "" >> $GITHUB_STEP_SUMMARY
                echo "üìÖ **Expires:** $EXPIRY" >> $GITHUB_STEP_SUMMARY

                if [ "$CERT_SOURCE" == "volume" ]; then
                  echo "üì¶ **Source:** Existing certs in Docker volume \`$DOCKER_VOLUME\` (no deployment needed)" >> $GITHUB_STEP_SUMMARY
                elif [ "$DEPLOYED" == "true" ]; then
                  echo "‚úÖ **Deployed** to Docker volume: \`$DOCKER_VOLUME\`" >> $GITHUB_STEP_SUMMARY
                elif [ "${{ inputs.deploy-to-server }}" == "true" ]; then
                  echo "‚ùå **Deployment failed**" >> $GITHUB_STEP_SUMMARY
                else
                  echo "‚è≠Ô∏è **Deployment skipped** (not requested)" >> $GITHUB_STEP_SUMMARY
                fi

                echo "" >> $GITHUB_STEP_SUMMARY
                echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
                echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
                echo "| Type | \`$CERT_TYPE\` |" >> $GITHUB_STEP_SUMMARY
                echo "| Source | \`${CERT_SOURCE:-certbot}\` |" >> $GITHUB_STEP_SUMMARY
                echo "| Domain | \`$DOMAIN\` |" >> $GITHUB_STEP_SUMMARY
                echo "| Volume | \`$DOCKER_VOLUME\` |" >> $GITHUB_STEP_SUMMARY
              else
                echo "‚ùå Certificate generation failed" >> $GITHUB_STEP_SUMMARY
              fi
